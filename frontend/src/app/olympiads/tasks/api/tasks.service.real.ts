/**
 * Tasks service API
 * API description in Markdown.
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core'
import { HttpClient, HttpEvent, HttpHeaders, HttpParams, HttpResponse } from '@angular/common/http'
import { CustomHttpUrlEncodingCodec } from '@/shared/encoder'

import { Observable } from 'rxjs'

import { AddStatus } from '../model/addStatus'
import { AllStatus } from '../model/allStatus'
import { CommonContestId } from '../model/commonContestId'
import { CommonContestInfo } from '../model/commonContestInfo'
import { ContestInfoUpdate } from '../model/contestInfoUpdate'
import { ContestsInStage } from '../model/contestsInStage'
import { CreateContest } from '../model/createContest'
import { CreateStage } from '../model/createStage'
import { CreateVariant } from '../model/createVariant'
import { InlineResponse200 } from '../model/inlineResponse200'
import { OlympiadCreateBody } from '../model/olympiadCreateBody'
import { StageInfo } from '../model/stageInfo'
import { StageInfoId } from '../model/stageInfoId'
import { StageInfoUpdate } from '../model/stageInfoUpdate'
import { StagesInOlympiad } from '../model/stagesInOlympiad'
import { StatusInfo } from '../model/statusInfo'
import { StatusInfoUpdate } from '../model/statusInfoUpdate'
import { TaskCreateBody } from '../model/taskCreateBody'
import { TaskId } from '../model/taskId'
import { TaskIdTaskBody } from '../model/taskIdTaskBody'
import { TaskInVariantImage } from '../model/taskInVariantImage'
import { TasksInVariant } from '../model/tasksInVariant'
import { UpdateUserInContest } from '../model/updateUserInContest'
import { UserCertificate } from '../model/userCertificate'
import { UsersInContest } from '../model/usersInContest'
import { VariantInfo } from '../model/variantInfo'
import { VariantInfoId } from '../model/variantInfoId'
import { VariantInfoUpdate } from '../model/variantInfoUpdate'
import { VariantsInContest } from '../model/variantsInContest'

import { BASE_PATH } from '../variables'
import { Configuration } from '../configuration'
import { TasksService } from '@/olympiads/tasks/api/tasks.service'


@Injectable()
export class TasksServiceReal implements TasksService
{
    protected basePath = '/'
    public defaultHeaders = new HttpHeaders()
    public configuration = new Configuration()

    constructor( protected httpClient: HttpClient, @Optional() @Inject( BASE_PATH ) basePath: string, @Optional() configuration: Configuration )
    {
        if ( basePath )
        {
            this.basePath = basePath
        }
        if ( configuration )
        {
            this.configuration = configuration
            this.basePath = basePath || configuration.basePath || this.basePath
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm( consumes: string[] ): boolean
    {
        const form = 'multipart/form-data'
        for ( const consume of consumes )
        {
            if ( form === consume )
            {
                return true
            }
        }
        return false
    }


    /**
     * list of olympiads (main contests)
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadAllGet( observe?: 'body', reportProgress?: boolean ): Observable<ContestsInStage>;
    olympiadAllGet( observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<ContestsInStage>>;
    olympiadAllGet( observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<ContestsInStage>>;
    olympiadAllGet( observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<ContestsInStage>( 'get', `${ this.basePath }/olympiad/all`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Create a new olympiad (main contest)
     *
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadCreatePost( body: OlympiadCreateBody, observe?: 'body', reportProgress?: boolean ): Observable<CommonContestId>;
    olympiadCreatePost( body: OlympiadCreateBody, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<CommonContestId>>;
    olympiadCreatePost( body: OlympiadCreateBody, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<CommonContestId>>;
    olympiadCreatePost( body: OlympiadCreateBody, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling olympiadCreatePost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<CommonContestId>( 'post', `${ this.basePath }/olympiad/create`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get info for the olympiad (main contest)
     *
     * @param idOlympiad Id of the olympiad
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadGet( idOlympiad: number, observe?: 'body', reportProgress?: boolean ): Observable<CommonContestInfo>;
    olympiadIdOlympiadGet( idOlympiad: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<CommonContestInfo>>;
    olympiadIdOlympiadGet( idOlympiad: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<CommonContestInfo>>;
    olympiadIdOlympiadGet( idOlympiad: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadGet.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<CommonContestInfo>( 'get', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Edit olympiad info
     *
     * @param body
     * @param idOlympiad Id of the olympiad
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadPatch( body: ContestInfoUpdate, idOlympiad: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    olympiadIdOlympiadPatch( body: ContestInfoUpdate, idOlympiad: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    olympiadIdOlympiadPatch( body: ContestInfoUpdate, idOlympiad: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    olympiadIdOlympiadPatch( body: ContestInfoUpdate, idOlympiad: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling olympiadIdOlympiadPatch.' )
        }

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadPatch.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<any>( 'patch', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Remove olympiad (main contest)
     *
     * @param idOlympiad Id of the olympiad
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadRemovePost( idOlympiad: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    olympiadIdOlympiadRemovePost( idOlympiad: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    olympiadIdOlympiadRemovePost( idOlympiad: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    olympiadIdOlympiadRemovePost( idOlympiad: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadRemovePost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<any>( 'post', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/remove`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * list of stages in olympiad
     *
     * @param idOlympiad Id of the olympiad
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageAllGet( idOlympiad: number, observe?: 'body', reportProgress?: boolean ): Observable<StagesInOlympiad>;
    olympiadIdOlympiadStageAllGet( idOlympiad: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<StagesInOlympiad>>;
    olympiadIdOlympiadStageAllGet( idOlympiad: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<StagesInOlympiad>>;
    olympiadIdOlympiadStageAllGet( idOlympiad: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageAllGet.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<StagesInOlympiad>( 'get', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/all`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Create a new stage in olympiad
     *
     * @param body
     * @param idOlympiad Id of the olympiad
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageCreatePost( body: CreateStage, idOlympiad: number, observe?: 'body', reportProgress?: boolean ): Observable<StageInfoId>;
    olympiadIdOlympiadStageCreatePost( body: CreateStage, idOlympiad: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<StageInfoId>>;
    olympiadIdOlympiadStageCreatePost( body: CreateStage, idOlympiad: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<StageInfoId>>;
    olympiadIdOlympiadStageCreatePost( body: CreateStage, idOlympiad: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling olympiadIdOlympiadStageCreatePost.' )
        }

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageCreatePost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<StageInfoId>( 'post', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/create`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * list of contests in stage
     *
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestAllGet( idOlympiad: number, idStage: number, observe?: 'body', reportProgress?: boolean ): Observable<ContestsInStage>;
    olympiadIdOlympiadStageIdStageContestAllGet( idOlympiad: number, idStage: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<ContestsInStage>>;
    olympiadIdOlympiadStageIdStageContestAllGet( idOlympiad: number, idStage: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<ContestsInStage>>;
    olympiadIdOlympiadStageIdStageContestAllGet( idOlympiad: number, idStage: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestAllGet.' )
        }

        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestAllGet.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<ContestsInStage>( 'get', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/all`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Create a new contest
     *
     * @param body
     * @param idStage Id of the stage
     * @param idOlympiad Id of the olympiad
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestCreatePost( body: CreateContest, idStage: number, idOlympiad: number, observe?: 'body', reportProgress?: boolean ): Observable<CommonContestId>;
    olympiadIdOlympiadStageIdStageContestCreatePost( body: CreateContest, idStage: number, idOlympiad: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<CommonContestId>>;
    olympiadIdOlympiadStageIdStageContestCreatePost( body: CreateContest, idStage: number, idOlympiad: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<CommonContestId>>;
    olympiadIdOlympiadStageIdStageContestCreatePost( body: CreateContest, idStage: number, idOlympiad: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling olympiadIdOlympiadStageIdStageContestCreatePost.' )
        }

        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestCreatePost.' )
        }

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestCreatePost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<CommonContestId>( 'post', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/create`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Add user to contest
     *
     * @param body
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestAdduserPost( body: UpdateUserInContest, idOlympiad: number, idStage: number, idContest: number, observe?: 'body', reportProgress?: boolean ): Observable<UpdateUserInContest>;
    olympiadIdOlympiadStageIdStageContestIdContestAdduserPost( body: UpdateUserInContest, idOlympiad: number, idStage: number, idContest: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<UpdateUserInContest>>;
    olympiadIdOlympiadStageIdStageContestIdContestAdduserPost( body: UpdateUserInContest, idOlympiad: number, idStage: number, idContest: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<UpdateUserInContest>>;
    olympiadIdOlympiadStageIdStageContestIdContestAdduserPost( body: UpdateUserInContest, idOlympiad: number, idStage: number, idContest: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestAdduserPost.' )
        }

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestAdduserPost.' )
        }

        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestAdduserPost.' )
        }

        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestAdduserPost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<UpdateUserInContest>( 'post', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/adduser`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get common info for a contest
     *
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestGet( idOlympiad: number, idStage: number, idContest: number, observe?: 'body', reportProgress?: boolean ): Observable<CommonContestInfo>;
    olympiadIdOlympiadStageIdStageContestIdContestGet( idOlympiad: number, idStage: number, idContest: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<CommonContestInfo>>;
    olympiadIdOlympiadStageIdStageContestIdContestGet( idOlympiad: number, idStage: number, idContest: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<CommonContestInfo>>;
    olympiadIdOlympiadStageIdStageContestIdContestGet( idOlympiad: number, idStage: number, idContest: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestGet.' )
        }

        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestGet.' )
        }

        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestGet.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<CommonContestInfo>( 'get', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Add user to contest
     *
     * @param body
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestMoveuserPost( body: UpdateUserInContest, idOlympiad: number, idStage: number, idContest: number, observe?: 'body', reportProgress?: boolean ): Observable<UpdateUserInContest>;
    olympiadIdOlympiadStageIdStageContestIdContestMoveuserPost( body: UpdateUserInContest, idOlympiad: number, idStage: number, idContest: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<UpdateUserInContest>>;
    olympiadIdOlympiadStageIdStageContestIdContestMoveuserPost( body: UpdateUserInContest, idOlympiad: number, idStage: number, idContest: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<UpdateUserInContest>>;
    olympiadIdOlympiadStageIdStageContestIdContestMoveuserPost( body: UpdateUserInContest, idOlympiad: number, idStage: number, idContest: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestMoveuserPost.' )
        }

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestMoveuserPost.' )
        }

        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestMoveuserPost.' )
        }

        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestMoveuserPost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<UpdateUserInContest>( 'post', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/moveuser`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Edit contest info
     *
     * @param body
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestPatch( body: ContestInfoUpdate, idOlympiad: number, idStage: number, idContest: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    olympiadIdOlympiadStageIdStageContestIdContestPatch( body: ContestInfoUpdate, idOlympiad: number, idStage: number, idContest: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    olympiadIdOlympiadStageIdStageContestIdContestPatch( body: ContestInfoUpdate, idOlympiad: number, idStage: number, idContest: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    olympiadIdOlympiadStageIdStageContestIdContestPatch( body: ContestInfoUpdate, idOlympiad: number, idStage: number, idContest: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestPatch.' )
        }

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestPatch.' )
        }

        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestPatch.' )
        }

        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestPatch.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<any>( 'patch', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Remove contest
     *
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestRemovePost( idOlympiad: number, idStage: number, idContest: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    olympiadIdOlympiadStageIdStageContestIdContestRemovePost( idOlympiad: number, idStage: number, idContest: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    olympiadIdOlympiadStageIdStageContestIdContestRemovePost( idOlympiad: number, idStage: number, idContest: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    olympiadIdOlympiadStageIdStageContestIdContestRemovePost( idOlympiad: number, idStage: number, idContest: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestRemovePost.' )
        }

        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestRemovePost.' )
        }

        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestRemovePost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<any>( 'post', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/remove`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Remove user from contest
     *
     * @param body
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestRemoveuserPost( body: UpdateUserInContest, idOlympiad: number, idStage: number, idContest: number, observe?: 'body', reportProgress?: boolean ): Observable<UpdateUserInContest>;
    olympiadIdOlympiadStageIdStageContestIdContestRemoveuserPost( body: UpdateUserInContest, idOlympiad: number, idStage: number, idContest: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<UpdateUserInContest>>;
    olympiadIdOlympiadStageIdStageContestIdContestRemoveuserPost( body: UpdateUserInContest, idOlympiad: number, idStage: number, idContest: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<UpdateUserInContest>>;
    olympiadIdOlympiadStageIdStageContestIdContestRemoveuserPost( body: UpdateUserInContest, idOlympiad: number, idStage: number, idContest: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestRemoveuserPost.' )
        }

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestRemoveuserPost.' )
        }

        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestRemoveuserPost.' )
        }

        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestRemoveuserPost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<UpdateUserInContest>( 'post', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/removeuser`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * list of user in contest
     *
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestUserAllGet( idOlympiad: number, idStage: number, idContest: number, observe?: 'body', reportProgress?: boolean ): Observable<UsersInContest>;
    olympiadIdOlympiadStageIdStageContestIdContestUserAllGet( idOlympiad: number, idStage: number, idContest: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<UsersInContest>>;
    olympiadIdOlympiadStageIdStageContestIdContestUserAllGet( idOlympiad: number, idStage: number, idContest: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<UsersInContest>>;
    olympiadIdOlympiadStageIdStageContestIdContestUserAllGet( idOlympiad: number, idStage: number, idContest: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestUserAllGet.' )
        }

        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestUserAllGet.' )
        }

        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestUserAllGet.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<UsersInContest>( 'get', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/user/all`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * certificate of user in contest
     *
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param idUser Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestUserIdUserCertificateGet( idOlympiad: number, idStage: number, idContest: number, idUser: number, observe?: 'body', reportProgress?: boolean ): Observable<UserCertificate>;
    olympiadIdOlympiadStageIdStageContestIdContestUserIdUserCertificateGet( idOlympiad: number, idStage: number, idContest: number, idUser: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<UserCertificate>>;
    olympiadIdOlympiadStageIdStageContestIdContestUserIdUserCertificateGet( idOlympiad: number, idStage: number, idContest: number, idUser: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<UserCertificate>>;
    olympiadIdOlympiadStageIdStageContestIdContestUserIdUserCertificateGet( idOlympiad: number, idStage: number, idContest: number, idUser: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestUserIdUserCertificateGet.' )
        }

        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestUserIdUserCertificateGet.' )
        }

        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestUserIdUserCertificateGet.' )
        }

        if ( idUser === null || idUser === undefined )
        {
            throw new Error( 'Required parameter idUser was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestUserIdUserCertificateGet.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<UserCertificate>( 'get', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/user/${ encodeURIComponent( String( idUser ) ) }/certificate`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * list of variants in contest
     *
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestVariantAllGet( idOlympiad: number, idStage: number, idContest: number, observe?: 'body', reportProgress?: boolean ): Observable<VariantsInContest>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantAllGet( idOlympiad: number, idStage: number, idContest: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<VariantsInContest>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantAllGet( idOlympiad: number, idStage: number, idContest: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<VariantsInContest>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantAllGet( idOlympiad: number, idStage: number, idContest: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantAllGet.' )
        }

        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantAllGet.' )
        }

        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantAllGet.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<VariantsInContest>( 'get', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/variant/all`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Create a new variant
     *
     * @param body
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestVariantCreatePost( body: CreateVariant, idOlympiad: number, idStage: number, idContest: number, observe?: 'body', reportProgress?: boolean ): Observable<VariantInfoId>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantCreatePost( body: CreateVariant, idOlympiad: number, idStage: number, idContest: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<VariantInfoId>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantCreatePost( body: CreateVariant, idOlympiad: number, idStage: number, idContest: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<VariantInfoId>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantCreatePost( body: CreateVariant, idOlympiad: number, idStage: number, idContest: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantCreatePost.' )
        }

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantCreatePost.' )
        }

        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantCreatePost.' )
        }

        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantCreatePost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<VariantInfoId>( 'post', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/variant/create`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Remove variant
     *
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param idVariant Id of the variant
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantRemovePost( idOlympiad: number, idStage: number, idContest: number, idVariant: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantRemovePost( idOlympiad: number, idStage: number, idContest: number, idVariant: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantRemovePost( idOlympiad: number, idStage: number, idContest: number, idVariant: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantRemovePost( idOlympiad: number, idStage: number, idContest: number, idVariant: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantRemovePost.' )
        }

        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantRemovePost.' )
        }

        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantRemovePost.' )
        }

        if ( idVariant === null || idVariant === undefined )
        {
            throw new Error( 'Required parameter idVariant was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantRemovePost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<any>( 'post', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( idVariant ) ) }/remove`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Create a new task
     *
     * @param body
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param idVariant Id of the variant
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskCreatePost( body: TaskCreateBody, idOlympiad: number, idStage: number, idContest: number, idVariant: number, observe?: 'body', reportProgress?: boolean ): Observable<TaskId>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskCreatePost( body: TaskCreateBody, idOlympiad: number, idStage: number, idContest: number, idVariant: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<TaskId>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskCreatePost( body: TaskCreateBody, idOlympiad: number, idStage: number, idContest: number, idVariant: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<TaskId>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskCreatePost( body: TaskCreateBody, idOlympiad: number, idStage: number, idContest: number, idVariant: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskCreatePost.' )
        }

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskCreatePost.' )
        }

        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskCreatePost.' )
        }

        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskCreatePost.' )
        }

        if ( idVariant === null || idVariant === undefined )
        {
            throw new Error( 'Required parameter idVariant was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskCreatePost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<TaskId>( 'post', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( idVariant ) ) }/task/create`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get info for a different tasks
     *
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param idVariant Id of the variant
     * @param idTask Id of the task
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskGet( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe?: 'body', reportProgress?: boolean ): Observable<InlineResponse200>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskGet( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<InlineResponse200>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskGet( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<InlineResponse200>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskGet( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskGet.' )
        }

        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskGet.' )
        }

        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskGet.' )
        }

        if ( idVariant === null || idVariant === undefined )
        {
            throw new Error( 'Required parameter idVariant was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskGet.' )
        }

        if ( idTask === null || idTask === undefined )
        {
            throw new Error( 'Required parameter idTask was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskGet.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<InlineResponse200>( 'get', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( idVariant ) ) }/task/${ encodeURIComponent( String( idTask ) ) }`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Update task info
     *
     * @param body
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param idVariant Id of the variant
     * @param idTask Id of the task
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskPatch( body: TaskIdTaskBody, idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskPatch( body: TaskIdTaskBody, idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskPatch( body: TaskIdTaskBody, idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskPatch( body: TaskIdTaskBody, idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskPatch.' )
        }

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskPatch.' )
        }

        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskPatch.' )
        }

        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskPatch.' )
        }

        if ( idVariant === null || idVariant === undefined )
        {
            throw new Error( 'Required parameter idVariant was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskPatch.' )
        }

        if ( idTask === null || idTask === undefined )
        {
            throw new Error( 'Required parameter idTask was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskPatch.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<any>( 'patch', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( idVariant ) ) }/task/${ encodeURIComponent( String( idTask ) ) }`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Remove task
     *
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param idVariant Id of the variant
     * @param idTask Id of the task
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskRemovePost( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskRemovePost( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskRemovePost( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskRemovePost( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskRemovePost.' )
        }

        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskRemovePost.' )
        }

        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskRemovePost.' )
        }

        if ( idVariant === null || idVariant === undefined )
        {
            throw new Error( 'Required parameter idVariant was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskRemovePost.' )
        }

        if ( idTask === null || idTask === undefined )
        {
            throw new Error( 'Required parameter idTask was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskRemovePost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<any>( 'post', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( idVariant ) ) }/task/${ encodeURIComponent( String( idTask ) ) }/remove`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * list of tasks in variant
     *
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param idVariant Id of the variant
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksAllGet( idOlympiad: number, idStage: number, idContest: number, idVariant: number, observe?: 'body', reportProgress?: boolean ): Observable<TasksInVariant>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksAllGet( idOlympiad: number, idStage: number, idContest: number, idVariant: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<TasksInVariant>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksAllGet( idOlympiad: number, idStage: number, idContest: number, idVariant: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<TasksInVariant>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksAllGet( idOlympiad: number, idStage: number, idContest: number, idVariant: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksAllGet.' )
        }

        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksAllGet.' )
        }

        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksAllGet.' )
        }

        if ( idVariant === null || idVariant === undefined )
        {
            throw new Error( 'Required parameter idVariant was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksAllGet.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<TasksInVariant>( 'get', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( idVariant ) ) }/tasks/all`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Task image
     *
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param idVariant Id of the variant
     * @param idTask Id of the task
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksIdTaskTaskimageGet( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe?: 'body', reportProgress?: boolean ): Observable<TaskInVariantImage>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksIdTaskTaskimageGet( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<TaskInVariantImage>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksIdTaskTaskimageGet( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<TaskInVariantImage>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksIdTaskTaskimageGet( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksIdTaskTaskimageGet.' )
        }

        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksIdTaskTaskimageGet.' )
        }

        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksIdTaskTaskimageGet.' )
        }

        if ( idVariant === null || idVariant === undefined )
        {
            throw new Error( 'Required parameter idVariant was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksIdTaskTaskimageGet.' )
        }

        if ( idTask === null || idTask === undefined )
        {
            throw new Error( 'Required parameter idTask was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksIdTaskTaskimageGet.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<TaskInVariantImage>( 'get', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( idVariant ) ) }/tasks/${ encodeURIComponent( String( idTask ) ) }/taskimage`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get info for a different variant
     *
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param variantNum Number of the variant in contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumGet( idOlympiad: number, idStage: number, idContest: number, variantNum: number, observe?: 'body', reportProgress?: boolean ): Observable<VariantInfo>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumGet( idOlympiad: number, idStage: number, idContest: number, variantNum: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<VariantInfo>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumGet( idOlympiad: number, idStage: number, idContest: number, variantNum: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<VariantInfo>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumGet( idOlympiad: number, idStage: number, idContest: number, variantNum: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumGet.' )
        }

        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumGet.' )
        }

        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumGet.' )
        }

        if ( variantNum === null || variantNum === undefined )
        {
            throw new Error( 'Required parameter variantNum was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumGet.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<VariantInfo>( 'get', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( variantNum ) ) }`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Edit variant
     *
     * @param body
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param variantNum Number of the variant in contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumPatch( body: VariantInfoUpdate, idOlympiad: number, idStage: number, idContest: number, variantNum: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumPatch( body: VariantInfoUpdate, idOlympiad: number, idStage: number, idContest: number, variantNum: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumPatch( body: VariantInfoUpdate, idOlympiad: number, idStage: number, idContest: number, variantNum: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumPatch( body: VariantInfoUpdate, idOlympiad: number, idStage: number, idContest: number, variantNum: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumPatch.' )
        }

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumPatch.' )
        }

        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumPatch.' )
        }

        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumPatch.' )
        }

        if ( variantNum === null || variantNum === undefined )
        {
            throw new Error( 'Required parameter variantNum was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumPatch.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<any>( 'patch', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( variantNum ) ) }`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get common info for a different stage
     *
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageGet( idOlympiad: number, idStage: number, observe?: 'body', reportProgress?: boolean ): Observable<StageInfo>;
    olympiadIdOlympiadStageIdStageGet( idOlympiad: number, idStage: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<StageInfo>>;
    olympiadIdOlympiadStageIdStageGet( idOlympiad: number, idStage: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<StageInfo>>;
    olympiadIdOlympiadStageIdStageGet( idOlympiad: number, idStage: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageGet.' )
        }

        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageGet.' )
        }

        let headers = this.defaultHeaders

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<StageInfo>( 'get', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Set stage info for a olympiad
     *
     * @param body
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStagePatch( body: StageInfoUpdate, idOlympiad: number, idStage: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    olympiadIdOlympiadStageIdStagePatch( body: StageInfoUpdate, idOlympiad: number, idStage: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    olympiadIdOlympiadStageIdStagePatch( body: StageInfoUpdate, idOlympiad: number, idStage: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    olympiadIdOlympiadStageIdStagePatch( body: StageInfoUpdate, idOlympiad: number, idStage: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling olympiadIdOlympiadStageIdStagePatch.' )
        }

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStagePatch.' )
        }

        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStagePatch.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<any>( 'patch', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Remove stage from olympiad
     *
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageRemovePost( idOlympiad: number, idStage: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    olympiadIdOlympiadStageIdStageRemovePost( idOlympiad: number, idStage: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    olympiadIdOlympiadStageIdStageRemovePost( idOlympiad: number, idStage: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    olympiadIdOlympiadStageIdStageRemovePost( idOlympiad: number, idStage: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageRemovePost.' )
        }

        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageRemovePost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<any>( 'post', `${ this.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/remove`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * add new user status to library
     *
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userStatusAddPost( body: AddStatus, observe?: 'body', reportProgress?: boolean ): Observable<StatusInfo>;
    userStatusAddPost( body: AddStatus, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<StatusInfo>>;
    userStatusAddPost( body: AddStatus, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<StatusInfo>>;
    userStatusAddPost( body: AddStatus, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling userStatusAddPost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<StatusInfo>( 'post', `${ this.basePath }/user_status/add`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * list of user_status
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userStatusAllGet( observe?: 'body', reportProgress?: boolean ): Observable<AllStatus>;
    userStatusAllGet( observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<AllStatus>>;
    userStatusAllGet( observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<AllStatus>>;
    userStatusAllGet( observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<AllStatus>( 'get', `${ this.basePath }/user_status/all`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get info for the user_status
     *
     * @param idStatus Id of the user_status
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userStatusIdStatusGet( idStatus: number, observe?: 'body', reportProgress?: boolean ): Observable<StatusInfo>;
    userStatusIdStatusGet( idStatus: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<StatusInfo>>;
    userStatusIdStatusGet( idStatus: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<StatusInfo>>;
    userStatusIdStatusGet( idStatus: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( idStatus === null || idStatus === undefined )
        {
            throw new Error( 'Required parameter idStatus was null or undefined when calling userStatusIdStatusGet.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<StatusInfo>( 'get', `${ this.basePath }/user_status/${ encodeURIComponent( String( idStatus ) ) }`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Edit user_status
     *
     * @param body
     * @param idStatus Id of the user_status
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userStatusIdStatusPatch( body: StatusInfoUpdate, idStatus: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    userStatusIdStatusPatch( body: StatusInfoUpdate, idStatus: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    userStatusIdStatusPatch( body: StatusInfoUpdate, idStatus: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    userStatusIdStatusPatch( body: StatusInfoUpdate, idStatus: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling userStatusIdStatusPatch.' )
        }

        if ( idStatus === null || idStatus === undefined )
        {
            throw new Error( 'Required parameter idStatus was null or undefined when calling userStatusIdStatusPatch.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<any>( 'patch', `${ this.basePath }/user_status/${ encodeURIComponent( String( idStatus ) ) }`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Remove user_status
     *
     * @param idStatus Id of the user_status
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userStatusIdStatusRemovePost( idStatus: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    userStatusIdStatusRemovePost( idStatus: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    userStatusIdStatusRemovePost( idStatus: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    userStatusIdStatusRemovePost( idStatus: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( idStatus === null || idStatus === undefined )
        {
            throw new Error( 'Required parameter idStatus was null or undefined when calling userStatusIdStatusRemovePost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (cookieJWTAuth) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<any>( 'post', `${ this.basePath }/user_status//${ encodeURIComponent( String( idStatus ) ) }/remove`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

}
