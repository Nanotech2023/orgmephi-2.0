/**
 * User service API
 * API description in Markdown.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core'
import { HttpClient, HttpEvent, HttpHeaders, HttpParameterCodec, HttpParams, HttpResponse } from '@angular/common/http'
import { CustomHttpParameterCodec } from '@/shared/encoder'
import { Observable } from 'rxjs'

import {
    RequestGroupAdd,
    RequestLogin,
    RequestPasswordAdmin,
    RequestPasswordSelf,
    RequestRegistration,
    RequestUserGroupsAdd,
    RequestUserGroupsRemove,
    RequestUserRole,
    RequestUserType,
    ResponseGroupAll,
    ResponseInfoCountries,
    ResponseInfoUniversities,
    ResponseUserAdminGroup,
    ResponseUserAll,
    ResponseUserByGroup,
    ResponseUserSelfGroup,
    TypeAuthCredentials,
    TypeCSRFPair,
    TypeGroup,
    TypePersonalInfo,
    TypePreregisterInfo,
    TypeStudentInfo,
    TypeUserInfo
} from '@/auth/api/models'

import { BASE_PATH } from '../variables'
import { Configuration } from '../configuration'
import { AuthService } from '@/auth/api/auth.service'


@Injectable( {
    providedIn: 'root'
} )
export class AuthServiceReal implements AuthService
{
    protected basePath = 'http://127.0.0.1:5000'
    public defaultHeaders = new HttpHeaders()
    public configuration = new Configuration()
    public encoder: HttpParameterCodec

    constructor( protected httpClient: HttpClient, @Optional() @Inject( BASE_PATH ) basePath: string, @Optional() configuration: Configuration )
    {
        if ( configuration )
        {
            this.configuration = configuration
        }
        if ( typeof this.configuration.basePath !== 'string' )
        {
            if ( typeof basePath !== 'string' )
            {
                basePath = this.basePath
            }
            this.configuration.basePath = basePath
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec()
    }


    addToHttpParams( httpParams: HttpParams, value: any, key?: string ): HttpParams
    {
        if ( typeof value === "object" && value instanceof Date === false )
        {
            httpParams = this.addToHttpParamsRecursive( httpParams, value )
        }
        else
        {
            httpParams = this.addToHttpParamsRecursive( httpParams, value, key )
        }
        return httpParams
    }

    addToHttpParamsRecursive( httpParams: HttpParams, value?: any, key?: string ): HttpParams
    {
        if ( value == null )
        {
            return httpParams
        }

        if ( typeof value === "object" )
        {
            if ( Array.isArray( value ) )
            {
                ( value as any[] ).forEach( elem => httpParams = this.addToHttpParamsRecursive( httpParams, elem, key ) )
            }
            else if ( value instanceof Date )
            {
                if ( key != null )
                {
                    httpParams = httpParams.append( key,
                        ( value as Date ).toISOString().substr( 0, 10 ) )
                }
                else
                {
                    throw Error( "key may not be null if value is Date" )
                }
            }
            else
            {
                Object.keys( value ).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[ k ], key != null ? `${ key }.${ k }` : k ) )
            }
        }
        else if ( key != null )
        {
            httpParams = httpParams.append( key, value )
        }
        else
        {
            throw Error( "key may not be null if value is not object or array" )
        }
        return httpParams
    }

    /**
     * Add a group
     * Add a group, only for admins
     * @param requestGroupAdd
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    groupAddPost( requestGroupAdd: RequestGroupAdd, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<TypeGroup>;
    groupAddPost( requestGroupAdd: RequestGroupAdd, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<TypeGroup>>;
    groupAddPost( requestGroupAdd: RequestGroupAdd, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<TypeGroup>>;
    groupAddPost( requestGroupAdd: RequestGroupAdd, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( requestGroupAdd === null || requestGroupAdd === undefined )
        {
            throw new Error( 'Required parameter requestGroupAdd was null or undefined when calling groupAddPost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAcessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAcessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAcessToken) required
        credential = this.configuration.lookupCredential( 'JWTAcessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<TypeGroup>( `${ this.configuration.basePath }/group/add`,
            requestGroupAdd,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get all groups
     * Get all group list, only for admins and creators
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    groupAllGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<ResponseGroupAll>;
    groupAllGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<ResponseGroupAll>>;
    groupAllGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<ResponseGroupAll>>;
    groupAllGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (JWTAcessToken) required
        credential = this.configuration.lookupCredential( 'JWTAcessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<ResponseGroupAll>( `${ this.configuration.basePath }/group/all`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get any group
     * Get any group, only for admins and creators
     * @param groupId Id of the group
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    groupGroupIdGet( groupId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<TypeGroup>;
    groupGroupIdGet( groupId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<TypeGroup>>;
    groupGroupIdGet( groupId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<TypeGroup>>;
    groupGroupIdGet( groupId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( groupId === null || groupId === undefined )
        {
            throw new Error( 'Required parameter groupId was null or undefined when calling groupGroupIdGet.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (JWTAcessToken) required
        credential = this.configuration.lookupCredential( 'JWTAcessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<TypeGroup>( `${ this.configuration.basePath }/group/${ encodeURIComponent( String( groupId ) ) }`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Delete a group
     * Add a group, only for admins
     * @param groupId ID of the group
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    groupGroupIdRemovePost( groupId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>;
    groupGroupIdRemovePost( groupId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<any>>;
    groupGroupIdRemovePost( groupId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<any>>;
    groupGroupIdRemovePost( groupId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( groupId === null || groupId === undefined )
        {
            throw new Error( 'Required parameter groupId was null or undefined when calling groupGroupIdRemovePost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAcessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAcessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAcessToken) required
        credential = this.configuration.lookupCredential( 'JWTAcessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/group/${ encodeURIComponent( String( groupId ) ) }/remove`,
            null,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get known country list
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    infoCountriesGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<ResponseInfoCountries>;
    infoCountriesGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<ResponseInfoCountries>>;
    infoCountriesGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<ResponseInfoCountries>>;
    infoCountriesGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<ResponseInfoCountries>( `${ this.configuration.basePath }/info/countries`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get known university list
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    infoUniversitiesGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<ResponseInfoUniversities>;
    infoUniversitiesGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<ResponseInfoUniversities>>;
    infoUniversitiesGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<ResponseInfoUniversities>>;
    infoUniversitiesGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<ResponseInfoUniversities>( `${ this.configuration.basePath }/info/universities`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Authenticate a user
     * @param requestLogin
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    loginPost( requestLogin: RequestLogin, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<TypeCSRFPair>;
    loginPost( requestLogin: RequestLogin, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<TypeCSRFPair>>;
    loginPost( requestLogin: RequestLogin, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<TypeCSRFPair>>;
    loginPost( requestLogin: RequestLogin, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( requestLogin === null || requestLogin === undefined )
        {
            throw new Error( 'Required parameter requestLogin was null or undefined when calling loginPost.' )
        }

        let headers = this.defaultHeaders

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<TypeCSRFPair>( `${ this.configuration.basePath }/login`,
            requestLogin,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Logout current user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    logoutPost( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<any>;
    logoutPost( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpResponse<any>>;
    logoutPost( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpEvent<any>>;
    logoutPost( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAcessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAcessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAcessToken) required
        credential = this.configuration.lookupCredential( 'JWTAcessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/logout`,
            null,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Register an unconfirmed user with a one-time password
     * Register an unconfirmed user with a one-time password, creators and admins only
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    preregisterPost( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<TypePreregisterInfo>;
    preregisterPost( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<TypePreregisterInfo>>;
    preregisterPost( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<TypePreregisterInfo>>;
    preregisterPost( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAcessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAcessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAcessToken) required
        credential = this.configuration.lookupCredential( 'JWTAcessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<TypePreregisterInfo>( `${ this.configuration.basePath }/preregister`,
            null,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Refresh JWT token for current user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    refreshPost( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<TypeCSRFPair>;
    refreshPost( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<TypeCSRFPair>>;
    refreshPost( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<TypeCSRFPair>>;
    refreshPost( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFRefreshToken) required
        credential = this.configuration.lookupCredential( 'CSRFRefreshToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTRefreshToken) required
        credential = this.configuration.lookupCredential( 'JWTRefreshToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<TypeCSRFPair>( `${ this.configuration.basePath }/refresh`,
            null,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Register an internal user
     * Register an internal user, admin only
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    registerInternalPost( body: TypeAuthCredentials, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<TypeUserInfo>;
    registerInternalPost( body: TypeAuthCredentials, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<TypeUserInfo>>;
    registerInternalPost( body: TypeAuthCredentials, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<TypeUserInfo>>;
    registerInternalPost( body: TypeAuthCredentials, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling registerInternalPost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAcessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAcessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAcessToken) required
        credential = this.configuration.lookupCredential( 'JWTAcessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<TypeUserInfo>( `${ this.configuration.basePath }/register/internal`,
            body,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Register a new user
     * @param requestRegistration
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    registerPost( requestRegistration: RequestRegistration, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<TypeUserInfo>;
    registerPost( requestRegistration: RequestRegistration, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<TypeUserInfo>>;
    registerPost( requestRegistration: RequestRegistration, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<TypeUserInfo>>;
    registerPost( requestRegistration: RequestRegistration, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( requestRegistration === null || requestRegistration === undefined )
        {
            throw new Error( 'Required parameter requestRegistration was null or undefined when calling registerPost.' )
        }

        let headers = this.defaultHeaders

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<TypeUserInfo>( `${ this.configuration.basePath }/register`,
            requestRegistration,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get common info for all users
     * Get info about all users, only for admins and creators
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userAllGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<ResponseUserAll>;
    userAllGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<ResponseUserAll>>;
    userAllGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<ResponseUserAll>>;
    userAllGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (JWTAcessToken) required
        credential = this.configuration.lookupCredential( 'JWTAcessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<ResponseUserAll>( `${ this.configuration.basePath }/user/all`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get common info for different users
     * Get info about any user by their group, only for admins and creators
     * @param groupId ID of the group
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userByGroupGroupIdGet( groupId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<ResponseUserByGroup>;
    userByGroupGroupIdGet( groupId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<ResponseUserByGroup>>;
    userByGroupGroupIdGet( groupId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<ResponseUserByGroup>>;
    userByGroupGroupIdGet( groupId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( groupId === null || groupId === undefined )
        {
            throw new Error( 'Required parameter groupId was null or undefined when calling userByGroupGroupIdGet.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (JWTAcessToken) required
        credential = this.configuration.lookupCredential( 'JWTAcessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<ResponseUserByGroup>( `${ this.configuration.basePath }/user/by-group/${ encodeURIComponent( String( groupId ) ) }`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get common info for current user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userSelfGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<TypeUserInfo>;
    userSelfGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<TypeUserInfo>>;
    userSelfGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<TypeUserInfo>>;
    userSelfGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let credential: string | undefined

        // authentication (CSRFAcessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAcessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAcessToken) required
        credential = this.configuration.lookupCredential( 'JWTAcessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<TypeUserInfo>( `${ this.configuration.basePath }/user/self`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get groups for current user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userSelfGroupsGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<ResponseUserSelfGroup>;
    userSelfGroupsGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<ResponseUserSelfGroup>>;
    userSelfGroupsGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<ResponseUserSelfGroup>>;
    userSelfGroupsGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (JWTAcessToken) required
        credential = this.configuration.lookupCredential( 'JWTAcessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<ResponseUserSelfGroup>( `${ this.configuration.basePath }/user/self/groups`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Change password for current user
     * @param requestPasswordSelf
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userSelfPasswordPost( requestPasswordSelf: RequestPasswordSelf, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>;
    userSelfPasswordPost( requestPasswordSelf: RequestPasswordSelf, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<any>>;
    userSelfPasswordPost( requestPasswordSelf: RequestPasswordSelf, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<any>>;
    userSelfPasswordPost( requestPasswordSelf: RequestPasswordSelf, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( requestPasswordSelf === null || requestPasswordSelf === undefined )
        {
            throw new Error( 'Required parameter requestPasswordSelf was null or undefined when calling userSelfPasswordPost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAcessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAcessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAcessToken) required
        credential = this.configuration.lookupCredential( 'JWTAcessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/user/self/password`,
            requestPasswordSelf,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get personal info for current user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userSelfPersonalGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<TypePersonalInfo>;
    userSelfPersonalGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<TypePersonalInfo>>;
    userSelfPersonalGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<TypePersonalInfo>>;
    userSelfPersonalGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (JWTAcessToken) required
        credential = this.configuration.lookupCredential( 'JWTAcessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<TypePersonalInfo>( `${ this.configuration.basePath }/user/self/personal`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get university student info for current user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userSelfUniversityGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<TypePersonalInfo>;
    userSelfUniversityGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<TypePersonalInfo>>;
    userSelfUniversityGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<TypePersonalInfo>>;
    userSelfUniversityGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (JWTAcessToken) required
        credential = this.configuration.lookupCredential( 'JWTAcessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<TypePersonalInfo>( `${ this.configuration.basePath }/user/self/university`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get common info for a different user
     * Get info about any user by its id, only for admins and creators
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userUserIdGet( userId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<TypeUserInfo>;
    userUserIdGet( userId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<TypeUserInfo>>;
    userUserIdGet( userId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<TypeUserInfo>>;
    userUserIdGet( userId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userUserIdGet.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (JWTAcessToken) required
        credential = this.configuration.lookupCredential( 'JWTAcessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<TypeUserInfo>( `${ this.configuration.basePath }/user/${ encodeURIComponent( String( userId ) ) }`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Assign a user to a group
     * Assign a user to a group, only for admins and creators
     * @param userId Id of the user
     * @param requestUserGroupsAdd
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userUserIdGroupsAddPost( userId: number, requestUserGroupsAdd: RequestUserGroupsAdd, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>;
    userUserIdGroupsAddPost( userId: number, requestUserGroupsAdd: RequestUserGroupsAdd, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<any>>;
    userUserIdGroupsAddPost( userId: number, requestUserGroupsAdd: RequestUserGroupsAdd, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<any>>;
    userUserIdGroupsAddPost( userId: number, requestUserGroupsAdd: RequestUserGroupsAdd, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userUserIdGroupsAddPost.' )
        }
        if ( requestUserGroupsAdd === null || requestUserGroupsAdd === undefined )
        {
            throw new Error( 'Required parameter requestUserGroupsAdd was null or undefined when calling userUserIdGroupsAddPost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAcessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAcessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAcessToken) required
        credential = this.configuration.lookupCredential( 'JWTAcessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/user/${ encodeURIComponent( String( userId ) ) }/groups/add`,
            requestUserGroupsAdd,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get groups for a different user
     * Get group list for any user by its id, only for admins and creators
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userUserIdGroupsGet( userId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<ResponseUserAdminGroup>;
    userUserIdGroupsGet( userId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<ResponseUserAdminGroup>>;
    userUserIdGroupsGet( userId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<ResponseUserAdminGroup>>;
    userUserIdGroupsGet( userId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userUserIdGroupsGet.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (JWTAcessToken) required
        credential = this.configuration.lookupCredential( 'JWTAcessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<ResponseUserAdminGroup>( `${ this.configuration.basePath }/user/${ encodeURIComponent( String( userId ) ) }/groups`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Remove a user from a group
     * Remove a user from a group, only for admins and creators
     * @param userId Id of the user
     * @param requestUserGroupsRemove
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userUserIdGroupsRemovePost( userId: number, requestUserGroupsRemove: RequestUserGroupsRemove, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>;
    userUserIdGroupsRemovePost( userId: number, requestUserGroupsRemove: RequestUserGroupsRemove, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<any>>;
    userUserIdGroupsRemovePost( userId: number, requestUserGroupsRemove: RequestUserGroupsRemove, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<any>>;
    userUserIdGroupsRemovePost( userId: number, requestUserGroupsRemove: RequestUserGroupsRemove, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userUserIdGroupsRemovePost.' )
        }
        if ( requestUserGroupsRemove === null || requestUserGroupsRemove === undefined )
        {
            throw new Error( 'Required parameter requestUserGroupsRemove was null or undefined when calling userUserIdGroupsRemovePost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAcessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAcessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAcessToken) required
        credential = this.configuration.lookupCredential( 'JWTAcessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/user/${ encodeURIComponent( String( userId ) ) }/groups/remove`,
            requestUserGroupsRemove,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Change password for another user
     * Change password for another user, admins only
     * @param userId Id of the user
     * @param requestPasswordAdmin
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userUserIdPasswordPost( userId: number, requestPasswordAdmin: RequestPasswordAdmin, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>;
    userUserIdPasswordPost( userId: number, requestPasswordAdmin: RequestPasswordAdmin, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<any>>;
    userUserIdPasswordPost( userId: number, requestPasswordAdmin: RequestPasswordAdmin, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<any>>;
    userUserIdPasswordPost( userId: number, requestPasswordAdmin: RequestPasswordAdmin, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userUserIdPasswordPost.' )
        }
        if ( requestPasswordAdmin === null || requestPasswordAdmin === undefined )
        {
            throw new Error( 'Required parameter requestPasswordAdmin was null or undefined when calling userUserIdPasswordPost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAcessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAcessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAcessToken) required
        credential = this.configuration.lookupCredential( 'JWTAcessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/user/${ encodeURIComponent( String( userId ) ) }/password`,
            requestPasswordAdmin,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get personal info for a different user
     * Get personal info about any user by its id, only for admins and creators
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userUserIdPersonalGet( userId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<TypePersonalInfo>;
    userUserIdPersonalGet( userId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<TypePersonalInfo>>;
    userUserIdPersonalGet( userId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<TypePersonalInfo>>;
    userUserIdPersonalGet( userId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userUserIdPersonalGet.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (JWTAcessToken) required
        credential = this.configuration.lookupCredential( 'JWTAcessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<TypePersonalInfo>( `${ this.configuration.basePath }/user/${ encodeURIComponent( String( userId ) ) }/personal`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Set personal info for a user
     * Set personal info about any user by its id, only for admins
     * @param userId Id of the user
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userUserIdPersonalPatch( userId: number, body: TypePersonalInfo, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>;
    userUserIdPersonalPatch( userId: number, body: TypePersonalInfo, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<any>>;
    userUserIdPersonalPatch( userId: number, body: TypePersonalInfo, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<any>>;
    userUserIdPersonalPatch( userId: number, body: TypePersonalInfo, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userUserIdPersonalPatch.' )
        }
        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling userUserIdPersonalPatch.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAcessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAcessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAcessToken) required
        credential = this.configuration.lookupCredential( 'JWTAcessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.patch<any>( `${ this.configuration.basePath }/user/${ encodeURIComponent( String( userId ) ) }/personal`,
            body,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Set the role of any user
     * Set the role of another user, only for admins
     * @param userId Id of the user
     * @param requestUserRole
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userUserIdRolePut( userId: number, requestUserRole: RequestUserRole, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>;
    userUserIdRolePut( userId: number, requestUserRole: RequestUserRole, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<any>>;
    userUserIdRolePut( userId: number, requestUserRole: RequestUserRole, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<any>>;
    userUserIdRolePut( userId: number, requestUserRole: RequestUserRole, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userUserIdRolePut.' )
        }
        if ( requestUserRole === null || requestUserRole === undefined )
        {
            throw new Error( 'Required parameter requestUserRole was null or undefined when calling userUserIdRolePut.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAcessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAcessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAcessToken) required
        credential = this.configuration.lookupCredential( 'JWTAcessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.put<any>( `${ this.configuration.basePath }/user/${ encodeURIComponent( String( userId ) ) }/role`,
            requestUserRole,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Set the type of any user
     * Set the type of another user, only for admins
     * @param userId Id of the user
     * @param requestUserType
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userUserIdTypePut( userId: number, requestUserType: RequestUserType, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>;
    userUserIdTypePut( userId: number, requestUserType: RequestUserType, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<any>>;
    userUserIdTypePut( userId: number, requestUserType: RequestUserType, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<any>>;
    userUserIdTypePut( userId: number, requestUserType: RequestUserType, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userUserIdTypePut.' )
        }
        if ( requestUserType === null || requestUserType === undefined )
        {
            throw new Error( 'Required parameter requestUserType was null or undefined when calling userUserIdTypePut.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAcessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAcessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAcessToken) required
        credential = this.configuration.lookupCredential( 'JWTAcessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.put<any>( `${ this.configuration.basePath }/user/${ encodeURIComponent( String( userId ) ) }/type`,
            requestUserType,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get university student info for a different user
     * Get university student info about any user by its id, only for admins and creators
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userUserIdUniversityGet( userId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<TypeStudentInfo>;
    userUserIdUniversityGet( userId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<TypeStudentInfo>>;
    userUserIdUniversityGet( userId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<TypeStudentInfo>>;
    userUserIdUniversityGet( userId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userUserIdUniversityGet.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (JWTAcessToken) required
        credential = this.configuration.lookupCredential( 'JWTAcessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<TypeStudentInfo>( `${ this.configuration.basePath }/user/${ encodeURIComponent( String( userId ) ) }/university`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Set university student info for a user
     * Set university student info about any user by its id, only for admins
     * @param userId Id of the user
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userUserIdUniversityPatch( userId: number, body: TypeStudentInfo, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>;
    userUserIdUniversityPatch( userId: number, body: TypeStudentInfo, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<any>>;
    userUserIdUniversityPatch( userId: number, body: TypeStudentInfo, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<any>>;
    userUserIdUniversityPatch( userId: number, body: TypeStudentInfo, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userUserIdUniversityPatch.' )
        }
        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling userUserIdUniversityPatch.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAcessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAcessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAcessToken) required
        credential = this.configuration.lookupCredential( 'JWTAcessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.patch<any>( `${ this.configuration.basePath }/user/${ encodeURIComponent( String( userId ) ) }/university`,
            body,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }
}