/**
 * aggregate_user
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core'
import { HttpClient, HttpEvent, HttpHeaders, HttpParameterCodec, HttpParams, HttpResponse } from '@angular/common/http'
import { CustomHttpParameterCodec } from '@/shared/encoder'
import { Observable } from 'rxjs'
import { BASE_PATH } from '../variables'
import { Configuration } from '../../shared/configuration'
import {
    CSRFPairUser,
    Group,
    GroupAddRequestUser,
    GroupListResponseUser,
    InfoCitiesResponseUser,
    InfoCountriesResponseUser,
    InfoRegionsResponseUser,
    InfoUniversitiesResponseUser,
    LoginRequestUser,
    MembershipRequestUser,
    PasswordRequestUser,
    PreregisterResponseUser,
    RegisterInternalRequestUser,
    RoleRequestUser,
    SchoolInfo,
    SchoolInfoInput,
    SchoolRegistrationRequestUser,
    SelfGroupsResponseUser,
    SelfPasswordRequestUser,
    StudentInfo,
    StudentInfoInput,
    TypeRequestUser,
    UniversityRegistrationRequestUser,
    User,
    UserFullListResponseUser,
    UserInfo,
    UserInfoInput,
    UserInfoRestrictedInput,
    UserListResponseUser
} from '@/auth/api/models'


@Injectable()
export class AuthService
{
    protected basePath = 'http://127.0.0.1:5000'
    public defaultHeaders = new HttpHeaders()
    public configuration = new Configuration()
    public encoder: HttpParameterCodec

    constructor( protected httpClient: HttpClient, @Optional() @Inject( BASE_PATH ) basePath: string, @Optional() configuration: Configuration )
    {
        if ( configuration )
        {
            this.configuration = configuration
        }
        if ( typeof this.configuration.basePath !== 'string' )
        {
            if ( typeof basePath !== 'string' )
            {
                basePath = this.basePath
            }
            this.configuration.basePath = basePath
        }
        this.configuration.withCredentials = true
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec()
    }


    private addToHttpParams( httpParams: HttpParams, value: any, key?: string ): HttpParams
    {
        if ( typeof value === "object" && value instanceof Date === false )
        {
            httpParams = this.addToHttpParamsRecursive( httpParams, value )
        }
        else
        {
            httpParams = this.addToHttpParamsRecursive( httpParams, value, key )
        }
        return httpParams
    }

    private addToHttpParamsRecursive( httpParams: HttpParams, value?: any, key?: string ): HttpParams
    {
        if ( value == null )
        {
            return httpParams
        }

        if ( typeof value === "object" )
        {
            if ( Array.isArray( value ) )
            {
                ( value as any[] ).forEach( elem => httpParams = this.addToHttpParamsRecursive( httpParams, elem, key ) )
            }
            else if ( value instanceof Date )
            {
                if ( key != null )
                {
                    httpParams = httpParams.append( key,
                        ( value as Date ).toISOString().substr( 0, 10 ) )
                }
                else
                {
                    throw Error( "key may not be null if value is Date" )
                }
            }
            else
            {
                Object.keys( value ).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[ k ], key != null ? `${ key }.${ k }` : k ) )
            }
        }
        else if ( key != null )
        {
            httpParams = httpParams.append( key, value )
        }
        else
        {
            throw Error( "key may not be null if value is not object or array" )
        }
        return httpParams
    }

    /**
     * @param groupAddRequestUser
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userAdminAddGroupPost( groupAddRequestUser: GroupAddRequestUser, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<Group>;
    public userAdminAddGroupPost( groupAddRequestUser: GroupAddRequestUser, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<Group>>;
    public userAdminAddGroupPost( groupAddRequestUser: GroupAddRequestUser, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<Group>>;
    public userAdminAddGroupPost( groupAddRequestUser: GroupAddRequestUser, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( groupAddRequestUser === null || groupAddRequestUser === undefined )
        {
            throw new Error( 'Required parameter groupAddRequestUser was null or undefined when calling userAdminAddGroupPost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAccessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<Group>( `${ this.configuration.basePath }/user/admin/add_group`,
            groupAddRequestUser,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param userId Id of the user
     * @param membershipRequestUser
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userAdminAddMemberUserIdPost( userId: number, membershipRequestUser: MembershipRequestUser, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<any>;
    public userAdminAddMemberUserIdPost( userId: number, membershipRequestUser: MembershipRequestUser, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpResponse<any>>;
    public userAdminAddMemberUserIdPost( userId: number, membershipRequestUser: MembershipRequestUser, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpEvent<any>>;
    public userAdminAddMemberUserIdPost( userId: number, membershipRequestUser: MembershipRequestUser, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined } ): Observable<any>
    {
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userAdminAddMemberUserIdPost.' )
        }
        if ( membershipRequestUser === null || membershipRequestUser === undefined )
        {
            throw new Error( 'Required parameter membershipRequestUser was null or undefined when calling userAdminAddMemberUserIdPost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAccessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/user/admin/add_member/${ encodeURIComponent( String( userId ) ) }`,
            membershipRequestUser,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param registerInternalRequestUser
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userAdminInternalRegisterPost( registerInternalRequestUser: RegisterInternalRequestUser, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<User>;
    public userAdminInternalRegisterPost( registerInternalRequestUser: RegisterInternalRequestUser, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<User>>;
    public userAdminInternalRegisterPost( registerInternalRequestUser: RegisterInternalRequestUser, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<User>>;
    public userAdminInternalRegisterPost( registerInternalRequestUser: RegisterInternalRequestUser, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( registerInternalRequestUser === null || registerInternalRequestUser === undefined )
        {
            throw new Error( 'Required parameter registerInternalRequestUser was null or undefined when calling userAdminInternalRegisterPost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAccessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<User>( `${ this.configuration.basePath }/user/admin/internal_register`,
            registerInternalRequestUser,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param userId Id of the user
     * @param passwordRequestUser
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userAdminPasswordUserIdPost( userId: number, passwordRequestUser: PasswordRequestUser, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<any>;
    public userAdminPasswordUserIdPost( userId: number, passwordRequestUser: PasswordRequestUser, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpResponse<any>>;
    public userAdminPasswordUserIdPost( userId: number, passwordRequestUser: PasswordRequestUser, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpEvent<any>>;
    public userAdminPasswordUserIdPost( userId: number, passwordRequestUser: PasswordRequestUser, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined } ): Observable<any>
    {
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userAdminPasswordUserIdPost.' )
        }
        if ( passwordRequestUser === null || passwordRequestUser === undefined )
        {
            throw new Error( 'Required parameter passwordRequestUser was null or undefined when calling userAdminPasswordUserIdPost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAccessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/user/admin/password/${ encodeURIComponent( String( userId ) ) }`,
            passwordRequestUser,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param userId Id of the user
     * @param userInfoInput
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userAdminPersonalUserIdPatch( userId: number, userInfoInput: UserInfoInput, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<any>;
    public userAdminPersonalUserIdPatch( userId: number, userInfoInput: UserInfoInput, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpResponse<any>>;
    public userAdminPersonalUserIdPatch( userId: number, userInfoInput: UserInfoInput, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpEvent<any>>;
    public userAdminPersonalUserIdPatch( userId: number, userInfoInput: UserInfoInput, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined } ): Observable<any>
    {
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userAdminPersonalUserIdPatch.' )
        }
        if ( userInfoInput === null || userInfoInput === undefined )
        {
            throw new Error( 'Required parameter userInfoInput was null or undefined when calling userAdminPersonalUserIdPatch.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAccessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.patch<any>( `${ this.configuration.basePath }/user/admin/personal/${ encodeURIComponent( String( userId ) ) }`,
            userInfoInput,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userAdminPreregisterPost( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<PreregisterResponseUser>;
    public userAdminPreregisterPost( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<PreregisterResponseUser>>;
    public userAdminPreregisterPost( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<PreregisterResponseUser>>;
    public userAdminPreregisterPost( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAccessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<PreregisterResponseUser>( `${ this.configuration.basePath }/user/admin/preregister`,
            null,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param groupId ID of the group
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userAdminRemoveGroupGroupIdPost( groupId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<any>;
    public userAdminRemoveGroupGroupIdPost( groupId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpResponse<any>>;
    public userAdminRemoveGroupGroupIdPost( groupId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpEvent<any>>;
    public userAdminRemoveGroupGroupIdPost( groupId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined } ): Observable<any>
    {
        if ( groupId === null || groupId === undefined )
        {
            throw new Error( 'Required parameter groupId was null or undefined when calling userAdminRemoveGroupGroupIdPost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAccessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/user/admin/remove_group/${ encodeURIComponent( String( groupId ) ) }`,
            null,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param userId Id of the user
     * @param membershipRequestUser
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userAdminRemoveMemberUserIdPost( userId: number, membershipRequestUser: MembershipRequestUser, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<any>;
    public userAdminRemoveMemberUserIdPost( userId: number, membershipRequestUser: MembershipRequestUser, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpResponse<any>>;
    public userAdminRemoveMemberUserIdPost( userId: number, membershipRequestUser: MembershipRequestUser, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpEvent<any>>;
    public userAdminRemoveMemberUserIdPost( userId: number, membershipRequestUser: MembershipRequestUser, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined } ): Observable<any>
    {
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userAdminRemoveMemberUserIdPost.' )
        }
        if ( membershipRequestUser === null || membershipRequestUser === undefined )
        {
            throw new Error( 'Required parameter membershipRequestUser was null or undefined when calling userAdminRemoveMemberUserIdPost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAccessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/user/admin/remove_member/${ encodeURIComponent( String( userId ) ) }`,
            membershipRequestUser,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param userId Id of the user
     * @param roleRequestUser
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userAdminRoleUserIdPut( userId: number, roleRequestUser: RoleRequestUser, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<any>;
    public userAdminRoleUserIdPut( userId: number, roleRequestUser: RoleRequestUser, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpResponse<any>>;
    public userAdminRoleUserIdPut( userId: number, roleRequestUser: RoleRequestUser, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpEvent<any>>;
    public userAdminRoleUserIdPut( userId: number, roleRequestUser: RoleRequestUser, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined } ): Observable<any>
    {
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userAdminRoleUserIdPut.' )
        }
        if ( roleRequestUser === null || roleRequestUser === undefined )
        {
            throw new Error( 'Required parameter roleRequestUser was null or undefined when calling userAdminRoleUserIdPut.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAccessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.put<any>( `${ this.configuration.basePath }/user/admin/role/${ encodeURIComponent( String( userId ) ) }`,
            roleRequestUser,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param userId Id of the user
     * @param schoolInfoInput
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userAdminSchoolUserIdPatch( userId: number, schoolInfoInput: SchoolInfoInput, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<any>;
    public userAdminSchoolUserIdPatch( userId: number, schoolInfoInput: SchoolInfoInput, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpResponse<any>>;
    public userAdminSchoolUserIdPatch( userId: number, schoolInfoInput: SchoolInfoInput, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpEvent<any>>;
    public userAdminSchoolUserIdPatch( userId: number, schoolInfoInput: SchoolInfoInput, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined } ): Observable<any>
    {
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userAdminSchoolUserIdPatch.' )
        }
        if ( schoolInfoInput === null || schoolInfoInput === undefined )
        {
            throw new Error( 'Required parameter schoolInfoInput was null or undefined when calling userAdminSchoolUserIdPatch.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAccessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.patch<any>( `${ this.configuration.basePath }/user/admin/school/${ encodeURIComponent( String( userId ) ) }`,
            schoolInfoInput,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param userId Id of the user
     * @param typeRequestUser
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userAdminTypeUserIdPut( userId: number, typeRequestUser: TypeRequestUser, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<any>;
    public userAdminTypeUserIdPut( userId: number, typeRequestUser: TypeRequestUser, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpResponse<any>>;
    public userAdminTypeUserIdPut( userId: number, typeRequestUser: TypeRequestUser, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpEvent<any>>;
    public userAdminTypeUserIdPut( userId: number, typeRequestUser: TypeRequestUser, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined } ): Observable<any>
    {
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userAdminTypeUserIdPut.' )
        }
        if ( typeRequestUser === null || typeRequestUser === undefined )
        {
            throw new Error( 'Required parameter typeRequestUser was null or undefined when calling userAdminTypeUserIdPut.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAccessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.put<any>( `${ this.configuration.basePath }/user/admin/type/${ encodeURIComponent( String( userId ) ) }`,
            typeRequestUser,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param userId Id of the user
     * @param studentInfoInput
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userAdminUniversityUserIdPatch( userId: number, studentInfoInput: StudentInfoInput, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<any>;
    public userAdminUniversityUserIdPatch( userId: number, studentInfoInput: StudentInfoInput, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpResponse<any>>;
    public userAdminUniversityUserIdPatch( userId: number, studentInfoInput: StudentInfoInput, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpEvent<any>>;
    public userAdminUniversityUserIdPatch( userId: number, studentInfoInput: StudentInfoInput, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined } ): Observable<any>
    {
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userAdminUniversityUserIdPatch.' )
        }
        if ( studentInfoInput === null || studentInfoInput === undefined )
        {
            throw new Error( 'Required parameter studentInfoInput was null or undefined when calling userAdminUniversityUserIdPatch.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAccessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.patch<any>( `${ this.configuration.basePath }/user/admin/university/${ encodeURIComponent( String( userId ) ) }`,
            studentInfoInput,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param loginRequestUser
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userAuthLoginPost( loginRequestUser: LoginRequestUser, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<CSRFPairUser>;
    public userAuthLoginPost( loginRequestUser: LoginRequestUser, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<CSRFPairUser>>;
    public userAuthLoginPost( loginRequestUser: LoginRequestUser, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<CSRFPairUser>>;
    public userAuthLoginPost( loginRequestUser: LoginRequestUser, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( loginRequestUser === null || loginRequestUser === undefined )
        {
            throw new Error( 'Required parameter loginRequestUser was null or undefined when calling userAuthLoginPost.' )
        }

        let headers = this.defaultHeaders

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<CSRFPairUser>( `${ this.configuration.basePath }/user/auth/login`,
            loginRequestUser,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userAuthLogoutPost( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<any>;
    public userAuthLogoutPost( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpResponse<any>>;
    public userAuthLogoutPost( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpEvent<any>>;
    public userAuthLogoutPost( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAccessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/user/auth/logout`,
            null,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userAuthRefreshPost( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<CSRFPairUser>;
    public userAuthRefreshPost( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<CSRFPairUser>>;
    public userAuthRefreshPost( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<CSRFPairUser>>;
    public userAuthRefreshPost( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFRefreshToken) required
        credential = this.configuration.lookupCredential( 'CSRFRefreshToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTRefreshToken) required
        credential = this.configuration.lookupCredential( 'JWTRefreshToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<CSRFPairUser>( `${ this.configuration.basePath }/user/auth/refresh`,
            null,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userCreatorGroupAllGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<GroupListResponseUser>;
    public userCreatorGroupAllGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<GroupListResponseUser>>;
    public userCreatorGroupAllGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<GroupListResponseUser>>;
    public userCreatorGroupAllGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<GroupListResponseUser>( `${ this.configuration.basePath }/user/creator/group/all`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param groupId Id of the group
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userCreatorGroupGroupIdGet( groupId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<Group>;
    public userCreatorGroupGroupIdGet( groupId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<Group>>;
    public userCreatorGroupGroupIdGet( groupId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<Group>>;
    public userCreatorGroupGroupIdGet( groupId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( groupId === null || groupId === undefined )
        {
            throw new Error( 'Required parameter groupId was null or undefined when calling userCreatorGroupGroupIdGet.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<Group>( `${ this.configuration.basePath }/user/creator/group/${ encodeURIComponent( String( groupId ) ) }`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userCreatorMembershipUserIdGet( userId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<GroupListResponseUser>;
    public userCreatorMembershipUserIdGet( userId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<GroupListResponseUser>>;
    public userCreatorMembershipUserIdGet( userId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<GroupListResponseUser>>;
    public userCreatorMembershipUserIdGet( userId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userCreatorMembershipUserIdGet.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<GroupListResponseUser>( `${ this.configuration.basePath }/user/creator/membership/${ encodeURIComponent( String( userId ) ) }`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userCreatorPersonalUserIdGet( userId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<UserInfo>;
    public userCreatorPersonalUserIdGet( userId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<UserInfo>>;
    public userCreatorPersonalUserIdGet( userId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<UserInfo>>;
    public userCreatorPersonalUserIdGet( userId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userCreatorPersonalUserIdGet.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<UserInfo>( `${ this.configuration.basePath }/user/creator/personal/${ encodeURIComponent( String( userId ) ) }`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userCreatorSchoolUserIdGet( userId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<SchoolInfo>;
    public userCreatorSchoolUserIdGet( userId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<SchoolInfo>>;
    public userCreatorSchoolUserIdGet( userId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<SchoolInfo>>;
    public userCreatorSchoolUserIdGet( userId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userCreatorSchoolUserIdGet.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<SchoolInfo>( `${ this.configuration.basePath }/user/creator/school/${ encodeURIComponent( String( userId ) ) }`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userCreatorUniversityUserIdGet( userId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<StudentInfo>;
    public userCreatorUniversityUserIdGet( userId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<StudentInfo>>;
    public userCreatorUniversityUserIdGet( userId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<StudentInfo>>;
    public userCreatorUniversityUserIdGet( userId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userCreatorUniversityUserIdGet.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<StudentInfo>( `${ this.configuration.basePath }/user/creator/university/${ encodeURIComponent( String( userId ) ) }`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userCreatorUserAllGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<UserListResponseUser>;
    public userCreatorUserAllGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<UserListResponseUser>>;
    public userCreatorUserAllGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<UserListResponseUser>>;
    public userCreatorUserAllGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<UserListResponseUser>( `${ this.configuration.basePath }/user/creator/user/all`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param groupId ID of the group
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userCreatorUserByGroupGroupIdGet( groupId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<UserListResponseUser>;
    public userCreatorUserByGroupGroupIdGet( groupId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<UserListResponseUser>>;
    public userCreatorUserByGroupGroupIdGet( groupId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<UserListResponseUser>>;
    public userCreatorUserByGroupGroupIdGet( groupId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( groupId === null || groupId === undefined )
        {
            throw new Error( 'Required parameter groupId was null or undefined when calling userCreatorUserByGroupGroupIdGet.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<UserListResponseUser>( `${ this.configuration.basePath }/user/creator/user/by-group/${ encodeURIComponent( String( groupId ) ) }`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userCreatorUserFullAllGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<UserFullListResponseUser>;
    public userCreatorUserFullAllGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<UserFullListResponseUser>>;
    public userCreatorUserFullAllGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<UserFullListResponseUser>>;
    public userCreatorUserFullAllGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<UserFullListResponseUser>( `${ this.configuration.basePath }/user/creator/user_full/all`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userCreatorUserUserIdGet( userId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<User>;
    public userCreatorUserUserIdGet( userId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<User>>;
    public userCreatorUserUserIdGet( userId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<User>>;
    public userCreatorUserUserIdGet( userId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userCreatorUserUserIdGet.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<User>( `${ this.configuration.basePath }/user/creator/user/${ encodeURIComponent( String( userId ) ) }`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userProfileGroupsGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<SelfGroupsResponseUser>;
    public userProfileGroupsGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<SelfGroupsResponseUser>>;
    public userProfileGroupsGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<SelfGroupsResponseUser>>;
    public userProfileGroupsGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<SelfGroupsResponseUser>( `${ this.configuration.basePath }/user/profile/groups`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param selfPasswordRequestUser
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userProfilePasswordPost( selfPasswordRequestUser: SelfPasswordRequestUser, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<any>;
    public userProfilePasswordPost( selfPasswordRequestUser: SelfPasswordRequestUser, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpResponse<any>>;
    public userProfilePasswordPost( selfPasswordRequestUser: SelfPasswordRequestUser, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpEvent<any>>;
    public userProfilePasswordPost( selfPasswordRequestUser: SelfPasswordRequestUser, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined } ): Observable<any>
    {
        if ( selfPasswordRequestUser === null || selfPasswordRequestUser === undefined )
        {
            throw new Error( 'Required parameter selfPasswordRequestUser was null or undefined when calling userProfilePasswordPost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAccessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/user/profile/password`,
            selfPasswordRequestUser,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userProfilePersonalGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<UserInfo>;
    public userProfilePersonalGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<UserInfo>>;
    public userProfilePersonalGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<UserInfo>>;
    public userProfilePersonalGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<UserInfo>( `${ this.configuration.basePath }/user/profile/personal`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param userInfoRestrictedInput
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userProfilePersonalPatch( userInfoRestrictedInput: UserInfoRestrictedInput, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<any>;
    public userProfilePersonalPatch( userInfoRestrictedInput: UserInfoRestrictedInput, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpResponse<any>>;
    public userProfilePersonalPatch( userInfoRestrictedInput: UserInfoRestrictedInput, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpEvent<any>>;
    public userProfilePersonalPatch( userInfoRestrictedInput: UserInfoRestrictedInput, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined } ): Observable<any>
    {
        if ( userInfoRestrictedInput === null || userInfoRestrictedInput === undefined )
        {
            throw new Error( 'Required parameter userInfoRestrictedInput was null or undefined when calling userProfilePersonalPatch.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAccessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.patch<any>( `${ this.configuration.basePath }/user/profile/personal`,
            userInfoRestrictedInput,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userProfileSchoolGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<SchoolInfo>;
    public userProfileSchoolGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<SchoolInfo>>;
    public userProfileSchoolGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<SchoolInfo>>;
    public userProfileSchoolGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<SchoolInfo>( `${ this.configuration.basePath }/user/profile/school`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param schoolInfoInput
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userProfileSchoolPatch( schoolInfoInput: SchoolInfoInput, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<any>;
    public userProfileSchoolPatch( schoolInfoInput: SchoolInfoInput, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpResponse<any>>;
    public userProfileSchoolPatch( schoolInfoInput: SchoolInfoInput, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpEvent<any>>;
    public userProfileSchoolPatch( schoolInfoInput: SchoolInfoInput, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined } ): Observable<any>
    {
        if ( schoolInfoInput === null || schoolInfoInput === undefined )
        {
            throw new Error( 'Required parameter schoolInfoInput was null or undefined when calling userProfileSchoolPatch.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAccessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.patch<any>( `${ this.configuration.basePath }/user/profile/school`,
            schoolInfoInput,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userProfileUniversityGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<StudentInfo>;
    public userProfileUniversityGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<StudentInfo>>;
    public userProfileUniversityGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<StudentInfo>>;
    public userProfileUniversityGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<StudentInfo>( `${ this.configuration.basePath }/user/profile/university`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param studentInfoInput
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userProfileUniversityPatch( studentInfoInput: StudentInfoInput, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<any>;
    public userProfileUniversityPatch( studentInfoInput: StudentInfoInput, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpResponse<any>>;
    public userProfileUniversityPatch( studentInfoInput: StudentInfoInput, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined } ): Observable<HttpEvent<any>>;
    public userProfileUniversityPatch( studentInfoInput: StudentInfoInput, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined } ): Observable<any>
    {
        if ( studentInfoInput === null || studentInfoInput === undefined )
        {
            throw new Error( 'Required parameter studentInfoInput was null or undefined when calling userProfileUniversityPatch.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFAccessToken) required
        credential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.patch<any>( `${ this.configuration.basePath }/user/profile/university`,
            studentInfoInput,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userProfileUserGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<User>;
    public userProfileUserGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<User>>;
    public userProfileUserGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<User>>;
    public userProfileUserGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (JWTAccessToken) required
        credential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<User>( `${ this.configuration.basePath }/user/profile/user`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param region Region name
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userRegistrationInfoCitiesRegionGet( region: string, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<InfoCitiesResponseUser>;
    public userRegistrationInfoCitiesRegionGet( region: string, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<InfoCitiesResponseUser>>;
    public userRegistrationInfoCitiesRegionGet( region: string, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<InfoCitiesResponseUser>>;
    public userRegistrationInfoCitiesRegionGet( region: string, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( region === null || region === undefined )
        {
            throw new Error( 'Required parameter region was null or undefined when calling userRegistrationInfoCitiesRegionGet.' )
        }

        let headers = this.defaultHeaders

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<InfoCitiesResponseUser>( `${ this.configuration.basePath }/user/registration/info/cities/${ encodeURIComponent( String( region ) ) }`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userRegistrationInfoCountriesGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<InfoCountriesResponseUser>;
    public userRegistrationInfoCountriesGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<InfoCountriesResponseUser>>;
    public userRegistrationInfoCountriesGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<InfoCountriesResponseUser>>;
    public userRegistrationInfoCountriesGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<InfoCountriesResponseUser>( `${ this.configuration.basePath }/user/registration/info/countries`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userRegistrationInfoRegionsGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<InfoRegionsResponseUser>;
    public userRegistrationInfoRegionsGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<InfoRegionsResponseUser>>;
    public userRegistrationInfoRegionsGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<InfoRegionsResponseUser>>;
    public userRegistrationInfoRegionsGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<InfoRegionsResponseUser>( `${ this.configuration.basePath }/user/registration/info/regions`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userRegistrationInfoUniversitiesGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<InfoUniversitiesResponseUser>;
    public userRegistrationInfoUniversitiesGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<InfoUniversitiesResponseUser>>;
    public userRegistrationInfoUniversitiesGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<InfoUniversitiesResponseUser>>;
    public userRegistrationInfoUniversitiesGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<InfoUniversitiesResponseUser>( `${ this.configuration.basePath }/user/registration/info/universities`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Register a new school student
     * @param schoolRegistrationRequestUser
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userRegistrationSchoolPost( schoolRegistrationRequestUser: SchoolRegistrationRequestUser, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<User>;
    public userRegistrationSchoolPost( schoolRegistrationRequestUser: SchoolRegistrationRequestUser, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<User>>;
    public userRegistrationSchoolPost( schoolRegistrationRequestUser: SchoolRegistrationRequestUser, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<User>>;
    public userRegistrationSchoolPost( schoolRegistrationRequestUser: SchoolRegistrationRequestUser, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( schoolRegistrationRequestUser === null || schoolRegistrationRequestUser === undefined )
        {
            throw new Error( 'Required parameter schoolRegistrationRequestUser was null or undefined when calling userRegistrationSchoolPost.' )
        }

        let headers = this.defaultHeaders

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<User>( `${ this.configuration.basePath }/user/registration/school`,
            schoolRegistrationRequestUser,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param universityRegistrationRequestUser
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userRegistrationUniversityPost( universityRegistrationRequestUser: UniversityRegistrationRequestUser, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<User>;
    public userRegistrationUniversityPost( universityRegistrationRequestUser: UniversityRegistrationRequestUser, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<User>>;
    public userRegistrationUniversityPost( universityRegistrationRequestUser: UniversityRegistrationRequestUser, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<User>>;
    public userRegistrationUniversityPost( universityRegistrationRequestUser: UniversityRegistrationRequestUser, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( universityRegistrationRequestUser === null || universityRegistrationRequestUser === undefined )
        {
            throw new Error( 'Required parameter universityRegistrationRequestUser was null or undefined when calling userRegistrationUniversityPost.' )
        }

        let headers = this.defaultHeaders

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<User>( `${ this.configuration.basePath }/user/registration/university`,
            universityRegistrationRequestUser,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

}
