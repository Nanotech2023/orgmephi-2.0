/**
 * User service API
 * API description in Markdown.
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core'
import { HttpClient, HttpEvent, HttpHeaders, HttpParams, HttpResponse } from '@angular/common/http'
import { CustomHttpUrlEncodingCodec } from '../encoder'

import { Observable } from 'rxjs'
import { RequestGroupAdd } from '@/auth/models/requestGroupAdd'
import { RequestLogin } from '@/auth/models/requestLogin'
import { RequestPasswordAdmin } from '@/auth/models/requestPasswordAdmin'
import { RequestPasswordSelf } from '@/auth/models/requestPasswordSelf'
import { RequestRegistration } from '@/auth/models/requestRegistration'
import { RequestUserGroupsAdd } from '@/auth/models/requestUserGroupsAdd'
import { RequestUserGroupsRemove } from '@/auth/models/requestUserGroupsRemove'
import { RequestUserRole } from '@/auth/models/requestUserRole'
import { RequestUserType } from '@/auth/models/requestUserType'
import { ResponseGroup } from '@/auth/models/responseGroup'
import { ResponseGroupAdd } from '@/auth/models/responseGroupAdd'
import { ResponseGroupAll } from '@/auth/models/responseGroupAll'
import { ResponseInfoCountries } from '@/auth/models/responseInfoCountries'
import { ResponseInfoUniversities } from '@/auth/models/responseInfoUniversities'
import { ResponseLogin } from '@/auth/models/responseLogin'
import { ResponsePersonalAdminGet } from '@/auth/models/responsePersonalAdminGet'
import { ResponsePersonalSelf } from '@/auth/models/responsePersonalSelf'
import { ResponsePreregister } from '@/auth/models/responsePreregister'
import { ResponseRefresh } from '@/auth/models/responseRefresh'
import { ResponseRegistration } from '@/auth/models/responseRegistration'
import { ResponseRegistrationInternal } from '@/auth/models/responseRegistrationInternal'
import { ResponseUniversityAdminGet } from '@/auth/models/responseUniversityAdminGet'
import { ResponseUniversitySelf } from '@/auth/models/responseUniversitySelf'
import { ResponseUserAdmin } from '@/auth/models/responseUserAdmin'
import { ResponseUserAdminGroup } from '@/auth/models/responseUserAdminGroup'
import { ResponseUserAll } from '@/auth/models/responseUserAll'
import { ResponseUserByGroup } from '@/auth/models/responseUserByGroup'
import { ResponseUserSelf } from '@/auth/models/responseUserSelf'
import { ResponseUserSelfGroup } from '@/auth/models/responseUserSelfGroup'
import { TypeAuthCredentials } from '@/auth/models/typeAuthCredentials'
import { TypePersonalInfo } from '@/auth/models/typePersonalInfo'
import { TypeStudentInfo } from '@/auth/models/typeStudentInfo'

import { BASE_PATH } from '../variables'
import { Configuration } from '../configuration'
import { IAuthService } from '@/auth/api/auth.service.int'


@Injectable()
export class AuthService implements IAuthService
{

    protected basePath = 'http://127.0.0.1:5000'
    public defaultHeaders = new HttpHeaders()
    public configuration = new Configuration()

    constructor( protected httpClient: HttpClient, @Optional() @Inject( BASE_PATH ) basePath: string, @Optional() configuration: Configuration )
    {
        if ( basePath )
        {
            this.basePath = basePath
        }
        if ( configuration )
        {
            this.configuration = configuration
            this.basePath = basePath || configuration.basePath || this.basePath
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm( consumes: string[] ): boolean
    {
        const form = 'multipart/form-data'
        for ( const consume of consumes )
        {
            if ( form === consume )
            {
                return true
            }
        }
        return false
    }


    /**
     * Add a group
     * Add a group, only for admins
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    groupAddPost( body: RequestGroupAdd, observe?: 'body', reportProgress?: boolean ): Observable<ResponseGroupAdd>;
    groupAddPost( body: RequestGroupAdd, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<ResponseGroupAdd>>;
    groupAddPost( body: RequestGroupAdd, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<ResponseGroupAdd>>;
    groupAddPost( body: RequestGroupAdd, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling groupAddPost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<ResponseGroupAdd>( 'post', `${ this.basePath }/group/add`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get all groups
     * Get all group list, only for admins and creators
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    groupAllGet( observe?: 'body', reportProgress?: boolean ): Observable<ResponseGroupAll>;
    groupAllGet( observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<ResponseGroupAll>>;
    groupAllGet( observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<ResponseGroupAll>>;
    groupAllGet( observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<ResponseGroupAll>( 'get', `${ this.basePath }/group/all`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get any group
     * Get any group, only for admins and creators
     * @param groupId Id of the group
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    groupGroupIdGet( groupId: number, observe?: 'body', reportProgress?: boolean ): Observable<ResponseGroup>;
    groupGroupIdGet( groupId: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<ResponseGroup>>;
    groupGroupIdGet( groupId: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<ResponseGroup>>;
    groupGroupIdGet( groupId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( groupId === null || groupId === undefined )
        {
            throw new Error( 'Required parameter groupId was null or undefined when calling groupGroupIdGet.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<ResponseGroup>( 'get', `${ this.basePath }/group/${ encodeURIComponent( String( groupId ) ) }`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Delete a group
     * Add a group, only for admins
     * @param groupId ID of the group
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    groupGroupIdRemovePost( groupId: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    groupGroupIdRemovePost( groupId: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    groupGroupIdRemovePost( groupId: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    groupGroupIdRemovePost( groupId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( groupId === null || groupId === undefined )
        {
            throw new Error( 'Required parameter groupId was null or undefined when calling groupGroupIdRemovePost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<any>( 'post', `${ this.basePath }/group/${ encodeURIComponent( String( groupId ) ) }/remove`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get known country list
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    infoCountriesGet( observe?: 'body', reportProgress?: boolean ): Observable<ResponseInfoCountries>;
    infoCountriesGet( observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<ResponseInfoCountries>>;
    infoCountriesGet( observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<ResponseInfoCountries>>;
    infoCountriesGet( observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        let headers = this.defaultHeaders

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<ResponseInfoCountries>( 'get', `${ this.basePath }/info/countries`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get known university list
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    infoUniversitiesGet( observe?: 'body', reportProgress?: boolean ): Observable<ResponseInfoUniversities>;
    infoUniversitiesGet( observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<ResponseInfoUniversities>>;
    infoUniversitiesGet( observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<ResponseInfoUniversities>>;
    infoUniversitiesGet( observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        let headers = this.defaultHeaders

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<ResponseInfoUniversities>( 'get', `${ this.basePath }/info/universities`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Authenticate a user
     *
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    loginPost( body: RequestLogin, observe?: 'body', reportProgress?: boolean ): Observable<ResponseLogin>;
    loginPost( body: RequestLogin, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<ResponseLogin>>;
    loginPost( body: RequestLogin, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<ResponseLogin>>;
    loginPost( body: RequestLogin, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling loginPost.' )
        }

        let headers = this.defaultHeaders

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<ResponseLogin>( 'post', `${ this.basePath }/login`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Logout current user
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    logoutPost( observe?: 'body', reportProgress?: boolean ): Observable<any>;
    logoutPost( observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    logoutPost( observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    logoutPost( observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = []
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<any>( 'post', `${ this.basePath }/logout`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Register an unconfirmed user with a one-time password
     * Register an unconfirmed user with a one-time password, creators and admins only
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    preregisterPost( observe?: 'body', reportProgress?: boolean ): Observable<ResponsePreregister>;
    preregisterPost( observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<ResponsePreregister>>;
    preregisterPost( observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<ResponsePreregister>>;
    preregisterPost( observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<ResponsePreregister>( 'post', `${ this.basePath }/preregister`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Refresh JWT token for current user
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    refreshPost( observe?: 'body', reportProgress?: boolean ): Observable<ResponseRefresh>;
    refreshPost( observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<ResponseRefresh>>;
    refreshPost( observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<ResponseRefresh>>;
    refreshPost( observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFRefreshToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTRefreshToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "refresh_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'refresh_token_cookie', this.configuration.apiKeys[ "refresh_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<ResponseRefresh>( 'post', `${ this.basePath }/refresh`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Register an internal user
     * Register an internal user, admin only
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    registerInternalPost( body: TypeAuthCredentials, observe?: 'body', reportProgress?: boolean ): Observable<ResponseRegistrationInternal>;
    registerInternalPost( body: TypeAuthCredentials, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<ResponseRegistrationInternal>>;
    registerInternalPost( body: TypeAuthCredentials, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<ResponseRegistrationInternal>>;
    registerInternalPost( body: TypeAuthCredentials, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling registerInternalPost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<ResponseRegistrationInternal>( 'post', `${ this.basePath }/register/internal`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Register a new user
     *
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    registerPost( body: RequestRegistration, observe?: 'body', reportProgress?: boolean ): Observable<ResponseRegistration>;
    registerPost( body: RequestRegistration, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<ResponseRegistration>>;
    registerPost( body: RequestRegistration, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<ResponseRegistration>>;
    registerPost( body: RequestRegistration, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling registerPost.' )
        }

        let headers = this.defaultHeaders

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<ResponseRegistration>( 'post', `${ this.basePath }/register`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get common info for all users
     * Get info about all users, only for admins and creators
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userAllGet( observe?: 'body', reportProgress?: boolean ): Observable<ResponseUserAll>;
    userAllGet( observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<ResponseUserAll>>;
    userAllGet( observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<ResponseUserAll>>;
    userAllGet( observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<ResponseUserAll>( 'get', `${ this.basePath }/user/all`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get common info for different users
     * Get info about any user by their group, only for admins and creators
     * @param groupId ID of the group
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userByGroupGroupIdGet( groupId: number, observe?: 'body', reportProgress?: boolean ): Observable<ResponseUserByGroup>;
    userByGroupGroupIdGet( groupId: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<ResponseUserByGroup>>;
    userByGroupGroupIdGet( groupId: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<ResponseUserByGroup>>;
    userByGroupGroupIdGet( groupId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( groupId === null || groupId === undefined )
        {
            throw new Error( 'Required parameter groupId was null or undefined when calling userByGroupGroupIdGet.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<ResponseUserByGroup>( 'get', `${ this.basePath }/user/by-group/${ encodeURIComponent( String( groupId ) ) }`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get common info for current user
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userSelfGet( observe?: 'body', reportProgress?: boolean ): Observable<ResponseUserSelf>;
    userSelfGet( observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<ResponseUserSelf>>;
    userSelfGet( observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<ResponseUserSelf>>;
    userSelfGet( observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<ResponseUserSelf>( 'get', `${ this.basePath }/user/self`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get groups for current user
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userSelfGroupsGet( observe?: 'body', reportProgress?: boolean ): Observable<ResponseUserSelfGroup>;
    userSelfGroupsGet( observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<ResponseUserSelfGroup>>;
    userSelfGroupsGet( observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<ResponseUserSelfGroup>>;
    userSelfGroupsGet( observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<ResponseUserSelfGroup>( 'get', `${ this.basePath }/user/self/groups`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Change password for current user
     *
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userSelfPasswordPost( body: RequestPasswordSelf, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    userSelfPasswordPost( body: RequestPasswordSelf, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    userSelfPasswordPost( body: RequestPasswordSelf, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    userSelfPasswordPost( body: RequestPasswordSelf, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling userSelfPasswordPost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<any>( 'post', `${ this.basePath }/user/self/password`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get personal info for current user
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userSelfPersonalGet( observe?: 'body', reportProgress?: boolean ): Observable<ResponsePersonalSelf>;
    userSelfPersonalGet( observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<ResponsePersonalSelf>>;
    userSelfPersonalGet( observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<ResponsePersonalSelf>>;
    userSelfPersonalGet( observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<ResponsePersonalSelf>( 'get', `${ this.basePath }/user/self/personal`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get university student info for current user
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userSelfUniversityGet( observe?: 'body', reportProgress?: boolean ): Observable<ResponseUniversitySelf>;
    userSelfUniversityGet( observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<ResponseUniversitySelf>>;
    userSelfUniversityGet( observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<ResponseUniversitySelf>>;
    userSelfUniversityGet( observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<ResponseUniversitySelf>( 'get', `${ this.basePath }/user/self/university`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get common info for a different user
     * Get info about any user by its id, only for admins and creators
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userUserIdGet( userId: number, observe?: 'body', reportProgress?: boolean ): Observable<ResponseUserAdmin>;
    userUserIdGet( userId: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<ResponseUserAdmin>>;
    userUserIdGet( userId: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<ResponseUserAdmin>>;
    userUserIdGet( userId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userUserIdGet.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<ResponseUserAdmin>( 'get', `${ this.basePath }/user/${ encodeURIComponent( String( userId ) ) }`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Assign a user to a group
     * Assign a user to a group, only for admins and creators
     * @param body
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userUserIdGroupsAddPost( body: RequestUserGroupsAdd, userId: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    userUserIdGroupsAddPost( body: RequestUserGroupsAdd, userId: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    userUserIdGroupsAddPost( body: RequestUserGroupsAdd, userId: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    userUserIdGroupsAddPost( body: RequestUserGroupsAdd, userId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling userUserIdGroupsAddPost.' )
        }

        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userUserIdGroupsAddPost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<any>( 'post', `${ this.basePath }/user/${ encodeURIComponent( String( userId ) ) }/groups/add`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get groups for a different user
     * Get group list for any user by its id, only for admins and creators
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userUserIdGroupsGet( userId: number, observe?: 'body', reportProgress?: boolean ): Observable<ResponseUserAdminGroup>;
    userUserIdGroupsGet( userId: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<ResponseUserAdminGroup>>;
    userUserIdGroupsGet( userId: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<ResponseUserAdminGroup>>;
    userUserIdGroupsGet( userId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userUserIdGroupsGet.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<ResponseUserAdminGroup>( 'get', `${ this.basePath }/user/${ encodeURIComponent( String( userId ) ) }/groups`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Remove a user from a group
     * Remove a user from a group, only for admins and creators
     * @param body
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userUserIdGroupsRemovePost( body: RequestUserGroupsRemove, userId: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    userUserIdGroupsRemovePost( body: RequestUserGroupsRemove, userId: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    userUserIdGroupsRemovePost( body: RequestUserGroupsRemove, userId: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    userUserIdGroupsRemovePost( body: RequestUserGroupsRemove, userId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling userUserIdGroupsRemovePost.' )
        }

        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userUserIdGroupsRemovePost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<any>( 'post', `${ this.basePath }/user/${ encodeURIComponent( String( userId ) ) }/groups/remove`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Change password for another user
     * Change password for another user, admins only
     * @param body
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userUserIdPasswordPost( body: RequestPasswordAdmin, userId: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    userUserIdPasswordPost( body: RequestPasswordAdmin, userId: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    userUserIdPasswordPost( body: RequestPasswordAdmin, userId: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    userUserIdPasswordPost( body: RequestPasswordAdmin, userId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling userUserIdPasswordPost.' )
        }

        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userUserIdPasswordPost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<any>( 'post', `${ this.basePath }/user/${ encodeURIComponent( String( userId ) ) }/password`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get personal info for a different user
     * Get personal info about any user by its id, only for admins and creators
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userUserIdPersonalGet( userId: number, observe?: 'body', reportProgress?: boolean ): Observable<ResponsePersonalAdminGet>;
    userUserIdPersonalGet( userId: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<ResponsePersonalAdminGet>>;
    userUserIdPersonalGet( userId: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<ResponsePersonalAdminGet>>;
    userUserIdPersonalGet( userId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userUserIdPersonalGet.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<ResponsePersonalAdminGet>( 'get', `${ this.basePath }/user/${ encodeURIComponent( String( userId ) ) }/personal`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Set personal info for a user
     * Set personal info about any user by its id, only for admins
     * @param body
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userUserIdPersonalPatch( body: TypePersonalInfo, userId: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    userUserIdPersonalPatch( body: TypePersonalInfo, userId: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    userUserIdPersonalPatch( body: TypePersonalInfo, userId: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    userUserIdPersonalPatch( body: TypePersonalInfo, userId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling userUserIdPersonalPatch.' )
        }

        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userUserIdPersonalPatch.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<any>( 'patch', `${ this.basePath }/user/${ encodeURIComponent( String( userId ) ) }/personal`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Set the role of any user
     * Set the role of another user, only for admins
     * @param body
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userUserIdRolePut( body: RequestUserRole, userId: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    userUserIdRolePut( body: RequestUserRole, userId: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    userUserIdRolePut( body: RequestUserRole, userId: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    userUserIdRolePut( body: RequestUserRole, userId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling userUserIdRolePut.' )
        }

        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userUserIdRolePut.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<any>( 'put', `${ this.basePath }/user/${ encodeURIComponent( String( userId ) ) }/role`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Set the type of any user
     * Set the type of another user, only for admins
     * @param body
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userUserIdTypePut( body: RequestUserType, userId: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    userUserIdTypePut( body: RequestUserType, userId: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    userUserIdTypePut( body: RequestUserType, userId: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    userUserIdTypePut( body: RequestUserType, userId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling userUserIdTypePut.' )
        }

        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userUserIdTypePut.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<any>( 'put', `${ this.basePath }/user/${ encodeURIComponent( String( userId ) ) }/type`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get university student info for a different user
     * Get university student info about any user by its id, only for admins and creators
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userUserIdUniversityGet( userId: number, observe?: 'body', reportProgress?: boolean ): Observable<ResponseUniversityAdminGet>;
    userUserIdUniversityGet( userId: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<ResponseUniversityAdminGet>>;
    userUserIdUniversityGet( userId: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<ResponseUniversityAdminGet>>;
    userUserIdUniversityGet( userId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userUserIdUniversityGet.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<ResponseUniversityAdminGet>( 'get', `${ this.basePath }/user/${ encodeURIComponent( String( userId ) ) }/university`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Set university student info for a user
     * Set university student info about any user by its id, only for admins
     * @param body
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userUserIdUniversityPatch( body: TypeStudentInfo, userId: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    userUserIdUniversityPatch( body: TypeStudentInfo, userId: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    userUserIdUniversityPatch( body: TypeStudentInfo, userId: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    userUserIdUniversityPatch( body: TypeStudentInfo, userId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling userUserIdUniversityPatch.' )
        }

        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling userUserIdUniversityPatch.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<any>( 'patch', `${ this.basePath }/user/${ encodeURIComponent( String( userId ) ) }/university`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

}