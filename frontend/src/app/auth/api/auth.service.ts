/**
 * User service API
 * API description in Markdown.
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core'
import { HttpClient, HttpEvent, HttpHeaders, HttpParams, HttpResponse } from '@angular/common/http'
import { CustomHttpUrlEncodingCodec } from '../encoder'

import { Observable } from 'rxjs'

import { AccountType } from '../models/accountType'
import { AddGroup } from '../models/addGroup'
import { AuthResponse } from '../models/authResponse'
import { Authentication } from '../models/authentication'
import { ChangePassword } from '../models/changePassword'
import { ChangePasswordAdmin } from '../models/changePasswordAdmin'
import { CommonUserInfo } from '../models/commonUserInfo'
import { GetCountriesResponse } from '../models/getCountriesResponse'
import { GetUniversitiesResponse } from '../models/getUniversitiesResponse'
import { GroupList } from '../models/groupList'
import { GroupType } from '../models/groupType'
import { PersonalInfo } from '../models/personalInfo'
import { PersonalInfoUpdate } from '../models/personalInfoUpdate'
import { RegisterAuthInfo } from '../models/registerAuthInfo'
import { RegisterConfirm } from '../models/registerConfirm'
import { Registration } from '../models/registration'
import { StudentInfo } from '../models/studentInfo'
import { StudentInfoUpdate } from '../models/studentInfoUpdate'
import { UpdateGroups } from '../models/updateGroups'
import { UserList } from '../models/userList'
import { UserRole } from '../models/userRole'

import { BASE_PATH } from '../variables'
import { Configuration } from '../configuration'
import { IAuthService } from '@/auth/api/auth.service.int'


@Injectable()
export class AuthService implements IAuthService
{
    basePath = '/'
    defaultHeaders = new HttpHeaders()
    configuration = new Configuration()

    constructor( public httpClient: HttpClient, @Optional() @Inject( BASE_PATH ) basePath: string, @Optional() configuration: Configuration )
    {
        if ( basePath )
        {
            this.basePath = basePath
        }
        if ( configuration )
        {
            this.configuration = configuration
            this.basePath = basePath || configuration.basePath || this.basePath
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm( consumes: string[] ): boolean
    {
        const form = 'multipart/form-data'
        for ( const consume of consumes )
        {
            if ( form === consume )
            {
                return true
            }
        }
        return false
    }


    /**
     * Add a group
     * Add a group, only for admins
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    groupAddPost( body: AddGroup, observe?: 'body', reportProgress?: boolean ): Observable<GroupType>;
    groupAddPost( body: AddGroup, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<GroupType>>;
    groupAddPost( body: AddGroup, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<GroupType>>;
    groupAddPost( body: AddGroup, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling groupAddPost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<GroupType>( 'post', `${ this.basePath }/group/add`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get all groups
     * Get all group list, only for admins and creators
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    groupAllGet( observe?: 'body', reportProgress?: boolean ): Observable<GroupList>;
    groupAllGet( observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<GroupList>>;
    groupAllGet( observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<GroupList>>;
    groupAllGet( observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<GroupList>( 'get', `${ this.basePath }/group/all`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Delete a group
     * Add a group, only for admins
     * @param body
     * @param id ID of the group
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    groupIdDeletePost( body: AddGroup, id: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    groupIdDeletePost( body: AddGroup, id: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    groupIdDeletePost( body: AddGroup, id: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    groupIdDeletePost( body: AddGroup, id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling groupIdDeletePost.' )
        }

        if ( id === null || id === undefined )
        {
            throw new Error( 'Required parameter id was null or undefined when calling groupIdDeletePost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<any>( 'post', `${ this.basePath }/group/${ encodeURIComponent( String( id ) ) }/delete`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get any group
     * Get any group, only for admins and creators
     * @param id Id of the group
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    groupIdGet( id: number, observe?: 'body', reportProgress?: boolean ): Observable<GroupType>;
    groupIdGet( id: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<GroupType>>;
    groupIdGet( id: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<GroupType>>;
    groupIdGet( id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( id === null || id === undefined )
        {
            throw new Error( 'Required parameter id was null or undefined when calling groupIdGet.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<GroupType>( 'get', `${ this.basePath }/group/${ encodeURIComponent( String( id ) ) }`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get known country list
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    infoCountriesGet( observe?: 'body', reportProgress?: boolean ): Observable<GetCountriesResponse>;
    infoCountriesGet( observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<GetCountriesResponse>>;
    infoCountriesGet( observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<GetCountriesResponse>>;
    infoCountriesGet( observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        let headers = this.defaultHeaders

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<GetCountriesResponse>( 'get', `${ this.basePath }/info/countries`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get known university list
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    infoUniversitiesGet( observe?: 'body', reportProgress?: boolean ): Observable<GetUniversitiesResponse>;
    infoUniversitiesGet( observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<GetUniversitiesResponse>>;
    infoUniversitiesGet( observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<GetUniversitiesResponse>>;
    infoUniversitiesGet( observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        let headers = this.defaultHeaders

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<GetUniversitiesResponse>( 'get', `${ this.basePath }/info/universities`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Authenticate a user
     *
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    loginPost( body: Authentication, observe?: 'body', reportProgress?: boolean ): Observable<AuthResponse>;
    loginPost( body: Authentication, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<AuthResponse>>;
    loginPost( body: Authentication, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<AuthResponse>>;
    loginPost( body: Authentication, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling loginPost.' )
        }

        let headers = this.defaultHeaders

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<AuthResponse>( 'post', `${ this.basePath }/login`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Logout current user
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    logoutPost( observe?: 'body', reportProgress?: boolean ): Observable<any>;
    logoutPost( observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    logoutPost( observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    logoutPost( observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = []
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<any>( 'post', `${ this.basePath }/logout`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Register an unconfirmed user with a one-time password
     * Register an unconfirmed user with a one-time password, creators and admins only
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    preregisterPost( observe?: 'body', reportProgress?: boolean ): Observable<RegisterConfirm>;
    preregisterPost( observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<RegisterConfirm>>;
    preregisterPost( observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<RegisterConfirm>>;
    preregisterPost( observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<RegisterConfirm>( 'post', `${ this.basePath }/preregister`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Refresh JWT token for current user
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    refreshPost( observe?: 'body', reportProgress?: boolean ): Observable<AuthResponse>;
    refreshPost( observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<AuthResponse>>;
    refreshPost( observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<AuthResponse>>;
    refreshPost( observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFRefreshToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTRefreshToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "refresh_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'refresh_token_cookie', this.configuration.apiKeys[ "refresh_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<AuthResponse>( 'post', `${ this.basePath }/refresh`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Register an internal user
     * Register an internal user, admin only
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    registerInternalPost( body: RegisterAuthInfo, observe?: 'body', reportProgress?: boolean ): Observable<CommonUserInfo>;
    registerInternalPost( body: RegisterAuthInfo, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<CommonUserInfo>>;
    registerInternalPost( body: RegisterAuthInfo, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<CommonUserInfo>>;
    registerInternalPost( body: RegisterAuthInfo, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling registerInternalPost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<CommonUserInfo>( 'post', `${ this.basePath }/register/internal`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Register a new user
     *
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    registerPost( body: Registration, observe?: 'body', reportProgress?: boolean ): Observable<CommonUserInfo>;
    registerPost( body: Registration, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<CommonUserInfo>>;
    registerPost( body: Registration, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<CommonUserInfo>>;
    registerPost( body: Registration, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling registerPost.' )
        }

        let headers = this.defaultHeaders

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<CommonUserInfo>( 'post', `${ this.basePath }/register`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get common info for all users
     * Get info about all users, only for admins and creators
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userAllGet( observe?: 'body', reportProgress?: boolean ): Observable<UserList>;
    userAllGet( observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<UserList>>;
    userAllGet( observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<UserList>>;
    userAllGet( observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<UserList>( 'get', `${ this.basePath }/user/all`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get common info for different users
     * Get info about any user by their group, only for admins and creators
     * @param id ID of the group
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userByGroupIdGet( id: number, observe?: 'body', reportProgress?: boolean ): Observable<UserList>;
    userByGroupIdGet( id: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<UserList>>;
    userByGroupIdGet( id: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<UserList>>;
    userByGroupIdGet( id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( id === null || id === undefined )
        {
            throw new Error( 'Required parameter id was null or undefined when calling userByGroupIdGet.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<UserList>( 'get', `${ this.basePath }/user/by-group/${ encodeURIComponent( String( id ) ) }`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get common info for a different user
     * Get info about any user by its id, only for admins and creators
     * @param id Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userIdGet( id: number, observe?: 'body', reportProgress?: boolean ): Observable<CommonUserInfo>;
    userIdGet( id: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<CommonUserInfo>>;
    userIdGet( id: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<CommonUserInfo>>;
    userIdGet( id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( id === null || id === undefined )
        {
            throw new Error( 'Required parameter id was null or undefined when calling userIdGet.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<CommonUserInfo>( 'get', `${ this.basePath }/user/${ encodeURIComponent( String( id ) ) }`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Assign a user to a group
     * Assign a user to a group, only for admins and creators
     * @param body
     * @param id Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userIdGroupsAddPost( body: UpdateGroups, id: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    userIdGroupsAddPost( body: UpdateGroups, id: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    userIdGroupsAddPost( body: UpdateGroups, id: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    userIdGroupsAddPost( body: UpdateGroups, id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling userIdGroupsAddPost.' )
        }

        if ( id === null || id === undefined )
        {
            throw new Error( 'Required parameter id was null or undefined when calling userIdGroupsAddPost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<any>( 'post', `${ this.basePath }/user/${ encodeURIComponent( String( id ) ) }/groups/add`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get groups for a different user
     * Get group list for any user by its id, only for admins and creators
     * @param id Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userIdGroupsGet( id: number, observe?: 'body', reportProgress?: boolean ): Observable<GroupList>;
    userIdGroupsGet( id: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<GroupList>>;
    userIdGroupsGet( id: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<GroupList>>;
    userIdGroupsGet( id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( id === null || id === undefined )
        {
            throw new Error( 'Required parameter id was null or undefined when calling userIdGroupsGet.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<GroupList>( 'get', `${ this.basePath }/user/${ encodeURIComponent( String( id ) ) }/groups`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Remove a user from a group
     * Remove a user from a group, only for admins and creators
     * @param body
     * @param id Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userIdGroupsRemovePost( body: UpdateGroups, id: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    userIdGroupsRemovePost( body: UpdateGroups, id: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    userIdGroupsRemovePost( body: UpdateGroups, id: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    userIdGroupsRemovePost( body: UpdateGroups, id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling userIdGroupsRemovePost.' )
        }

        if ( id === null || id === undefined )
        {
            throw new Error( 'Required parameter id was null or undefined when calling userIdGroupsRemovePost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<any>( 'post', `${ this.basePath }/user/${ encodeURIComponent( String( id ) ) }/groups/remove`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Change password for another user
     * Change password for another user, admins only
     * @param body
     * @param id Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userIdPasswordPost( body: ChangePasswordAdmin, id: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    userIdPasswordPost( body: ChangePasswordAdmin, id: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    userIdPasswordPost( body: ChangePasswordAdmin, id: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    userIdPasswordPost( body: ChangePasswordAdmin, id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling userIdPasswordPost.' )
        }

        if ( id === null || id === undefined )
        {
            throw new Error( 'Required parameter id was null or undefined when calling userIdPasswordPost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = []
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<any>( 'post', `${ this.basePath }/user/${ encodeURIComponent( String( id ) ) }/password`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get personal info for a different user
     * Get personal info about any user by its id, only for admins and creators
     * @param id Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userIdPersonalGet( id: number, observe?: 'body', reportProgress?: boolean ): Observable<PersonalInfo>;
    userIdPersonalGet( id: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<PersonalInfo>>;
    userIdPersonalGet( id: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<PersonalInfo>>;
    userIdPersonalGet( id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( id === null || id === undefined )
        {
            throw new Error( 'Required parameter id was null or undefined when calling userIdPersonalGet.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<PersonalInfo>( 'get', `${ this.basePath }/user/${ encodeURIComponent( String( id ) ) }/personal`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Set personal info for a user
     * Set personal info about any user by its id, only for admins
     * @param body
     * @param id Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userIdPersonalPatch( body: PersonalInfoUpdate, id: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    userIdPersonalPatch( body: PersonalInfoUpdate, id: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    userIdPersonalPatch( body: PersonalInfoUpdate, id: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    userIdPersonalPatch( body: PersonalInfoUpdate, id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling userIdPersonalPatch.' )
        }

        if ( id === null || id === undefined )
        {
            throw new Error( 'Required parameter id was null or undefined when calling userIdPersonalPatch.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<any>( 'patch', `${ this.basePath }/user/${ encodeURIComponent( String( id ) ) }/personal`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Set the role of any user
     * Set the role of another user, only for admins
     * @param body
     * @param id Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userIdRolePut( body: UserRole, id: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    userIdRolePut( body: UserRole, id: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    userIdRolePut( body: UserRole, id: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    userIdRolePut( body: UserRole, id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling userIdRolePut.' )
        }

        if ( id === null || id === undefined )
        {
            throw new Error( 'Required parameter id was null or undefined when calling userIdRolePut.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<any>( 'put', `${ this.basePath }/user/${ encodeURIComponent( String( id ) ) }/role`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Set the type of any user
     * Set the type of another user, only for admins
     * @param body
     * @param id Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userIdTypePut( body: AccountType, id: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    userIdTypePut( body: AccountType, id: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    userIdTypePut( body: AccountType, id: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    userIdTypePut( body: AccountType, id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling userIdTypePut.' )
        }

        if ( id === null || id === undefined )
        {
            throw new Error( 'Required parameter id was null or undefined when calling userIdTypePut.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<any>( 'put', `${ this.basePath }/user/${ encodeURIComponent( String( id ) ) }/type`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get university student info for a different user
     * Get university student info about any user by its id, only for admins and creators
     * @param id Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userIdUniversityGet( id: number, observe?: 'body', reportProgress?: boolean ): Observable<StudentInfo>;
    userIdUniversityGet( id: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<StudentInfo>>;
    userIdUniversityGet( id: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<StudentInfo>>;
    userIdUniversityGet( id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( id === null || id === undefined )
        {
            throw new Error( 'Required parameter id was null or undefined when calling userIdUniversityGet.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<StudentInfo>( 'get', `${ this.basePath }/user/${ encodeURIComponent( String( id ) ) }/university`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Set university student info for a user
     * Set university student info about any user by its id, only for admins
     * @param body
     * @param id Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userIdUniversityPatch( body: StudentInfoUpdate, id: number, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    userIdUniversityPatch( body: StudentInfoUpdate, id: number, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    userIdUniversityPatch( body: StudentInfoUpdate, id: number, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    userIdUniversityPatch( body: StudentInfoUpdate, id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling userIdUniversityPatch.' )
        }

        if ( id === null || id === undefined )
        {
            throw new Error( 'Required parameter id was null or undefined when calling userIdUniversityPatch.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<any>( 'patch', `${ this.basePath }/user/${ encodeURIComponent( String( id ) ) }/university`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get common info for current user
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userSelfGet( observe?: 'body', reportProgress?: boolean ): Observable<CommonUserInfo>;
    userSelfGet( observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<CommonUserInfo>>;
    userSelfGet( observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<CommonUserInfo>>;
    userSelfGet( observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<CommonUserInfo>( 'get', `${ this.basePath }/user/self`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get groups for current user
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userSelfGroupsGet( observe?: 'body', reportProgress?: boolean ): Observable<GroupList>;
    userSelfGroupsGet( observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<GroupList>>;
    userSelfGroupsGet( observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<GroupList>>;
    userSelfGroupsGet( observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<GroupList>( 'get', `${ this.basePath }/user/self/groups`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Change password for current user
     *
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userSelfPasswordPost( body: ChangePassword, observe?: 'body', reportProgress?: boolean ): Observable<any>;
    userSelfPasswordPost( body: ChangePassword, observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<any>>;
    userSelfPasswordPost( body: ChangePassword, observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<any>>;
    userSelfPasswordPost( body: ChangePassword, observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling userSelfPasswordPost.' )
        }

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (CSRFAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        {
            headers = headers.set( 'X-CSRF-TOKEN', this.configuration.apiKeys[ "X-CSRF-TOKEN" ] )
        }

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = []
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected != undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        return this.httpClient.request<any>( 'post', `${ this.basePath }/user/self/password`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get personal info for current user
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userSelfPersonalGet( observe?: 'body', reportProgress?: boolean ): Observable<PersonalInfo>;
    userSelfPersonalGet( observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<PersonalInfo>>;
    userSelfPersonalGet( observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<PersonalInfo>>;
    userSelfPersonalGet( observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<PersonalInfo>( 'get', `${ this.basePath }/user/self/personal`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get university student info for current user
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userSelfUniversityGet( observe?: 'body', reportProgress?: boolean ): Observable<StudentInfo>;
    userSelfUniversityGet( observe?: 'response', reportProgress?: boolean ): Observable<HttpResponse<StudentInfo>>;
    userSelfUniversityGet( observe?: 'events', reportProgress?: boolean ): Observable<HttpEvent<StudentInfo>>;
    userSelfUniversityGet( observe: any = 'body', reportProgress: boolean = false ): Observable<any>
    {

        let queryParameters = new HttpParams( { encoder: new CustomHttpUrlEncodingCodec() } )

        let headers = this.defaultHeaders

        // authentication (JWTAcessToken) required
        if ( this.configuration.apiKeys && this.configuration.apiKeys[ "access_token_cookie" ] )
        {
            queryParameters = queryParameters.set( 'access_token_cookie', this.configuration.apiKeys[ "access_token_cookie" ] )
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ]
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        if ( httpHeaderAcceptSelected != undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }

        // to determine the Content-Type header
        const consumes: string[] = []

        return this.httpClient.request<StudentInfo>( 'get', `${ this.basePath }/user/self/university`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

}
