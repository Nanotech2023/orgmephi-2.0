/**
 * Tasks service API
 * API description in Markdown.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core'
import { HttpClient, HttpEvent, HttpHeaders, HttpParameterCodec, HttpParams, HttpResponse } from '@angular/common/http'
import { Observable } from 'rxjs'
import { CustomHttpParameterCodec } from '@/shared/encoder'
import { Configuration } from '@/shared/configuration'
import { BASE_PATH } from '../variables'
import {
    AddStatus,
    AllStatus,
    CommonContestId,
    CommonContestInfo,
    ContestInfoUpdate,
    ContestsInStage,
    CreateContest,
    CreateMultipleTask,
    CreatePlainTask,
    CreateRangeTask,
    CreateStage,
    CreateVariant,
    MultipleTaskInfo,
    MultipleTaskInfoUpdate,
    PlainTaskInfo,
    PlainTaskInfoUpdate,
    RangeTaskInfo,
    RangeTaskInfoUpdate,
    StageInfo,
    StageInfoId,
    StageInfoUpdate,
    StagesInOlympiad,
    StatusInfo,
    StatusInfoUpdate,
    TaskId,
    TaskInVariantImage,
    TasksInVariant,
    UpdateUserInContest,
    UserCertificate,
    UsersInContest,
    VariantInfo,
    VariantInfoId,
    VariantInfoUpdate,
    VariantsInContest
} from '@/manage-olympiads/api/models'
import { OlympiadsService } from '@/manage-olympiads/api/olympiads.service'


@Injectable()
export class OlympiadsServiceReal implements OlympiadsService
{
    protected basePath = 'http://127.0.0.1:5000'
    public defaultHeaders = new HttpHeaders()
    public configuration = new Configuration()
    public encoder: HttpParameterCodec

    constructor( protected httpClient: HttpClient, @Optional() @Inject( BASE_PATH ) basePath: string, @Optional() configuration: Configuration )
    {
        if ( configuration )
        {
            this.configuration = configuration
        }
        if ( typeof this.configuration.basePath !== 'string' )
        {
            if ( typeof basePath !== 'string' )
            {
                basePath = this.basePath
            }
            this.configuration.basePath = basePath
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec()
    }


    private addToHttpParams( httpParams: HttpParams, value: any, key?: string ): HttpParams
    {
        if ( typeof value === "object" && value instanceof Date === false )
        {
            httpParams = this.addToHttpParamsRecursive( httpParams, value )
        }
        else
        {
            httpParams = this.addToHttpParamsRecursive( httpParams, value, key )
        }
        return httpParams
    }

    private addToHttpParamsRecursive( httpParams: HttpParams, value?: any, key?: string ): HttpParams
    {
        if ( value == null )
        {
            return httpParams
        }

        if ( typeof value === "object" )
        {
            if ( Array.isArray( value ) )
            {
                ( value as any[] ).forEach( elem => httpParams = this.addToHttpParamsRecursive( httpParams, elem, key ) )
            }
            else if ( value instanceof Date )
            {
                if ( key != null )
                {
                    httpParams = httpParams.append( key,
                        ( value as Date ).toISOString().substr( 0, 10 ) )
                }
                else
                {
                    throw Error( "key may not be null if value is Date" )
                }
            }
            else
            {
                Object.keys( value ).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[ k ], key != null ? `${ key }.${ k }` : k ) )
            }
        }
        else if ( key != null )
        {
            httpParams = httpParams.append( key, value )
        }
        else
        {
            throw Error( "key may not be null if value is not object or array" )
        }
        return httpParams
    }

    /**
     * list of olympiads (main contests)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadAllGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<ContestsInStage>;
    olympiadAllGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<ContestsInStage>>;
    olympiadAllGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<ContestsInStage>>;
    olympiadAllGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<ContestsInStage>( `${ this.configuration.basePath }/olympiad/all`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    // /**
    //  * Create a new olympiad (main contest)
    //  * @param uNKNOWNBASETYPE
    //  * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
    //  * @param reportProgress flag to report request and response progress.
    //  */
    // public olympiadCreatePost( uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<CommonContestId>;
    // public olympiadCreatePost( uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<CommonContestId>>;
    // public olympiadCreatePost( uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<CommonContestId>>;
    // public olympiadCreatePost( uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    // {
    //     if ( uNKNOWNBASETYPE === null || uNKNOWNBASETYPE === undefined )
    //     {
    //         throw new Error( 'Required parameter uNKNOWNBASETYPE was null or undefined when calling olympiadCreatePost.' )
    //     }
    //
    //     let headers = this.defaultHeaders
    //
    //     let credential: string | undefined
    //     // authentication (CSRFToken) required
    //     credential = this.configuration.lookupCredential( 'CSRFToken' )
    //     if ( credential )
    //     {
    //         headers = headers.set( 'X-CSRF-TOKEN', credential )
    //     }
    //
    //     // authentication (cookieJWTAuth) required
    //     credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
    //     if ( credential )
    //     {
    //     }
    //
    //     let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
    //     if ( httpHeaderAcceptSelected === undefined )
    //     {
    //         // to determine the Accept header
    //         const httpHeaderAccepts: string[] = [
    //             'application/json'
    //         ]
    //         httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
    //     }
    //     if ( httpHeaderAcceptSelected !== undefined )
    //     {
    //         headers = headers.set( 'Accept', httpHeaderAcceptSelected )
    //     }
    //
    //
    //     // to determine the Content-Type header
    //     const consumes: string[] = [
    //         'application/json'
    //     ]
    //     const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
    //     if ( httpContentTypeSelected !== undefined )
    //     {
    //         headers = headers.set( 'Content-Type', httpContentTypeSelected )
    //     }
    //
    //     let responseType_: 'text' | 'json' = 'json'
    //     if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
    //     {
    //         responseType_ = 'text'
    //     }
    //
    //     return this.httpClient.post<CommonContestId>( `${ this.configuration.basePath }/olympiad/create`,
    //         uNKNOWNBASETYPE,
    //         {
    //             responseType: <any> responseType_,
    //             withCredentials: this.configuration.withCredentials,
    //             headers: headers,
    //             observe: observe,
    //             reportProgress: reportProgress
    //         }
    //     )
    // }

    /**
     * Get info for the olympiad (main contest)
     * @param idOlympiad Id of the olympiad
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadGet( idOlympiad: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<CommonContestInfo>;
    olympiadIdOlympiadGet( idOlympiad: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<CommonContestInfo>>;
    olympiadIdOlympiadGet( idOlympiad: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<CommonContestInfo>>;
    olympiadIdOlympiadGet( idOlympiad: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadGet.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<CommonContestInfo>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Edit olympiad info
     * @param idOlympiad Id of the olympiad
     * @param contestInfoUpdate
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadPatch( idOlympiad: number, contestInfoUpdate: ContestInfoUpdate, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>;
    olympiadIdOlympiadPatch( idOlympiad: number, contestInfoUpdate: ContestInfoUpdate, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<any>>;
    olympiadIdOlympiadPatch( idOlympiad: number, contestInfoUpdate: ContestInfoUpdate, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<any>>;
    olympiadIdOlympiadPatch( idOlympiad: number, contestInfoUpdate: ContestInfoUpdate, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadPatch.' )
        }
        if ( contestInfoUpdate === null || contestInfoUpdate === undefined )
        {
            throw new Error( 'Required parameter contestInfoUpdate was null or undefined when calling olympiadIdOlympiadPatch.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.patch<any>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }`,
            contestInfoUpdate,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Remove olympiad (main contest)
     * @param idOlympiad Id of the olympiad
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadRemovePost( idOlympiad: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>;
    olympiadIdOlympiadRemovePost( idOlympiad: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<any>>;
    olympiadIdOlympiadRemovePost( idOlympiad: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<any>>;
    olympiadIdOlympiadRemovePost( idOlympiad: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadRemovePost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/remove`,
            null,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * list of stages in olympiad
     * @param idOlympiad Id of the olympiad
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageAllGet( idOlympiad: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<StagesInOlympiad>;
    olympiadIdOlympiadStageAllGet( idOlympiad: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<StagesInOlympiad>>;
    olympiadIdOlympiadStageAllGet( idOlympiad: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<StagesInOlympiad>>;
    olympiadIdOlympiadStageAllGet( idOlympiad: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageAllGet.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<StagesInOlympiad>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/all`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Create a new stage in olympiad
     * @param idOlympiad Id of the olympiad
     * @param createStage
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageCreatePost( idOlympiad: number, createStage: CreateStage, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<StageInfoId>;
    olympiadIdOlympiadStageCreatePost( idOlympiad: number, createStage: CreateStage, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<StageInfoId>>;
    olympiadIdOlympiadStageCreatePost( idOlympiad: number, createStage: CreateStage, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<StageInfoId>>;
    olympiadIdOlympiadStageCreatePost( idOlympiad: number, createStage: CreateStage, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageCreatePost.' )
        }
        if ( createStage === null || createStage === undefined )
        {
            throw new Error( 'Required parameter createStage was null or undefined when calling olympiadIdOlympiadStageCreatePost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<StageInfoId>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/create`,
            createStage,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * list of contests in stage
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestAllGet( idOlympiad: number, idStage: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<ContestsInStage>;
    olympiadIdOlympiadStageIdStageContestAllGet( idOlympiad: number, idStage: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<ContestsInStage>>;
    olympiadIdOlympiadStageIdStageContestAllGet( idOlympiad: number, idStage: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<ContestsInStage>>;
    olympiadIdOlympiadStageIdStageContestAllGet( idOlympiad: number, idStage: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestAllGet.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestAllGet.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<ContestsInStage>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/all`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Create a new contest
     * @param idStage Id of the stage
     * @param idOlympiad Id of the olympiad
     * @param createContest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestCreatePost( idStage: number, idOlympiad: number, createContest: CreateContest, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<CommonContestId>;
    olympiadIdOlympiadStageIdStageContestCreatePost( idStage: number, idOlympiad: number, createContest: CreateContest, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<CommonContestId>>;
    olympiadIdOlympiadStageIdStageContestCreatePost( idStage: number, idOlympiad: number, createContest: CreateContest, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<CommonContestId>>;
    olympiadIdOlympiadStageIdStageContestCreatePost( idStage: number, idOlympiad: number, createContest: CreateContest, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestCreatePost.' )
        }
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestCreatePost.' )
        }
        if ( createContest === null || createContest === undefined )
        {
            throw new Error( 'Required parameter createContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestCreatePost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<CommonContestId>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/create`,
            createContest,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Add user to contest
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param updateUserInContest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestAdduserPost( idOlympiad: number, idStage: number, idContest: number, updateUserInContest: UpdateUserInContest, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<UpdateUserInContest>;
    olympiadIdOlympiadStageIdStageContestIdContestAdduserPost( idOlympiad: number, idStage: number, idContest: number, updateUserInContest: UpdateUserInContest, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<UpdateUserInContest>>;
    olympiadIdOlympiadStageIdStageContestIdContestAdduserPost( idOlympiad: number, idStage: number, idContest: number, updateUserInContest: UpdateUserInContest, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<UpdateUserInContest>>;
    olympiadIdOlympiadStageIdStageContestIdContestAdduserPost( idOlympiad: number, idStage: number, idContest: number, updateUserInContest: UpdateUserInContest, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestAdduserPost.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestAdduserPost.' )
        }
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestAdduserPost.' )
        }
        if ( updateUserInContest === null || updateUserInContest === undefined )
        {
            throw new Error( 'Required parameter updateUserInContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestAdduserPost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<UpdateUserInContest>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/adduser`,
            updateUserInContest,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get common info for a contest
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestGet( idOlympiad: number, idStage: number, idContest: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<CommonContestInfo>;
    olympiadIdOlympiadStageIdStageContestIdContestGet( idOlympiad: number, idStage: number, idContest: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<CommonContestInfo>>;
    olympiadIdOlympiadStageIdStageContestIdContestGet( idOlympiad: number, idStage: number, idContest: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<CommonContestInfo>>;
    olympiadIdOlympiadStageIdStageContestIdContestGet( idOlympiad: number, idStage: number, idContest: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestGet.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestGet.' )
        }
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestGet.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<CommonContestInfo>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Add user to contest
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param updateUserInContest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestMoveuserPost( idOlympiad: number, idStage: number, idContest: number, updateUserInContest: UpdateUserInContest, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<UpdateUserInContest>;
    olympiadIdOlympiadStageIdStageContestIdContestMoveuserPost( idOlympiad: number, idStage: number, idContest: number, updateUserInContest: UpdateUserInContest, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<UpdateUserInContest>>;
    olympiadIdOlympiadStageIdStageContestIdContestMoveuserPost( idOlympiad: number, idStage: number, idContest: number, updateUserInContest: UpdateUserInContest, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<UpdateUserInContest>>;
    olympiadIdOlympiadStageIdStageContestIdContestMoveuserPost( idOlympiad: number, idStage: number, idContest: number, updateUserInContest: UpdateUserInContest, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestMoveuserPost.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestMoveuserPost.' )
        }
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestMoveuserPost.' )
        }
        if ( updateUserInContest === null || updateUserInContest === undefined )
        {
            throw new Error( 'Required parameter updateUserInContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestMoveuserPost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<UpdateUserInContest>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/moveuser`,
            updateUserInContest,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Edit contest info
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param contestInfoUpdate
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestPatch( idOlympiad: number, idStage: number, idContest: number, contestInfoUpdate: ContestInfoUpdate, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>;
    olympiadIdOlympiadStageIdStageContestIdContestPatch( idOlympiad: number, idStage: number, idContest: number, contestInfoUpdate: ContestInfoUpdate, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<any>>;
    olympiadIdOlympiadStageIdStageContestIdContestPatch( idOlympiad: number, idStage: number, idContest: number, contestInfoUpdate: ContestInfoUpdate, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<any>>;
    olympiadIdOlympiadStageIdStageContestIdContestPatch( idOlympiad: number, idStage: number, idContest: number, contestInfoUpdate: ContestInfoUpdate, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestPatch.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestPatch.' )
        }
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestPatch.' )
        }
        if ( contestInfoUpdate === null || contestInfoUpdate === undefined )
        {
            throw new Error( 'Required parameter contestInfoUpdate was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestPatch.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.patch<any>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }`,
            contestInfoUpdate,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Remove contest
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestRemovePost( idOlympiad: number, idStage: number, idContest: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>;
    olympiadIdOlympiadStageIdStageContestIdContestRemovePost( idOlympiad: number, idStage: number, idContest: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<any>>;
    olympiadIdOlympiadStageIdStageContestIdContestRemovePost( idOlympiad: number, idStage: number, idContest: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<any>>;
    olympiadIdOlympiadStageIdStageContestIdContestRemovePost( idOlympiad: number, idStage: number, idContest: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestRemovePost.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestRemovePost.' )
        }
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestRemovePost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/remove`,
            null,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Remove user from contest
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param updateUserInContest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestRemoveuserPost( idOlympiad: number, idStage: number, idContest: number, updateUserInContest: UpdateUserInContest, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<UpdateUserInContest>;
    olympiadIdOlympiadStageIdStageContestIdContestRemoveuserPost( idOlympiad: number, idStage: number, idContest: number, updateUserInContest: UpdateUserInContest, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<UpdateUserInContest>>;
    olympiadIdOlympiadStageIdStageContestIdContestRemoveuserPost( idOlympiad: number, idStage: number, idContest: number, updateUserInContest: UpdateUserInContest, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<UpdateUserInContest>>;
    olympiadIdOlympiadStageIdStageContestIdContestRemoveuserPost( idOlympiad: number, idStage: number, idContest: number, updateUserInContest: UpdateUserInContest, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestRemoveuserPost.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestRemoveuserPost.' )
        }
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestRemoveuserPost.' )
        }
        if ( updateUserInContest === null || updateUserInContest === undefined )
        {
            throw new Error( 'Required parameter updateUserInContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestRemoveuserPost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<UpdateUserInContest>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/removeuser`,
            updateUserInContest,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * list of user in contest
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestUserAllGet( idOlympiad: number, idStage: number, idContest: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<UsersInContest>;
    olympiadIdOlympiadStageIdStageContestIdContestUserAllGet( idOlympiad: number, idStage: number, idContest: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<UsersInContest>>;
    olympiadIdOlympiadStageIdStageContestIdContestUserAllGet( idOlympiad: number, idStage: number, idContest: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<UsersInContest>>;
    olympiadIdOlympiadStageIdStageContestIdContestUserAllGet( idOlympiad: number, idStage: number, idContest: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestUserAllGet.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestUserAllGet.' )
        }
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestUserAllGet.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<UsersInContest>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/user/all`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * certificate of user in contest
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param idUser Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestUserIdUserCertificateGet( idOlympiad: number, idStage: number, idContest: number, idUser: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<UserCertificate>;
    olympiadIdOlympiadStageIdStageContestIdContestUserIdUserCertificateGet( idOlympiad: number, idStage: number, idContest: number, idUser: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<UserCertificate>>;
    olympiadIdOlympiadStageIdStageContestIdContestUserIdUserCertificateGet( idOlympiad: number, idStage: number, idContest: number, idUser: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<UserCertificate>>;
    olympiadIdOlympiadStageIdStageContestIdContestUserIdUserCertificateGet( idOlympiad: number, idStage: number, idContest: number, idUser: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestUserIdUserCertificateGet.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestUserIdUserCertificateGet.' )
        }
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestUserIdUserCertificateGet.' )
        }
        if ( idUser === null || idUser === undefined )
        {
            throw new Error( 'Required parameter idUser was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestUserIdUserCertificateGet.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<UserCertificate>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/user/${ encodeURIComponent( String( idUser ) ) }/certificate`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * list of variants in contest
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestVariantAllGet( idOlympiad: number, idStage: number, idContest: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<VariantsInContest>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantAllGet( idOlympiad: number, idStage: number, idContest: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<VariantsInContest>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantAllGet( idOlympiad: number, idStage: number, idContest: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<VariantsInContest>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantAllGet( idOlympiad: number, idStage: number, idContest: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantAllGet.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantAllGet.' )
        }
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantAllGet.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<VariantsInContest>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/variant/all`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Create a new variant
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param createVariant
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestVariantCreatePost( idOlympiad: number, idStage: number, idContest: number, createVariant: CreateVariant, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<VariantInfoId>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantCreatePost( idOlympiad: number, idStage: number, idContest: number, createVariant: CreateVariant, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<VariantInfoId>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantCreatePost( idOlympiad: number, idStage: number, idContest: number, createVariant: CreateVariant, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<VariantInfoId>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantCreatePost( idOlympiad: number, idStage: number, idContest: number, createVariant: CreateVariant, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantCreatePost.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantCreatePost.' )
        }
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantCreatePost.' )
        }
        if ( createVariant === null || createVariant === undefined )
        {
            throw new Error( 'Required parameter createVariant was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantCreatePost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<VariantInfoId>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/variant/create`,
            createVariant,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Remove variant
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param idVariant Id of the variant
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantRemovePost( idOlympiad: number, idStage: number, idContest: number, idVariant: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantRemovePost( idOlympiad: number, idStage: number, idContest: number, idVariant: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<any>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantRemovePost( idOlympiad: number, idStage: number, idContest: number, idVariant: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<any>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantRemovePost( idOlympiad: number, idStage: number, idContest: number, idVariant: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantRemovePost.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantRemovePost.' )
        }
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantRemovePost.' )
        }
        if ( idVariant === null || idVariant === undefined )
        {
            throw new Error( 'Required parameter idVariant was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantRemovePost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( idVariant ) ) }/remove`,
            null,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Create a new task
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param idVariant Id of the variant
     * @param createPlainTaskCreateRangeTaskCreateMultipleTask
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskCreatePost( idOlympiad: number, idStage: number, idContest: number, idVariant: number, createPlainTaskCreateRangeTaskCreateMultipleTask: CreatePlainTask | CreateRangeTask | CreateMultipleTask, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<TaskId>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskCreatePost( idOlympiad: number, idStage: number, idContest: number, idVariant: number, createPlainTaskCreateRangeTaskCreateMultipleTask: CreatePlainTask | CreateRangeTask | CreateMultipleTask, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<TaskId>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskCreatePost( idOlympiad: number, idStage: number, idContest: number, idVariant: number, createPlainTaskCreateRangeTaskCreateMultipleTask: CreatePlainTask | CreateRangeTask | CreateMultipleTask, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<TaskId>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskCreatePost( idOlympiad: number, idStage: number, idContest: number, idVariant: number, createPlainTaskCreateRangeTaskCreateMultipleTask: CreatePlainTask | CreateRangeTask | CreateMultipleTask, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskCreatePost.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskCreatePost.' )
        }
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskCreatePost.' )
        }
        if ( idVariant === null || idVariant === undefined )
        {
            throw new Error( 'Required parameter idVariant was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskCreatePost.' )
        }
        if ( createPlainTaskCreateRangeTaskCreateMultipleTask === null || createPlainTaskCreateRangeTaskCreateMultipleTask === undefined )
        {
            throw new Error( 'Required parameter createPlainTaskCreateRangeTaskCreateMultipleTask was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskCreatePost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<TaskId>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( idVariant ) ) }/task/create`,
            createPlainTaskCreateRangeTaskCreateMultipleTask,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get info for a different tasks
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param idVariant Id of the variant
     * @param idTask Id of the task
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskGet( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<PlainTaskInfo | RangeTaskInfo | MultipleTaskInfo>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskGet( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<PlainTaskInfo | RangeTaskInfo | MultipleTaskInfo>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskGet( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<PlainTaskInfo | RangeTaskInfo | MultipleTaskInfo>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskGet( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskGet.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskGet.' )
        }
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskGet.' )
        }
        if ( idVariant === null || idVariant === undefined )
        {
            throw new Error( 'Required parameter idVariant was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskGet.' )
        }
        if ( idTask === null || idTask === undefined )
        {
            throw new Error( 'Required parameter idTask was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskGet.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<PlainTaskInfo | RangeTaskInfo | MultipleTaskInfo>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( idVariant ) ) }/task/${ encodeURIComponent( String( idTask ) ) }`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Update task info
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param idVariant Id of the variant
     * @param idTask Id of the task
     * @param plainTaskInfoUpdateRangeTaskInfoUpdateMultipleTaskInfoUpdate
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskPatch( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, plainTaskInfoUpdateRangeTaskInfoUpdateMultipleTaskInfoUpdate: PlainTaskInfoUpdate | RangeTaskInfoUpdate | MultipleTaskInfoUpdate, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskPatch( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, plainTaskInfoUpdateRangeTaskInfoUpdateMultipleTaskInfoUpdate: PlainTaskInfoUpdate | RangeTaskInfoUpdate | MultipleTaskInfoUpdate, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<any>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskPatch( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, plainTaskInfoUpdateRangeTaskInfoUpdateMultipleTaskInfoUpdate: PlainTaskInfoUpdate | RangeTaskInfoUpdate | MultipleTaskInfoUpdate, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<any>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskPatch( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, plainTaskInfoUpdateRangeTaskInfoUpdateMultipleTaskInfoUpdate: PlainTaskInfoUpdate | RangeTaskInfoUpdate | MultipleTaskInfoUpdate, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskPatch.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskPatch.' )
        }
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskPatch.' )
        }
        if ( idVariant === null || idVariant === undefined )
        {
            throw new Error( 'Required parameter idVariant was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskPatch.' )
        }
        if ( idTask === null || idTask === undefined )
        {
            throw new Error( 'Required parameter idTask was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskPatch.' )
        }
        if ( plainTaskInfoUpdateRangeTaskInfoUpdateMultipleTaskInfoUpdate === null || plainTaskInfoUpdateRangeTaskInfoUpdateMultipleTaskInfoUpdate === undefined )
        {
            throw new Error( 'Required parameter plainTaskInfoUpdateRangeTaskInfoUpdateMultipleTaskInfoUpdate was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskPatch.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.patch<any>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( idVariant ) ) }/task/${ encodeURIComponent( String( idTask ) ) }`,
            plainTaskInfoUpdateRangeTaskInfoUpdateMultipleTaskInfoUpdate,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Remove task
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param idVariant Id of the variant
     * @param idTask Id of the task
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskRemovePost( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskRemovePost( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<any>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskRemovePost( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<any>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskRemovePost( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskRemovePost.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskRemovePost.' )
        }
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskRemovePost.' )
        }
        if ( idVariant === null || idVariant === undefined )
        {
            throw new Error( 'Required parameter idVariant was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskRemovePost.' )
        }
        if ( idTask === null || idTask === undefined )
        {
            throw new Error( 'Required parameter idTask was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTaskIdTaskRemovePost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( idVariant ) ) }/task/${ encodeURIComponent( String( idTask ) ) }/remove`,
            null,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * list of tasks in variant
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param idVariant Id of the variant
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksAllGet( idOlympiad: number, idStage: number, idContest: number, idVariant: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<TasksInVariant>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksAllGet( idOlympiad: number, idStage: number, idContest: number, idVariant: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<TasksInVariant>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksAllGet( idOlympiad: number, idStage: number, idContest: number, idVariant: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<TasksInVariant>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksAllGet( idOlympiad: number, idStage: number, idContest: number, idVariant: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksAllGet.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksAllGet.' )
        }
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksAllGet.' )
        }
        if ( idVariant === null || idVariant === undefined )
        {
            throw new Error( 'Required parameter idVariant was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksAllGet.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<TasksInVariant>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( idVariant ) ) }/tasks/all`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Task image
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param idVariant Id of the variant
     * @param idTask Id of the task
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksIdTaskTaskimageGet( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<TaskInVariantImage>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksIdTaskTaskimageGet( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<TaskInVariantImage>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksIdTaskTaskimageGet( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<TaskInVariantImage>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksIdTaskTaskimageGet( idOlympiad: number, idStage: number, idContest: number, idVariant: number, idTask: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksIdTaskTaskimageGet.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksIdTaskTaskimageGet.' )
        }
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksIdTaskTaskimageGet.' )
        }
        if ( idVariant === null || idVariant === undefined )
        {
            throw new Error( 'Required parameter idVariant was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksIdTaskTaskimageGet.' )
        }
        if ( idTask === null || idTask === undefined )
        {
            throw new Error( 'Required parameter idTask was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantIdVariantTasksIdTaskTaskimageGet.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<TaskInVariantImage>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( idVariant ) ) }/tasks/${ encodeURIComponent( String( idTask ) ) }/taskimage`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get info for a different variant
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param variantNum Number of the variant in contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumGet( idOlympiad: number, idStage: number, idContest: number, variantNum: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<VariantInfo>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumGet( idOlympiad: number, idStage: number, idContest: number, variantNum: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<VariantInfo>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumGet( idOlympiad: number, idStage: number, idContest: number, variantNum: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<VariantInfo>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumGet( idOlympiad: number, idStage: number, idContest: number, variantNum: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumGet.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumGet.' )
        }
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumGet.' )
        }
        if ( variantNum === null || variantNum === undefined )
        {
            throw new Error( 'Required parameter variantNum was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumGet.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<VariantInfo>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( variantNum ) ) }`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Edit variant
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param variantNum Number of the variant in contest
     * @param variantInfoUpdate
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumPatch( idOlympiad: number, idStage: number, idContest: number, variantNum: number, variantInfoUpdate: VariantInfoUpdate, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumPatch( idOlympiad: number, idStage: number, idContest: number, variantNum: number, variantInfoUpdate: VariantInfoUpdate, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<any>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumPatch( idOlympiad: number, idStage: number, idContest: number, variantNum: number, variantInfoUpdate: VariantInfoUpdate, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<any>>;
    olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumPatch( idOlympiad: number, idStage: number, idContest: number, variantNum: number, variantInfoUpdate: VariantInfoUpdate, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumPatch.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumPatch.' )
        }
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumPatch.' )
        }
        if ( variantNum === null || variantNum === undefined )
        {
            throw new Error( 'Required parameter variantNum was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumPatch.' )
        }
        if ( variantInfoUpdate === null || variantInfoUpdate === undefined )
        {
            throw new Error( 'Required parameter variantInfoUpdate was null or undefined when calling olympiadIdOlympiadStageIdStageContestIdContestVariantVariantNumPatch.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.patch<any>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( variantNum ) ) }`,
            variantInfoUpdate,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get common info for a different stage
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageGet( idOlympiad: number, idStage: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<StageInfo>;
    olympiadIdOlympiadStageIdStageGet( idOlympiad: number, idStage: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<StageInfo>>;
    olympiadIdOlympiadStageIdStageGet( idOlympiad: number, idStage: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<StageInfo>>;
    olympiadIdOlympiadStageIdStageGet( idOlympiad: number, idStage: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageGet.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageGet.' )
        }

        let headers = this.defaultHeaders

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<StageInfo>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Set stage info for a olympiad
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param stageInfoUpdate
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStagePatch( idOlympiad: number, idStage: number, stageInfoUpdate: StageInfoUpdate, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>;
    olympiadIdOlympiadStageIdStagePatch( idOlympiad: number, idStage: number, stageInfoUpdate: StageInfoUpdate, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<any>>;
    olympiadIdOlympiadStageIdStagePatch( idOlympiad: number, idStage: number, stageInfoUpdate: StageInfoUpdate, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<any>>;
    olympiadIdOlympiadStageIdStagePatch( idOlympiad: number, idStage: number, stageInfoUpdate: StageInfoUpdate, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStagePatch.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStagePatch.' )
        }
        if ( stageInfoUpdate === null || stageInfoUpdate === undefined )
        {
            throw new Error( 'Required parameter stageInfoUpdate was null or undefined when calling olympiadIdOlympiadStageIdStagePatch.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.patch<any>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }`,
            stageInfoUpdate,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Remove stage from olympiad
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    olympiadIdOlympiadStageIdStageRemovePost( idOlympiad: number, idStage: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>;
    olympiadIdOlympiadStageIdStageRemovePost( idOlympiad: number, idStage: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<any>>;
    olympiadIdOlympiadStageIdStageRemovePost( idOlympiad: number, idStage: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<any>>;
    olympiadIdOlympiadStageIdStageRemovePost( idOlympiad: number, idStage: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling olympiadIdOlympiadStageIdStageRemovePost.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling olympiadIdOlympiadStageIdStageRemovePost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/remove`,
            null,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * add new user status to library
     * @param addStatus
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userStatusAddPost( addStatus: AddStatus, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<StatusInfo>;
    userStatusAddPost( addStatus: AddStatus, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<StatusInfo>>;
    userStatusAddPost( addStatus: AddStatus, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<StatusInfo>>;
    userStatusAddPost( addStatus: AddStatus, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( addStatus === null || addStatus === undefined )
        {
            throw new Error( 'Required parameter addStatus was null or undefined when calling userStatusAddPost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<StatusInfo>( `${ this.configuration.basePath }/user_status/add`,
            addStatus,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * list of user_status
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userStatusAllGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<AllStatus>;
    userStatusAllGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<AllStatus>>;
    userStatusAllGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<AllStatus>>;
    userStatusAllGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<AllStatus>( `${ this.configuration.basePath }/user_status/all`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Get info for the user_status
     * @param idStatus Id of the user_status
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userStatusIdStatusGet( idStatus: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<StatusInfo>;
    userStatusIdStatusGet( idStatus: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<StatusInfo>>;
    userStatusIdStatusGet( idStatus: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<StatusInfo>>;
    userStatusIdStatusGet( idStatus: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idStatus === null || idStatus === undefined )
        {
            throw new Error( 'Required parameter idStatus was null or undefined when calling userStatusIdStatusGet.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<StatusInfo>( `${ this.configuration.basePath }/user_status/${ encodeURIComponent( String( idStatus ) ) }`,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Edit user_status
     * @param idStatus Id of the user_status
     * @param statusInfoUpdate
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userStatusIdStatusPatch( idStatus: number, statusInfoUpdate: StatusInfoUpdate, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>;
    userStatusIdStatusPatch( idStatus: number, statusInfoUpdate: StatusInfoUpdate, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<any>>;
    userStatusIdStatusPatch( idStatus: number, statusInfoUpdate: StatusInfoUpdate, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<any>>;
    userStatusIdStatusPatch( idStatus: number, statusInfoUpdate: StatusInfoUpdate, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idStatus === null || idStatus === undefined )
        {
            throw new Error( 'Required parameter idStatus was null or undefined when calling userStatusIdStatusPatch.' )
        }
        if ( statusInfoUpdate === null || statusInfoUpdate === undefined )
        {
            throw new Error( 'Required parameter statusInfoUpdate was null or undefined when calling userStatusIdStatusPatch.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            headers = headers.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.patch<any>( `${ this.configuration.basePath }/user_status/${ encodeURIComponent( String( idStatus ) ) }`,
            statusInfoUpdate,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * Remove user_status
     * @param idStatus Id of the user_status
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    userStatusIdStatusRemovePost( idStatus: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>;
    userStatusIdStatusRemovePost( idStatus: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpResponse<any>>;
    userStatusIdStatusRemovePost( idStatus: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json' } ): Observable<HttpEvent<any>>;
    userStatusIdStatusRemovePost( idStatus: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json' } ): Observable<any>
    {
        if ( idStatus === null || idStatus === undefined )
        {
            throw new Error( 'Required parameter idStatus was null or undefined when calling userStatusIdStatusRemovePost.' )
        }

        let headers = this.defaultHeaders

        let credential: string | undefined
        // authentication (CSRFToken) required
        credential = this.configuration.lookupCredential( 'CSRFToken' )
        if ( credential )
        {
            headers = headers.set( 'X-CSRF-TOKEN', credential )
        }

        // authentication (cookieJWTAuth) required
        credential = this.configuration.lookupCredential( 'cookieJWTAuth' )
        if ( credential )
        {
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( httpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( httpHeaderAcceptSelected !== undefined )
        {
            headers = headers.set( 'Accept', httpHeaderAcceptSelected )
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/user_status//${ encodeURIComponent( String( idStatus ) ) }/remove`,
            null,
            {
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

}
