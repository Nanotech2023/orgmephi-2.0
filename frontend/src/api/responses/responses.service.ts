/**
 * aggregate_contest_responses
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core'
import { HttpClient, HttpContext, HttpEvent, HttpHeaders, HttpParameterCodec, HttpResponse } from '@angular/common/http'
import { Observable } from 'rxjs'
import { CustomHttpParameterCodec } from '@api/encoder'
import { BASE_PATH } from '@api/variables'
import { Configuration } from '@api/configuration'
import { environment } from '@environments/environment'
import {
    AllUserAnswersResponse,
    AllUserMarksResponse,
    AllUserResultsResponse,
    Answer,
    ContestResultSheetResponse,
    MultipleAnswerRequest,
    PlainAnswerRequest,
    RangeAnswerRequest,
    UserAnswerMarkResponse,
    UserResponseStatusResponse,
    UserTimeResponseRequest
} from '@api/responses/model'


@Injectable()
export class ResponsesService
{
    protected basePath = environment.apiUrl + '/contest'
    public defaultHeaders = new HttpHeaders()
    public configuration = new Configuration()
    public encoder: HttpParameterCodec

    constructor( protected httpClient: HttpClient, @Optional() @Inject( BASE_PATH ) basePath: string, @Optional() configuration: Configuration )
    {
        if ( configuration )
        {
            this.configuration = configuration
        }
        if ( typeof this.configuration.basePath !== 'string' )
        {
            if ( typeof basePath !== 'string' )
            {
                basePath = this.basePath
            }
            this.configuration.basePath = basePath
        }
        this.configuration.withCredentials = true
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec()
    }

    /**
     * @param contestId Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesCreatorContestContestIdCheckPost( contestId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public responsesCreatorContestContestIdCheckPost( contestId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public responsesCreatorContestContestIdCheckPost( contestId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public responsesCreatorContestContestIdCheckPost( contestId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesCreatorContestContestIdCheckPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/responses/creator/contest/${ encodeURIComponent( String( contestId ) ) }/check`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesCreatorContestContestIdListGet( contestId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<ContestResultSheetResponse>;
    public responsesCreatorContestContestIdListGet( contestId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<ContestResultSheetResponse>>;
    public responsesCreatorContestContestIdListGet( contestId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<ContestResultSheetResponse>>;
    public responsesCreatorContestContestIdListGet( contestId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesCreatorContestContestIdListGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<ContestResultSheetResponse>( `${ this.configuration.basePath }/responses/creator/contest/${ encodeURIComponent( String( contestId ) ) }/list`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param taskId Id of the task
     * @param userId Id of the user
     * @param filetype Filetype
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @deprecated
     */
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdFiletypePost( contestId: number, taskId: number, userId: number, filetype: string, body?: Blob, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdFiletypePost( contestId: number, taskId: number, userId: number, filetype: string, body?: Blob, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdFiletypePost( contestId: number, taskId: number, userId: number, filetype: string, body?: Blob, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdFiletypePost( contestId: number, taskId: number, userId: number, filetype: string, body?: Blob, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdFiletypePost.' )
        }
        if ( taskId === null || taskId === undefined )
        {
            throw new Error( 'Required parameter taskId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdFiletypePost.' )
        }
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdFiletypePost.' )
        }
        if ( filetype === null || filetype === undefined )
        {
            throw new Error( 'Required parameter filetype was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdFiletypePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/octet-stream'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/responses/creator/contest/${ encodeURIComponent( String( contestId ) ) }/task/${ encodeURIComponent( String( taskId ) ) }/user/${ encodeURIComponent( String( userId ) ) }/${ encodeURIComponent( String( filetype ) ) }`,
            body,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param taskId Id of the task
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdGet( contestId: number, taskId: number, userId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<Answer>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdGet( contestId: number, taskId: number, userId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<Answer>>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdGet( contestId: number, taskId: number, userId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<Answer>>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdGet( contestId: number, taskId: number, userId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdGet.' )
        }
        if ( taskId === null || taskId === undefined )
        {
            throw new Error( 'Required parameter taskId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdGet.' )
        }
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<Answer>( `${ this.configuration.basePath }/responses/creator/contest/${ encodeURIComponent( String( contestId ) ) }/task/${ encodeURIComponent( String( taskId ) ) }/user/${ encodeURIComponent( String( userId ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param taskId Id of the task
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdMarkGet( contestId: number, taskId: number, userId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<UserAnswerMarkResponse>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdMarkGet( contestId: number, taskId: number, userId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<UserAnswerMarkResponse>>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdMarkGet( contestId: number, taskId: number, userId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<UserAnswerMarkResponse>>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdMarkGet( contestId: number, taskId: number, userId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdMarkGet.' )
        }
        if ( taskId === null || taskId === undefined )
        {
            throw new Error( 'Required parameter taskId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdMarkGet.' )
        }
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdMarkGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<UserAnswerMarkResponse>( `${ this.configuration.basePath }/responses/creator/contest/${ encodeURIComponent( String( contestId ) ) }/task/${ encodeURIComponent( String( taskId ) ) }/user/${ encodeURIComponent( String( userId ) ) }/mark`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param taskId Id of the task
     * @param userId Id of the user
     * @param userAnswerMarkResponse
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdMarkPost( contestId: number, taskId: number, userId: number, userAnswerMarkResponse: UserAnswerMarkResponse, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdMarkPost( contestId: number, taskId: number, userId: number, userAnswerMarkResponse: UserAnswerMarkResponse, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdMarkPost( contestId: number, taskId: number, userId: number, userAnswerMarkResponse: UserAnswerMarkResponse, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdMarkPost( contestId: number, taskId: number, userId: number, userAnswerMarkResponse: UserAnswerMarkResponse, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdMarkPost.' )
        }
        if ( taskId === null || taskId === undefined )
        {
            throw new Error( 'Required parameter taskId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdMarkPost.' )
        }
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdMarkPost.' )
        }
        if ( userAnswerMarkResponse === null || userAnswerMarkResponse === undefined )
        {
            throw new Error( 'Required parameter userAnswerMarkResponse was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdMarkPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/responses/creator/contest/${ encodeURIComponent( String( contestId ) ) }/task/${ encodeURIComponent( String( taskId ) ) }/user/${ encodeURIComponent( String( userId ) ) }/mark`,
            userAnswerMarkResponse,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param taskId Id of the task
     * @param userId Id of the user
     * @param multipleAnswerRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdMultiplePost( contestId: number, taskId: number, userId: number, multipleAnswerRequest?: MultipleAnswerRequest, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdMultiplePost( contestId: number, taskId: number, userId: number, multipleAnswerRequest?: MultipleAnswerRequest, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdMultiplePost( contestId: number, taskId: number, userId: number, multipleAnswerRequest?: MultipleAnswerRequest, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdMultiplePost( contestId: number, taskId: number, userId: number, multipleAnswerRequest?: MultipleAnswerRequest, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdMultiplePost.' )
        }
        if ( taskId === null || taskId === undefined )
        {
            throw new Error( 'Required parameter taskId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdMultiplePost.' )
        }
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdMultiplePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/responses/creator/contest/${ encodeURIComponent( String( contestId ) ) }/task/${ encodeURIComponent( String( taskId ) ) }/user/${ encodeURIComponent( String( userId ) ) }/multiple`,
            multipleAnswerRequest,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param taskId Id of the task
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdPlainFileGet( contestId: number, taskId: number, userId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/msword' | 'application/pdf' | 'application/zip' | 'image/gif' | 'image/jpeg' | 'image/png' | 'text/plain', context?: HttpContext } ): Observable<Blob>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdPlainFileGet( contestId: number, taskId: number, userId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/msword' | 'application/pdf' | 'application/zip' | 'image/gif' | 'image/jpeg' | 'image/png' | 'text/plain', context?: HttpContext } ): Observable<HttpResponse<Blob>>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdPlainFileGet( contestId: number, taskId: number, userId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/msword' | 'application/pdf' | 'application/zip' | 'image/gif' | 'image/jpeg' | 'image/png' | 'text/plain', context?: HttpContext } ): Observable<HttpEvent<Blob>>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdPlainFileGet( contestId: number, taskId: number, userId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/msword' | 'application/pdf' | 'application/zip' | 'image/gif' | 'image/jpeg' | 'image/png' | 'text/plain', context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdPlainFileGet.' )
        }
        if ( taskId === null || taskId === undefined )
        {
            throw new Error( 'Required parameter taskId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdPlainFileGet.' )
        }
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdPlainFileGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/msword',
                'application/pdf',
                'application/zip',
                'image/gif',
                'image/jpeg',
                'image/png',
                'text/plain'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        return this.httpClient.get( `${ this.configuration.basePath }/responses/creator/contest/${ encodeURIComponent( String( contestId ) ) }/task/${ encodeURIComponent( String( taskId ) ) }/user/${ encodeURIComponent( String( userId ) ) }/plain/file`,
            {
                context: localVarHttpContext,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param taskId Id of the task
     * @param userId Id of the user
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdPlainFilePost( contestId: number, taskId: number, userId: number, body?: Blob, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdPlainFilePost( contestId: number, taskId: number, userId: number, body?: Blob, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdPlainFilePost( contestId: number, taskId: number, userId: number, body?: Blob, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdPlainFilePost( contestId: number, taskId: number, userId: number, body?: Blob, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdPlainFilePost.' )
        }
        if ( taskId === null || taskId === undefined )
        {
            throw new Error( 'Required parameter taskId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdPlainFilePost.' )
        }
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdPlainFilePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/msword',
            'application/pdf',
            'application/zip',
            'image/gif',
            'image/jpeg',
            'image/png',
            'text/plain'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/responses/creator/contest/${ encodeURIComponent( String( contestId ) ) }/task/${ encodeURIComponent( String( taskId ) ) }/user/${ encodeURIComponent( String( userId ) ) }/plain/file`,
            body,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param taskId Id of the task
     * @param userId Id of the user
     * @param plainAnswerRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdPlainPost( contestId: number, taskId: number, userId: number, plainAnswerRequest?: PlainAnswerRequest, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdPlainPost( contestId: number, taskId: number, userId: number, plainAnswerRequest?: PlainAnswerRequest, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdPlainPost( contestId: number, taskId: number, userId: number, plainAnswerRequest?: PlainAnswerRequest, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdPlainPost( contestId: number, taskId: number, userId: number, plainAnswerRequest?: PlainAnswerRequest, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdPlainPost.' )
        }
        if ( taskId === null || taskId === undefined )
        {
            throw new Error( 'Required parameter taskId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdPlainPost.' )
        }
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdPlainPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/responses/creator/contest/${ encodeURIComponent( String( contestId ) ) }/task/${ encodeURIComponent( String( taskId ) ) }/user/${ encodeURIComponent( String( userId ) ) }/plain`,
            plainAnswerRequest,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param taskId Id of the task
     * @param userId Id of the user
     * @param rangeAnswerRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdRangePost( contestId: number, taskId: number, userId: number, rangeAnswerRequest?: RangeAnswerRequest, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdRangePost( contestId: number, taskId: number, userId: number, rangeAnswerRequest?: RangeAnswerRequest, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdRangePost( contestId: number, taskId: number, userId: number, rangeAnswerRequest?: RangeAnswerRequest, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public responsesCreatorContestContestIdTaskTaskIdUserUserIdRangePost( contestId: number, taskId: number, userId: number, rangeAnswerRequest?: RangeAnswerRequest, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdRangePost.' )
        }
        if ( taskId === null || taskId === undefined )
        {
            throw new Error( 'Required parameter taskId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdRangePost.' )
        }
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling responsesCreatorContestContestIdTaskTaskIdUserUserIdRangePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/responses/creator/contest/${ encodeURIComponent( String( contestId ) ) }/task/${ encodeURIComponent( String( taskId ) ) }/user/${ encodeURIComponent( String( userId ) ) }/range`,
            rangeAnswerRequest,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesCreatorContestContestIdUserUserIdCreatePost( contestId: number, userId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public responsesCreatorContestContestIdUserUserIdCreatePost( contestId: number, userId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public responsesCreatorContestContestIdUserUserIdCreatePost( contestId: number, userId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public responsesCreatorContestContestIdUserUserIdCreatePost( contestId: number, userId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesCreatorContestContestIdUserUserIdCreatePost.' )
        }
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling responsesCreatorContestContestIdUserUserIdCreatePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/responses/creator/contest/${ encodeURIComponent( String( contestId ) ) }/user/${ encodeURIComponent( String( userId ) ) }/create`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesCreatorContestContestIdUserUserIdFinishPost( contestId: number, userId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public responsesCreatorContestContestIdUserUserIdFinishPost( contestId: number, userId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public responsesCreatorContestContestIdUserUserIdFinishPost( contestId: number, userId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public responsesCreatorContestContestIdUserUserIdFinishPost( contestId: number, userId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesCreatorContestContestIdUserUserIdFinishPost.' )
        }
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling responsesCreatorContestContestIdUserUserIdFinishPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/responses/creator/contest/${ encodeURIComponent( String( contestId ) ) }/user/${ encodeURIComponent( String( userId ) ) }/finish`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesCreatorContestContestIdUserUserIdMarkGet( contestId: number, userId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllUserMarksResponse>;
    public responsesCreatorContestContestIdUserUserIdMarkGet( contestId: number, userId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllUserMarksResponse>>;
    public responsesCreatorContestContestIdUserUserIdMarkGet( contestId: number, userId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllUserMarksResponse>>;
    public responsesCreatorContestContestIdUserUserIdMarkGet( contestId: number, userId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesCreatorContestContestIdUserUserIdMarkGet.' )
        }
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling responsesCreatorContestContestIdUserUserIdMarkGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<AllUserMarksResponse>( `${ this.configuration.basePath }/responses/creator/contest/${ encodeURIComponent( String( contestId ) ) }/user/${ encodeURIComponent( String( userId ) ) }/mark`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesCreatorContestContestIdUserUserIdResponseGet( contestId: number, userId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllUserAnswersResponse>;
    public responsesCreatorContestContestIdUserUserIdResponseGet( contestId: number, userId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllUserAnswersResponse>>;
    public responsesCreatorContestContestIdUserUserIdResponseGet( contestId: number, userId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllUserAnswersResponse>>;
    public responsesCreatorContestContestIdUserUserIdResponseGet( contestId: number, userId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesCreatorContestContestIdUserUserIdResponseGet.' )
        }
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling responsesCreatorContestContestIdUserUserIdResponseGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<AllUserAnswersResponse>( `${ this.configuration.basePath }/responses/creator/contest/${ encodeURIComponent( String( contestId ) ) }/user/${ encodeURIComponent( String( userId ) ) }/response`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesCreatorContestContestIdUserUserIdStatusGet( contestId: number, userId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<UserResponseStatusResponse>;
    public responsesCreatorContestContestIdUserUserIdStatusGet( contestId: number, userId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<UserResponseStatusResponse>>;
    public responsesCreatorContestContestIdUserUserIdStatusGet( contestId: number, userId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<UserResponseStatusResponse>>;
    public responsesCreatorContestContestIdUserUserIdStatusGet( contestId: number, userId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesCreatorContestContestIdUserUserIdStatusGet.' )
        }
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling responsesCreatorContestContestIdUserUserIdStatusGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<UserResponseStatusResponse>( `${ this.configuration.basePath }/responses/creator/contest/${ encodeURIComponent( String( contestId ) ) }/user/${ encodeURIComponent( String( userId ) ) }/status`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param userId Id of the user
     * @param userResponseStatusResponse
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesCreatorContestContestIdUserUserIdStatusPost( contestId: number, userId: number, userResponseStatusResponse: UserResponseStatusResponse, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public responsesCreatorContestContestIdUserUserIdStatusPost( contestId: number, userId: number, userResponseStatusResponse: UserResponseStatusResponse, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public responsesCreatorContestContestIdUserUserIdStatusPost( contestId: number, userId: number, userResponseStatusResponse: UserResponseStatusResponse, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public responsesCreatorContestContestIdUserUserIdStatusPost( contestId: number, userId: number, userResponseStatusResponse: UserResponseStatusResponse, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesCreatorContestContestIdUserUserIdStatusPost.' )
        }
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling responsesCreatorContestContestIdUserUserIdStatusPost.' )
        }
        if ( userResponseStatusResponse === null || userResponseStatusResponse === undefined )
        {
            throw new Error( 'Required parameter userResponseStatusResponse was null or undefined when calling responsesCreatorContestContestIdUserUserIdStatusPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/responses/creator/contest/${ encodeURIComponent( String( contestId ) ) }/user/${ encodeURIComponent( String( userId ) ) }/status`,
            userResponseStatusResponse,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesCreatorContestContestIdUserUserIdTimeExtraGet( contestId: number, userId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<UserTimeResponseRequest>;
    public responsesCreatorContestContestIdUserUserIdTimeExtraGet( contestId: number, userId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<UserTimeResponseRequest>>;
    public responsesCreatorContestContestIdUserUserIdTimeExtraGet( contestId: number, userId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<UserTimeResponseRequest>>;
    public responsesCreatorContestContestIdUserUserIdTimeExtraGet( contestId: number, userId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesCreatorContestContestIdUserUserIdTimeExtraGet.' )
        }
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling responsesCreatorContestContestIdUserUserIdTimeExtraGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<UserTimeResponseRequest>( `${ this.configuration.basePath }/responses/creator/contest/${ encodeURIComponent( String( contestId ) ) }/user/${ encodeURIComponent( String( userId ) ) }/time/extra`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param userId Id of the user
     * @param userTimeResponseRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesCreatorContestContestIdUserUserIdTimeExtraPost( contestId: number, userId: number, userTimeResponseRequest: UserTimeResponseRequest, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public responsesCreatorContestContestIdUserUserIdTimeExtraPost( contestId: number, userId: number, userTimeResponseRequest: UserTimeResponseRequest, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public responsesCreatorContestContestIdUserUserIdTimeExtraPost( contestId: number, userId: number, userTimeResponseRequest: UserTimeResponseRequest, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public responsesCreatorContestContestIdUserUserIdTimeExtraPost( contestId: number, userId: number, userTimeResponseRequest: UserTimeResponseRequest, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesCreatorContestContestIdUserUserIdTimeExtraPost.' )
        }
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling responsesCreatorContestContestIdUserUserIdTimeExtraPost.' )
        }
        if ( userTimeResponseRequest === null || userTimeResponseRequest === undefined )
        {
            throw new Error( 'Required parameter userTimeResponseRequest was null or undefined when calling responsesCreatorContestContestIdUserUserIdTimeExtraPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/responses/creator/contest/${ encodeURIComponent( String( contestId ) ) }/user/${ encodeURIComponent( String( userId ) ) }/time/extra`,
            userTimeResponseRequest,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesCreatorContestContestIdUserUserIdTimeGet( contestId: number, userId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<UserTimeResponseRequest>;
    public responsesCreatorContestContestIdUserUserIdTimeGet( contestId: number, userId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<UserTimeResponseRequest>>;
    public responsesCreatorContestContestIdUserUserIdTimeGet( contestId: number, userId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<UserTimeResponseRequest>>;
    public responsesCreatorContestContestIdUserUserIdTimeGet( contestId: number, userId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesCreatorContestContestIdUserUserIdTimeGet.' )
        }
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling responsesCreatorContestContestIdUserUserIdTimeGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<UserTimeResponseRequest>( `${ this.configuration.basePath }/responses/creator/contest/${ encodeURIComponent( String( contestId ) ) }/user/${ encodeURIComponent( String( userId ) ) }/time`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesCreatorContestContestIdWinningPost( contestId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public responsesCreatorContestContestIdWinningPost( contestId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public responsesCreatorContestContestIdWinningPost( contestId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public responsesCreatorContestContestIdWinningPost( contestId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesCreatorContestContestIdWinningPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/responses/creator/contest/${ encodeURIComponent( String( contestId ) ) }/winning`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param userId Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesCreatorContestUserUserIdResultsGet( userId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllUserResultsResponse>;
    public responsesCreatorContestUserUserIdResultsGet( userId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllUserResultsResponse>>;
    public responsesCreatorContestUserUserIdResultsGet( userId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllUserResultsResponse>>;
    public responsesCreatorContestUserUserIdResultsGet( userId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling responsesCreatorContestUserUserIdResultsGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<AllUserResultsResponse>( `${ this.configuration.basePath }/responses/creator/contest/user/${ encodeURIComponent( String( userId ) ) }/results`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param taskId Id of the task
     * @param filetype Filetype
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @deprecated
     */
    public responsesParticipantContestContestIdTaskTaskIdUserSelfFiletypePost( contestId: number, taskId: number, filetype: string, body?: Blob, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public responsesParticipantContestContestIdTaskTaskIdUserSelfFiletypePost( contestId: number, taskId: number, filetype: string, body?: Blob, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public responsesParticipantContestContestIdTaskTaskIdUserSelfFiletypePost( contestId: number, taskId: number, filetype: string, body?: Blob, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public responsesParticipantContestContestIdTaskTaskIdUserSelfFiletypePost( contestId: number, taskId: number, filetype: string, body?: Blob, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesParticipantContestContestIdTaskTaskIdUserSelfFiletypePost.' )
        }
        if ( taskId === null || taskId === undefined )
        {
            throw new Error( 'Required parameter taskId was null or undefined when calling responsesParticipantContestContestIdTaskTaskIdUserSelfFiletypePost.' )
        }
        if ( filetype === null || filetype === undefined )
        {
            throw new Error( 'Required parameter filetype was null or undefined when calling responsesParticipantContestContestIdTaskTaskIdUserSelfFiletypePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/octet-stream'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/responses/participant/contest/${ encodeURIComponent( String( contestId ) ) }/task/${ encodeURIComponent( String( taskId ) ) }/user/self/${ encodeURIComponent( String( filetype ) ) }`,
            body,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param taskId Id of the task
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesParticipantContestContestIdTaskTaskIdUserSelfGet( contestId: number, taskId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<Answer>;
    public responsesParticipantContestContestIdTaskTaskIdUserSelfGet( contestId: number, taskId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<Answer>>;
    public responsesParticipantContestContestIdTaskTaskIdUserSelfGet( contestId: number, taskId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<Answer>>;
    public responsesParticipantContestContestIdTaskTaskIdUserSelfGet( contestId: number, taskId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesParticipantContestContestIdTaskTaskIdUserSelfGet.' )
        }
        if ( taskId === null || taskId === undefined )
        {
            throw new Error( 'Required parameter taskId was null or undefined when calling responsesParticipantContestContestIdTaskTaskIdUserSelfGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<Answer>( `${ this.configuration.basePath }/responses/participant/contest/${ encodeURIComponent( String( contestId ) ) }/task/${ encodeURIComponent( String( taskId ) ) }/user/self`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param taskId Id of the task
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesParticipantContestContestIdTaskTaskIdUserSelfMarkGet( contestId: number, taskId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<UserAnswerMarkResponse>;
    public responsesParticipantContestContestIdTaskTaskIdUserSelfMarkGet( contestId: number, taskId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<UserAnswerMarkResponse>>;
    public responsesParticipantContestContestIdTaskTaskIdUserSelfMarkGet( contestId: number, taskId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<UserAnswerMarkResponse>>;
    public responsesParticipantContestContestIdTaskTaskIdUserSelfMarkGet( contestId: number, taskId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesParticipantContestContestIdTaskTaskIdUserSelfMarkGet.' )
        }
        if ( taskId === null || taskId === undefined )
        {
            throw new Error( 'Required parameter taskId was null or undefined when calling responsesParticipantContestContestIdTaskTaskIdUserSelfMarkGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<UserAnswerMarkResponse>( `${ this.configuration.basePath }/responses/participant/contest/${ encodeURIComponent( String( contestId ) ) }/task/${ encodeURIComponent( String( taskId ) ) }/user/self/mark`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param taskId Id of the task
     * @param multipleAnswerRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesParticipantContestContestIdTaskTaskIdUserSelfMultiplePost( contestId: number, taskId: number, multipleAnswerRequest?: MultipleAnswerRequest, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public responsesParticipantContestContestIdTaskTaskIdUserSelfMultiplePost( contestId: number, taskId: number, multipleAnswerRequest?: MultipleAnswerRequest, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public responsesParticipantContestContestIdTaskTaskIdUserSelfMultiplePost( contestId: number, taskId: number, multipleAnswerRequest?: MultipleAnswerRequest, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public responsesParticipantContestContestIdTaskTaskIdUserSelfMultiplePost( contestId: number, taskId: number, multipleAnswerRequest?: MultipleAnswerRequest, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesParticipantContestContestIdTaskTaskIdUserSelfMultiplePost.' )
        }
        if ( taskId === null || taskId === undefined )
        {
            throw new Error( 'Required parameter taskId was null or undefined when calling responsesParticipantContestContestIdTaskTaskIdUserSelfMultiplePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/responses/participant/contest/${ encodeURIComponent( String( contestId ) ) }/task/${ encodeURIComponent( String( taskId ) ) }/user/self/multiple`,
            multipleAnswerRequest,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param taskId Id of the task
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesParticipantContestContestIdTaskTaskIdUserSelfPlainFileGet( contestId: number, taskId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/msword' | 'application/pdf' | 'application/zip' | 'image/gif' | 'image/jpeg' | 'image/png' | 'text/plain', context?: HttpContext } ): Observable<Blob>;
    public responsesParticipantContestContestIdTaskTaskIdUserSelfPlainFileGet( contestId: number, taskId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/msword' | 'application/pdf' | 'application/zip' | 'image/gif' | 'image/jpeg' | 'image/png' | 'text/plain', context?: HttpContext } ): Observable<HttpResponse<Blob>>;
    public responsesParticipantContestContestIdTaskTaskIdUserSelfPlainFileGet( contestId: number, taskId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/msword' | 'application/pdf' | 'application/zip' | 'image/gif' | 'image/jpeg' | 'image/png' | 'text/plain', context?: HttpContext } ): Observable<HttpEvent<Blob>>;
    public responsesParticipantContestContestIdTaskTaskIdUserSelfPlainFileGet( contestId: number, taskId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/msword' | 'application/pdf' | 'application/zip' | 'image/gif' | 'image/jpeg' | 'image/png' | 'text/plain', context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesParticipantContestContestIdTaskTaskIdUserSelfPlainFileGet.' )
        }
        if ( taskId === null || taskId === undefined )
        {
            throw new Error( 'Required parameter taskId was null or undefined when calling responsesParticipantContestContestIdTaskTaskIdUserSelfPlainFileGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/msword',
                'application/pdf',
                'application/zip',
                'image/gif',
                'image/jpeg',
                'image/png',
                'text/plain'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        return this.httpClient.get( `${ this.configuration.basePath }/responses/participant/contest/${ encodeURIComponent( String( contestId ) ) }/task/${ encodeURIComponent( String( taskId ) ) }/user/self/plain/file`,
            {
                context: localVarHttpContext,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param taskId Id of the task
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesParticipantContestContestIdTaskTaskIdUserSelfPlainFilePost( contestId: number, taskId: number, body?: Blob, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public responsesParticipantContestContestIdTaskTaskIdUserSelfPlainFilePost( contestId: number, taskId: number, body?: Blob, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public responsesParticipantContestContestIdTaskTaskIdUserSelfPlainFilePost( contestId: number, taskId: number, body?: Blob, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public responsesParticipantContestContestIdTaskTaskIdUserSelfPlainFilePost( contestId: number, taskId: number, body?: Blob, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesParticipantContestContestIdTaskTaskIdUserSelfPlainFilePost.' )
        }
        if ( taskId === null || taskId === undefined )
        {
            throw new Error( 'Required parameter taskId was null or undefined when calling responsesParticipantContestContestIdTaskTaskIdUserSelfPlainFilePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/msword',
            'application/pdf',
            'application/zip',
            'image/gif',
            'image/jpeg',
            'image/png',
            'text/plain'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/responses/participant/contest/${ encodeURIComponent( String( contestId ) ) }/task/${ encodeURIComponent( String( taskId ) ) }/user/self/plain/file`,
            body,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param taskId Id of the task
     * @param plainAnswerRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesParticipantContestContestIdTaskTaskIdUserSelfPlainPost( contestId: number, taskId: number, plainAnswerRequest?: PlainAnswerRequest, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public responsesParticipantContestContestIdTaskTaskIdUserSelfPlainPost( contestId: number, taskId: number, plainAnswerRequest?: PlainAnswerRequest, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public responsesParticipantContestContestIdTaskTaskIdUserSelfPlainPost( contestId: number, taskId: number, plainAnswerRequest?: PlainAnswerRequest, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public responsesParticipantContestContestIdTaskTaskIdUserSelfPlainPost( contestId: number, taskId: number, plainAnswerRequest?: PlainAnswerRequest, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesParticipantContestContestIdTaskTaskIdUserSelfPlainPost.' )
        }
        if ( taskId === null || taskId === undefined )
        {
            throw new Error( 'Required parameter taskId was null or undefined when calling responsesParticipantContestContestIdTaskTaskIdUserSelfPlainPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/responses/participant/contest/${ encodeURIComponent( String( contestId ) ) }/task/${ encodeURIComponent( String( taskId ) ) }/user/self/plain`,
            plainAnswerRequest,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param taskId Id of the task
     * @param rangeAnswerRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesParticipantContestContestIdTaskTaskIdUserSelfRangePost( contestId: number, taskId: number, rangeAnswerRequest?: RangeAnswerRequest, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public responsesParticipantContestContestIdTaskTaskIdUserSelfRangePost( contestId: number, taskId: number, rangeAnswerRequest?: RangeAnswerRequest, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public responsesParticipantContestContestIdTaskTaskIdUserSelfRangePost( contestId: number, taskId: number, rangeAnswerRequest?: RangeAnswerRequest, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public responsesParticipantContestContestIdTaskTaskIdUserSelfRangePost( contestId: number, taskId: number, rangeAnswerRequest?: RangeAnswerRequest, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesParticipantContestContestIdTaskTaskIdUserSelfRangePost.' )
        }
        if ( taskId === null || taskId === undefined )
        {
            throw new Error( 'Required parameter taskId was null or undefined when calling responsesParticipantContestContestIdTaskTaskIdUserSelfRangePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/responses/participant/contest/${ encodeURIComponent( String( contestId ) ) }/task/${ encodeURIComponent( String( taskId ) ) }/user/self/range`,
            rangeAnswerRequest,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesParticipantContestContestIdUserSelfCreatePost( contestId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public responsesParticipantContestContestIdUserSelfCreatePost( contestId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public responsesParticipantContestContestIdUserSelfCreatePost( contestId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public responsesParticipantContestContestIdUserSelfCreatePost( contestId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesParticipantContestContestIdUserSelfCreatePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/responses/participant/contest/${ encodeURIComponent( String( contestId ) ) }/user/self/create`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesParticipantContestContestIdUserSelfFinishPost( contestId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public responsesParticipantContestContestIdUserSelfFinishPost( contestId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public responsesParticipantContestContestIdUserSelfFinishPost( contestId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public responsesParticipantContestContestIdUserSelfFinishPost( contestId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesParticipantContestContestIdUserSelfFinishPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/responses/participant/contest/${ encodeURIComponent( String( contestId ) ) }/user/self/finish`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesParticipantContestContestIdUserSelfMarkGet( contestId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllUserMarksResponse>;
    public responsesParticipantContestContestIdUserSelfMarkGet( contestId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllUserMarksResponse>>;
    public responsesParticipantContestContestIdUserSelfMarkGet( contestId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllUserMarksResponse>>;
    public responsesParticipantContestContestIdUserSelfMarkGet( contestId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesParticipantContestContestIdUserSelfMarkGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<AllUserMarksResponse>( `${ this.configuration.basePath }/responses/participant/contest/${ encodeURIComponent( String( contestId ) ) }/user/self/mark`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesParticipantContestContestIdUserSelfResponseGet( contestId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllUserAnswersResponse>;
    public responsesParticipantContestContestIdUserSelfResponseGet( contestId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllUserAnswersResponse>>;
    public responsesParticipantContestContestIdUserSelfResponseGet( contestId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllUserAnswersResponse>>;
    public responsesParticipantContestContestIdUserSelfResponseGet( contestId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesParticipantContestContestIdUserSelfResponseGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<AllUserAnswersResponse>( `${ this.configuration.basePath }/responses/participant/contest/${ encodeURIComponent( String( contestId ) ) }/user/self/response`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesParticipantContestContestIdUserSelfStatusGet( contestId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<UserResponseStatusResponse>;
    public responsesParticipantContestContestIdUserSelfStatusGet( contestId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<UserResponseStatusResponse>>;
    public responsesParticipantContestContestIdUserSelfStatusGet( contestId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<UserResponseStatusResponse>>;
    public responsesParticipantContestContestIdUserSelfStatusGet( contestId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesParticipantContestContestIdUserSelfStatusGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<UserResponseStatusResponse>( `${ this.configuration.basePath }/responses/participant/contest/${ encodeURIComponent( String( contestId ) ) }/user/self/status`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesParticipantContestContestIdUserSelfTimeGet( contestId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<UserTimeResponseRequest>;
    public responsesParticipantContestContestIdUserSelfTimeGet( contestId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<UserTimeResponseRequest>>;
    public responsesParticipantContestContestIdUserSelfTimeGet( contestId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<UserTimeResponseRequest>>;
    public responsesParticipantContestContestIdUserSelfTimeGet( contestId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling responsesParticipantContestContestIdUserSelfTimeGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<UserTimeResponseRequest>( `${ this.configuration.basePath }/responses/participant/contest/${ encodeURIComponent( String( contestId ) ) }/user/self/time`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public responsesParticipantContestUserSelfResultsGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllUserResultsResponse>;
    public responsesParticipantContestUserSelfResultsGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllUserResultsResponse>>;
    public responsesParticipantContestUserSelfResultsGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllUserResultsResponse>>;
    public responsesParticipantContestUserSelfResultsGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<AllUserResultsResponse>( `${ this.configuration.basePath }/responses/participant/contest/user/self/results`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }
}