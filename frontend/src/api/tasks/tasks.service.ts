/**
 * aggregate_contest_tasks
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core'
import {
    HttpClient,
    HttpContext,
    HttpEvent,
    HttpHeaders,
    HttpParameterCodec,
    HttpParams,
    HttpResponse
} from '@angular/common/http'
import { Observable } from 'rxjs'
import { CustomHttpParameterCodec } from '@api/encoder'
import { BASE_PATH } from '@api/variables'
import { Configuration } from '@api/configuration'
import { environment } from '@environments/environment'
import {
    AllBaseContestResponseTaskUnauthorized,
    AllLocationResponseTaskUnauthorized,
    AllOlympiadsResponseTaskCreator,
    AllOlympiadsResponseTaskUnauthorized,
    AllOlympiadTypesResponseTaskUnauthorized,
    AllStagesResponseTaskUnauthorized,
    AllTargetClassesRequestTaskUnauthorized,
    AllTaskResponseTaskParticipant,
    AllTasksResponseTaskCreator,
    AllVariantsResponseTaskCreator,
    BaseContest,
    BaseOlympiadIdResponseTaskCreator,
    BaseOlympiadResponseTaskCreator,
    ChangeSupervisorRequestTaskParticipant,
    ChangeUsersLocationInContestRequestTaskControlUsers,
    Contest,
    ContestGroupRestrictionListAdmin,
    ContestIdResponseTaskCreator,
    ContestResponseTaskCreator,
    CreateCompositeContestRequestTaskCreator,
    CreateOlympiadTypeRequestTaskAdmin,
    CreateOnlineLocationRequestTaskAdmin,
    CreateOtherLocationRequestTaskAdmin,
    CreateRussiaLocationRequestTaskAdmin,
    CreateSimpleContestRequestTaskCreator,
    CreateStageRequestTaskCreator,
    EnrollRequestTaskParticipant,
    FilterSimpleContestResponse,
    FilterSimpleContestResponseTaskParticipant,
    LocationResponseTaskAdmin,
    OlympiadLocation,
    OlympiadType,
    OlympiadTypeResponseTaskAdmin,
    Stage,
    StageIdResponseTaskCreator,
    StageResponseTaskCreator,
    TargetClass,
    TaskIdResponseTaskCreator,
    TaskResponseTaskCreator,
    UpdateBaseOlympiadRequestTaskEditor,
    UpdateContestRequestTaskEditor,
    UpdateLocationOfContestRequestTaskEditor,
    UpdatePreviousContestRequestTaskEditor,
    UpdateStageRequestTaskEditor,
    UpdateTargetClassesOfContestRequestTaskEditor,
    UpdateUserInContestRequestTaskControlUsers,
    UsersResponseTaskControlUsers,
    VariantResponseTaskCreator,
    VariantWithCompletedTasksCountTaskParticipant,
    AllContestTaskResponseTaskCreator,
    AllTaskPoolsResponseTaskCreator,
    Certificate,
    CertificateGetResponseTaskEditor,
    CertificateType,
    ContestTask,
    ContestTaskResponseTaskCreator,
    FontsResponseTasksAdmin,
    MultipleChoiceTask,
    PlainTask,
    RangeTask,
    TaskPool,
    TaskPoolIdResponseTaskCreator,
    VariantIdResponseTaskAdmin,
    UserProctoringDataResponseTaskParticipant,
    UserExternalDataResponseTaskParticipant
} from '@api/tasks/model'


@Injectable()
export class TasksService
{
    protected basePath = environment.apiUrl + '/contest'
    public defaultHeaders = new HttpHeaders()
    public configuration = new Configuration()
    public encoder: HttpParameterCodec

    constructor( protected httpClient: HttpClient, @Optional() @Inject( BASE_PATH ) basePath: string, @Optional() configuration: Configuration )
    {
        if ( configuration )
        {
            this.configuration = configuration
        }
        if ( typeof this.configuration.basePath !== 'string' )
        {
            if ( typeof basePath !== 'string' )
            {
                basePath = this.basePath
            }
            this.configuration.basePath = basePath
        }
        this.configuration.withCredentials = true
        this.configuration.credentials[ "CSRFAccessToken" ] = () => localStorage.getItem( 'CSRFAccessToken' ) ?? undefined
        this.configuration.credentials[ "CSRFRefreshToken" ] = () => localStorage.getItem( 'CSRFRefreshToken' ) ?? undefined
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec()
    }

    private addToHttpParams( httpParams: HttpParams, value: any, key?: string ): HttpParams
    {
        if ( typeof value === "object" && value instanceof Date === false )
        {
            httpParams = this.addToHttpParamsRecursive( httpParams, value )
        }
        else
        {
            httpParams = this.addToHttpParamsRecursive( httpParams, value, key )
        }
        return httpParams
    }

    private addToHttpParamsRecursive( httpParams: HttpParams, value?: any, key?: string ): HttpParams
    {
        if ( value == null )
        {
            return httpParams
        }

        if ( typeof value === "object" )
        {
            if ( Array.isArray( value ) )
            {
                ( value as any[] ).forEach( elem => httpParams = this.addToHttpParamsRecursive( httpParams, elem, key ) )
            }
            else if ( value instanceof Date )
            {
                if ( key != null )
                {
                    httpParams = httpParams.append( key,
                        ( value as Date ).toISOString().substr( 0, 10 ) )
                }
                else
                {
                    throw Error( "key may not be null if value is Date" )
                }
            }
            else
            {
                Object.keys( value ).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[ k ], key != null ? `${ key }.${ k }` : k ) )
            }
        }
        else if ( key != null )
        {
            httpParams = httpParams.append( key, value )
        }
        else
        {
            throw Error( "key may not be null if value is not object or array" )
        }
        return httpParams
    }

    /**
     * @param certificateId Id of the certificate
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksAdminCertificateCertificateIdDelete( certificateId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksAdminCertificateCertificateIdDelete( certificateId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksAdminCertificateCertificateIdDelete( certificateId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksAdminCertificateCertificateIdDelete( certificateId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( certificateId === null || certificateId === undefined )
        {
            throw new Error( 'Required parameter certificateId was null or undefined when calling tasksAdminCertificateCertificateIdDelete.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.delete<any>( `${ this.configuration.basePath }/tasks/admin/certificate/${ encodeURIComponent( String( certificateId ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param certificateId Id of the certificate
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksAdminCertificateCertificateIdImagePost( certificateId: number, body: Blob, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksAdminCertificateCertificateIdImagePost( certificateId: number, body: Blob, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksAdminCertificateCertificateIdImagePost( certificateId: number, body: Blob, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksAdminCertificateCertificateIdImagePost( certificateId: number, body: Blob, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( certificateId === null || certificateId === undefined )
        {
            throw new Error( 'Required parameter certificateId was null or undefined when calling tasksAdminCertificateCertificateIdImagePost.' )
        }
        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling tasksAdminCertificateCertificateIdImagePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'image/jpeg',
            'image/png'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/admin/certificate/${ encodeURIComponent( String( certificateId ) ) }/image`,
            body,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param certificateId Id of the certificate
     * @param certificate
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksAdminCertificateCertificateIdPatch( certificateId: number, certificate: Certificate, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksAdminCertificateCertificateIdPatch( certificateId: number, certificate: Certificate, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksAdminCertificateCertificateIdPatch( certificateId: number, certificate: Certificate, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksAdminCertificateCertificateIdPatch( certificateId: number, certificate: Certificate, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( certificateId === null || certificateId === undefined )
        {
            throw new Error( 'Required parameter certificateId was null or undefined when calling tasksAdminCertificateCertificateIdPatch.' )
        }
        if ( certificate === null || certificate === undefined )
        {
            throw new Error( 'Required parameter certificate was null or undefined when calling tasksAdminCertificateCertificateIdPatch.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.patch<any>( `${ this.configuration.basePath }/tasks/admin/certificate/${ encodeURIComponent( String( certificateId ) ) }`,
            certificate,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param certificateId Id of the certificate
     * @param firstName User first name
     * @param secondName User second name
     * @param middleName User middle name
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksAdminCertificateCertificateIdTestGet( certificateId: number, firstName?: number, secondName?: number, middleName?: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/pdf', context?: HttpContext } ): Observable<Blob>;
    public tasksAdminCertificateCertificateIdTestGet( certificateId: number, firstName?: number, secondName?: number, middleName?: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/pdf', context?: HttpContext } ): Observable<HttpResponse<Blob>>;
    public tasksAdminCertificateCertificateIdTestGet( certificateId: number, firstName?: number, secondName?: number, middleName?: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/pdf', context?: HttpContext } ): Observable<HttpEvent<Blob>>;
    public tasksAdminCertificateCertificateIdTestGet( certificateId: number, firstName?: number, secondName?: number, middleName?: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/pdf', context?: HttpContext } ): Observable<any>
    {
        if ( certificateId === null || certificateId === undefined )
        {
            throw new Error( 'Required parameter certificateId was null or undefined when calling tasksAdminCertificateCertificateIdTestGet.' )
        }

        let localVarQueryParameters = new HttpParams( { encoder: this.encoder } )
        if ( firstName !== undefined && firstName !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> firstName, 'first_name' )
        }
        if ( secondName !== undefined && secondName !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> secondName, 'second_name' )
        }
        if ( middleName !== undefined && middleName !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> middleName, 'middle_name' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/pdf'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        return this.httpClient.get( `${ this.configuration.basePath }/tasks/admin/certificate/${ encodeURIComponent( String( certificateId ) ) }/test`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param userId Id of the user
     * @param contestId Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksAdminCertificateGet( userId: number, contestId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/pdf', context?: HttpContext } ): Observable<Blob>;
    public tasksAdminCertificateGet( userId: number, contestId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/pdf', context?: HttpContext } ): Observable<HttpResponse<Blob>>;
    public tasksAdminCertificateGet( userId: number, contestId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/pdf', context?: HttpContext } ): Observable<HttpEvent<Blob>>;
    public tasksAdminCertificateGet( userId: number, contestId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/pdf', context?: HttpContext } ): Observable<any>
    {
        if ( userId === null || userId === undefined )
        {
            throw new Error( 'Required parameter userId was null or undefined when calling tasksAdminCertificateGet.' )
        }
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling tasksAdminCertificateGet.' )
        }

        let localVarQueryParameters = new HttpParams( { encoder: this.encoder } )
        if ( userId !== undefined && userId !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> userId, 'user_id' )
        }
        if ( contestId !== undefined && contestId !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> contestId, 'contest_id' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/pdf'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        return this.httpClient.get( `${ this.configuration.basePath }/tasks/admin/certificate`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param certificateTypeId Id of the certificate type
     * @param certificate
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksAdminCertificateTypeCertificateTypeIdCertificatePost( certificateTypeId: number, certificate: Certificate, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<Certificate>;
    public tasksAdminCertificateTypeCertificateTypeIdCertificatePost( certificateTypeId: number, certificate: Certificate, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<Certificate>>;
    public tasksAdminCertificateTypeCertificateTypeIdCertificatePost( certificateTypeId: number, certificate: Certificate, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<Certificate>>;
    public tasksAdminCertificateTypeCertificateTypeIdCertificatePost( certificateTypeId: number, certificate: Certificate, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( certificateTypeId === null || certificateTypeId === undefined )
        {
            throw new Error( 'Required parameter certificateTypeId was null or undefined when calling tasksAdminCertificateTypeCertificateTypeIdCertificatePost.' )
        }
        if ( certificate === null || certificate === undefined )
        {
            throw new Error( 'Required parameter certificate was null or undefined when calling tasksAdminCertificateTypeCertificateTypeIdCertificatePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<Certificate>( `${ this.configuration.basePath }/tasks/admin/certificate_type/${ encodeURIComponent( String( certificateTypeId ) ) }/certificate`,
            certificate,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param certificateTypeId Id of the certificate type
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksAdminCertificateTypeCertificateTypeIdDelete( certificateTypeId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksAdminCertificateTypeCertificateTypeIdDelete( certificateTypeId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksAdminCertificateTypeCertificateTypeIdDelete( certificateTypeId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksAdminCertificateTypeCertificateTypeIdDelete( certificateTypeId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( certificateTypeId === null || certificateTypeId === undefined )
        {
            throw new Error( 'Required parameter certificateTypeId was null or undefined when calling tasksAdminCertificateTypeCertificateTypeIdDelete.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.delete<any>( `${ this.configuration.basePath }/tasks/admin/certificate_type/${ encodeURIComponent( String( certificateTypeId ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param certificateTypeId Id of the certificate type
     * @param certificateType
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksAdminCertificateTypeCertificateTypeIdPatch( certificateTypeId: number, certificateType: CertificateType, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksAdminCertificateTypeCertificateTypeIdPatch( certificateTypeId: number, certificateType: CertificateType, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksAdminCertificateTypeCertificateTypeIdPatch( certificateTypeId: number, certificateType: CertificateType, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksAdminCertificateTypeCertificateTypeIdPatch( certificateTypeId: number, certificateType: CertificateType, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( certificateTypeId === null || certificateTypeId === undefined )
        {
            throw new Error( 'Required parameter certificateTypeId was null or undefined when calling tasksAdminCertificateTypeCertificateTypeIdPatch.' )
        }
        if ( certificateType === null || certificateType === undefined )
        {
            throw new Error( 'Required parameter certificateType was null or undefined when calling tasksAdminCertificateTypeCertificateTypeIdPatch.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.patch<any>( `${ this.configuration.basePath }/tasks/admin/certificate_type/${ encodeURIComponent( String( certificateTypeId ) ) }`,
            certificateType,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param certificateType
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksAdminCertificateTypePost( certificateType: CertificateType, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<CertificateType>;
    public tasksAdminCertificateTypePost( certificateType: CertificateType, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<CertificateType>>;
    public tasksAdminCertificateTypePost( certificateType: CertificateType, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<CertificateType>>;
    public tasksAdminCertificateTypePost( certificateType: CertificateType, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( certificateType === null || certificateType === undefined )
        {
            throw new Error( 'Required parameter certificateType was null or undefined when calling tasksAdminCertificateTypePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<CertificateType>( `${ this.configuration.basePath }/tasks/admin/certificate_type`,
            certificateType,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest Id of the contest
     * @param idUser Id of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksAdminContestIdContestUserIdUserVariantGeneratePost( idContest: number, idUser: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<VariantIdResponseTaskAdmin>;
    public tasksAdminContestIdContestUserIdUserVariantGeneratePost( idContest: number, idUser: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<VariantIdResponseTaskAdmin>>;
    public tasksAdminContestIdContestUserIdUserVariantGeneratePost( idContest: number, idUser: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<VariantIdResponseTaskAdmin>>;
    public tasksAdminContestIdContestUserIdUserVariantGeneratePost( idContest: number, idUser: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksAdminContestIdContestUserIdUserVariantGeneratePost.' )
        }
        if ( idUser === null || idUser === undefined )
        {
            throw new Error( 'Required parameter idUser was null or undefined when calling tasksAdminContestIdContestUserIdUserVariantGeneratePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<VariantIdResponseTaskAdmin>( `${ this.configuration.basePath }/tasks/admin/contest/${ encodeURIComponent( String( idContest ) ) }/user/${ encodeURIComponent( String( idUser ) ) }/variant/generate`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksAdminFontsGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<FontsResponseTasksAdmin>;
    public tasksAdminFontsGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<FontsResponseTasksAdmin>>;
    public tasksAdminFontsGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<FontsResponseTasksAdmin>>;
    public tasksAdminFontsGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<FontsResponseTasksAdmin>( `${ this.configuration.basePath }/tasks/admin/fonts`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param createOnlineLocationRequestTaskAdmin
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksAdminLocationCreateOnlinePost( createOnlineLocationRequestTaskAdmin: CreateOnlineLocationRequestTaskAdmin, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<LocationResponseTaskAdmin>;
    public tasksAdminLocationCreateOnlinePost( createOnlineLocationRequestTaskAdmin: CreateOnlineLocationRequestTaskAdmin, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<LocationResponseTaskAdmin>>;
    public tasksAdminLocationCreateOnlinePost( createOnlineLocationRequestTaskAdmin: CreateOnlineLocationRequestTaskAdmin, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<LocationResponseTaskAdmin>>;
    public tasksAdminLocationCreateOnlinePost( createOnlineLocationRequestTaskAdmin: CreateOnlineLocationRequestTaskAdmin, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( createOnlineLocationRequestTaskAdmin === null || createOnlineLocationRequestTaskAdmin === undefined )
        {
            throw new Error( 'Required parameter createOnlineLocationRequestTaskAdmin was null or undefined when calling tasksAdminLocationCreateOnlinePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<LocationResponseTaskAdmin>( `${ this.configuration.basePath }/tasks/admin/location/create_online`,
            createOnlineLocationRequestTaskAdmin,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param createOtherLocationRequestTaskAdmin
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksAdminLocationCreateOtherPost( createOtherLocationRequestTaskAdmin: CreateOtherLocationRequestTaskAdmin, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<LocationResponseTaskAdmin>;
    public tasksAdminLocationCreateOtherPost( createOtherLocationRequestTaskAdmin: CreateOtherLocationRequestTaskAdmin, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<LocationResponseTaskAdmin>>;
    public tasksAdminLocationCreateOtherPost( createOtherLocationRequestTaskAdmin: CreateOtherLocationRequestTaskAdmin, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<LocationResponseTaskAdmin>>;
    public tasksAdminLocationCreateOtherPost( createOtherLocationRequestTaskAdmin: CreateOtherLocationRequestTaskAdmin, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( createOtherLocationRequestTaskAdmin === null || createOtherLocationRequestTaskAdmin === undefined )
        {
            throw new Error( 'Required parameter createOtherLocationRequestTaskAdmin was null or undefined when calling tasksAdminLocationCreateOtherPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<LocationResponseTaskAdmin>( `${ this.configuration.basePath }/tasks/admin/location/create_other`,
            createOtherLocationRequestTaskAdmin,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param createRussiaLocationRequestTaskAdmin
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksAdminLocationCreateRussiaPost( createRussiaLocationRequestTaskAdmin: CreateRussiaLocationRequestTaskAdmin, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<LocationResponseTaskAdmin>;
    public tasksAdminLocationCreateRussiaPost( createRussiaLocationRequestTaskAdmin: CreateRussiaLocationRequestTaskAdmin, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<LocationResponseTaskAdmin>>;
    public tasksAdminLocationCreateRussiaPost( createRussiaLocationRequestTaskAdmin: CreateRussiaLocationRequestTaskAdmin, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<LocationResponseTaskAdmin>>;
    public tasksAdminLocationCreateRussiaPost( createRussiaLocationRequestTaskAdmin: CreateRussiaLocationRequestTaskAdmin, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( createRussiaLocationRequestTaskAdmin === null || createRussiaLocationRequestTaskAdmin === undefined )
        {
            throw new Error( 'Required parameter createRussiaLocationRequestTaskAdmin was null or undefined when calling tasksAdminLocationCreateRussiaPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<LocationResponseTaskAdmin>( `${ this.configuration.basePath }/tasks/admin/location/create_russia`,
            createRussiaLocationRequestTaskAdmin,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idLocation Id of the location
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksAdminLocationIdLocationRemovePost( idLocation: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksAdminLocationIdLocationRemovePost( idLocation: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksAdminLocationIdLocationRemovePost( idLocation: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksAdminLocationIdLocationRemovePost( idLocation: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idLocation === null || idLocation === undefined )
        {
            throw new Error( 'Required parameter idLocation was null or undefined when calling tasksAdminLocationIdLocationRemovePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/admin/location/${ encodeURIComponent( String( idLocation ) ) }/remove`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param createOlympiadTypeRequestTaskAdmin
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksAdminOlympiadTypeCreatePost( createOlympiadTypeRequestTaskAdmin: CreateOlympiadTypeRequestTaskAdmin, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<OlympiadTypeResponseTaskAdmin>;
    public tasksAdminOlympiadTypeCreatePost( createOlympiadTypeRequestTaskAdmin: CreateOlympiadTypeRequestTaskAdmin, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<OlympiadTypeResponseTaskAdmin>>;
    public tasksAdminOlympiadTypeCreatePost( createOlympiadTypeRequestTaskAdmin: CreateOlympiadTypeRequestTaskAdmin, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<OlympiadTypeResponseTaskAdmin>>;
    public tasksAdminOlympiadTypeCreatePost( createOlympiadTypeRequestTaskAdmin: CreateOlympiadTypeRequestTaskAdmin, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( createOlympiadTypeRequestTaskAdmin === null || createOlympiadTypeRequestTaskAdmin === undefined )
        {
            throw new Error( 'Required parameter createOlympiadTypeRequestTaskAdmin was null or undefined when calling tasksAdminOlympiadTypeCreatePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<OlympiadTypeResponseTaskAdmin>( `${ this.configuration.basePath }/tasks/admin/olympiad_type/create`,
            createOlympiadTypeRequestTaskAdmin,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idOlympiadType Id of the olympiad type
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksAdminOlympiadTypeIdOlympiadTypeRemovePost( idOlympiadType: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksAdminOlympiadTypeIdOlympiadTypeRemovePost( idOlympiadType: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksAdminOlympiadTypeIdOlympiadTypeRemovePost( idOlympiadType: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksAdminOlympiadTypeIdOlympiadTypeRemovePost( idOlympiadType: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idOlympiadType === null || idOlympiadType === undefined )
        {
            throw new Error( 'Required parameter idOlympiadType was null or undefined when calling tasksAdminOlympiadTypeIdOlympiadTypeRemovePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/admin/olympiad_type/${ encodeURIComponent( String( idOlympiadType ) ) }/remove`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param updateUserInContestRequestTaskControlUsers
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksControlUsersContestIdContestAddUserPost( idContest: number, updateUserInContestRequestTaskControlUsers: UpdateUserInContestRequestTaskControlUsers, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksControlUsersContestIdContestAddUserPost( idContest: number, updateUserInContestRequestTaskControlUsers: UpdateUserInContestRequestTaskControlUsers, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksControlUsersContestIdContestAddUserPost( idContest: number, updateUserInContestRequestTaskControlUsers: UpdateUserInContestRequestTaskControlUsers, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksControlUsersContestIdContestAddUserPost( idContest: number, updateUserInContestRequestTaskControlUsers: UpdateUserInContestRequestTaskControlUsers, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksControlUsersContestIdContestAddUserPost.' )
        }
        if ( updateUserInContestRequestTaskControlUsers === null || updateUserInContestRequestTaskControlUsers === undefined )
        {
            throw new Error( 'Required parameter updateUserInContestRequestTaskControlUsers was null or undefined when calling tasksControlUsersContestIdContestAddUserPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/control_users/contest/${ encodeURIComponent( String( idContest ) ) }/add_user`,
            updateUserInContestRequestTaskControlUsers,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param changeUsersLocationInContestRequestTaskControlUsers
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksControlUsersContestIdContestChangeLocationPost( idContest: number, changeUsersLocationInContestRequestTaskControlUsers: ChangeUsersLocationInContestRequestTaskControlUsers, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksControlUsersContestIdContestChangeLocationPost( idContest: number, changeUsersLocationInContestRequestTaskControlUsers: ChangeUsersLocationInContestRequestTaskControlUsers, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksControlUsersContestIdContestChangeLocationPost( idContest: number, changeUsersLocationInContestRequestTaskControlUsers: ChangeUsersLocationInContestRequestTaskControlUsers, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksControlUsersContestIdContestChangeLocationPost( idContest: number, changeUsersLocationInContestRequestTaskControlUsers: ChangeUsersLocationInContestRequestTaskControlUsers, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksControlUsersContestIdContestChangeLocationPost.' )
        }
        if ( changeUsersLocationInContestRequestTaskControlUsers === null || changeUsersLocationInContestRequestTaskControlUsers === undefined )
        {
            throw new Error( 'Required parameter changeUsersLocationInContestRequestTaskControlUsers was null or undefined when calling tasksControlUsersContestIdContestChangeLocationPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/control_users/contest/${ encodeURIComponent( String( idContest ) ) }/change_location`,
            changeUsersLocationInContestRequestTaskControlUsers,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param updateUserInContestRequestTaskControlUsers
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksControlUsersContestIdContestEditUsersPatch( idContest: number, updateUserInContestRequestTaskControlUsers: UpdateUserInContestRequestTaskControlUsers, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksControlUsersContestIdContestEditUsersPatch( idContest: number, updateUserInContestRequestTaskControlUsers: UpdateUserInContestRequestTaskControlUsers, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksControlUsersContestIdContestEditUsersPatch( idContest: number, updateUserInContestRequestTaskControlUsers: UpdateUserInContestRequestTaskControlUsers, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksControlUsersContestIdContestEditUsersPatch( idContest: number, updateUserInContestRequestTaskControlUsers: UpdateUserInContestRequestTaskControlUsers, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksControlUsersContestIdContestEditUsersPatch.' )
        }
        if ( updateUserInContestRequestTaskControlUsers === null || updateUserInContestRequestTaskControlUsers === undefined )
        {
            throw new Error( 'Required parameter updateUserInContestRequestTaskControlUsers was null or undefined when calling tasksControlUsersContestIdContestEditUsersPatch.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.patch<any>( `${ this.configuration.basePath }/tasks/control_users/contest/${ encodeURIComponent( String( idContest ) ) }/edit_users`,
            updateUserInContestRequestTaskControlUsers,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param updateUserInContestRequestTaskControlUsers
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksControlUsersContestIdContestRemoveUserPost( idContest: number, updateUserInContestRequestTaskControlUsers: UpdateUserInContestRequestTaskControlUsers, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksControlUsersContestIdContestRemoveUserPost( idContest: number, updateUserInContestRequestTaskControlUsers: UpdateUserInContestRequestTaskControlUsers, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksControlUsersContestIdContestRemoveUserPost( idContest: number, updateUserInContestRequestTaskControlUsers: UpdateUserInContestRequestTaskControlUsers, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksControlUsersContestIdContestRemoveUserPost( idContest: number, updateUserInContestRequestTaskControlUsers: UpdateUserInContestRequestTaskControlUsers, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksControlUsersContestIdContestRemoveUserPost.' )
        }
        if ( updateUserInContestRequestTaskControlUsers === null || updateUserInContestRequestTaskControlUsers === undefined )
        {
            throw new Error( 'Required parameter updateUserInContestRequestTaskControlUsers was null or undefined when calling tasksControlUsersContestIdContestRemoveUserPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/control_users/contest/${ encodeURIComponent( String( idContest ) ) }/remove_user`,
            updateUserInContestRequestTaskControlUsers,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksControlUsersContestIdContestUserAllGet( idContest: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<UsersResponseTaskControlUsers>;
    public tasksControlUsersContestIdContestUserAllGet( idContest: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<UsersResponseTaskControlUsers>>;
    public tasksControlUsersContestIdContestUserAllGet( idContest: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<UsersResponseTaskControlUsers>>;
    public tasksControlUsersContestIdContestUserAllGet( idContest: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksControlUsersContestIdContestUserAllGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<UsersResponseTaskControlUsers>( `${ this.configuration.basePath }/tasks/control_users/contest/${ encodeURIComponent( String( idContest ) ) }/user/all`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param idUser ID of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksControlUsersContestIdContestUserIdUserCertificateGet( idContest: number, idUser: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/pdf', context?: HttpContext } ): Observable<Blob>;
    public tasksControlUsersContestIdContestUserIdUserCertificateGet( idContest: number, idUser: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/pdf', context?: HttpContext } ): Observable<HttpResponse<Blob>>;
    public tasksControlUsersContestIdContestUserIdUserCertificateGet( idContest: number, idUser: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/pdf', context?: HttpContext } ): Observable<HttpEvent<Blob>>;
    public tasksControlUsersContestIdContestUserIdUserCertificateGet( idContest: number, idUser: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/pdf', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksControlUsersContestIdContestUserIdUserCertificateGet.' )
        }
        if ( idUser === null || idUser === undefined )
        {
            throw new Error( 'Required parameter idUser was null or undefined when calling tasksControlUsersContestIdContestUserIdUserCertificateGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/pdf'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        return this.httpClient.get( `${ this.configuration.basePath }/tasks/control_users/contest/${ encodeURIComponent( String( idContest ) ) }/user/${ encodeURIComponent( String( idUser ) ) }/certificate`,
            {
                context: localVarHttpContext,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param baseContest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorBaseOlympiadCreatePost( baseContest: BaseContest, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<BaseOlympiadIdResponseTaskCreator>;
    public tasksCreatorBaseOlympiadCreatePost( baseContest: BaseContest, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<BaseOlympiadIdResponseTaskCreator>>;
    public tasksCreatorBaseOlympiadCreatePost( baseContest: BaseContest, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<BaseOlympiadIdResponseTaskCreator>>;
    public tasksCreatorBaseOlympiadCreatePost( baseContest: BaseContest, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( baseContest === null || baseContest === undefined )
        {
            throw new Error( 'Required parameter baseContest was null or undefined when calling tasksCreatorBaseOlympiadCreatePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<BaseOlympiadIdResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/base_olympiad/create`,
            baseContest,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idBaseOlympiad ID of the base olympiad
     * @param createCompositeContestRequestTaskCreator
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorBaseOlympiadIdBaseOlympiadOlympiadCreateCompositePost( idBaseOlympiad: number, createCompositeContestRequestTaskCreator: CreateCompositeContestRequestTaskCreator, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<ContestIdResponseTaskCreator>;
    public tasksCreatorBaseOlympiadIdBaseOlympiadOlympiadCreateCompositePost( idBaseOlympiad: number, createCompositeContestRequestTaskCreator: CreateCompositeContestRequestTaskCreator, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<ContestIdResponseTaskCreator>>;
    public tasksCreatorBaseOlympiadIdBaseOlympiadOlympiadCreateCompositePost( idBaseOlympiad: number, createCompositeContestRequestTaskCreator: CreateCompositeContestRequestTaskCreator, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<ContestIdResponseTaskCreator>>;
    public tasksCreatorBaseOlympiadIdBaseOlympiadOlympiadCreateCompositePost( idBaseOlympiad: number, createCompositeContestRequestTaskCreator: CreateCompositeContestRequestTaskCreator, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idBaseOlympiad === null || idBaseOlympiad === undefined )
        {
            throw new Error( 'Required parameter idBaseOlympiad was null or undefined when calling tasksCreatorBaseOlympiadIdBaseOlympiadOlympiadCreateCompositePost.' )
        }
        if ( createCompositeContestRequestTaskCreator === null || createCompositeContestRequestTaskCreator === undefined )
        {
            throw new Error( 'Required parameter createCompositeContestRequestTaskCreator was null or undefined when calling tasksCreatorBaseOlympiadIdBaseOlympiadOlympiadCreateCompositePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<ContestIdResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/base_olympiad/${ encodeURIComponent( String( idBaseOlympiad ) ) }/olympiad/create_composite`,
            createCompositeContestRequestTaskCreator,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idBaseOlympiad ID of the base olympiad
     * @param createSimpleContestRequestTaskCreator
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorBaseOlympiadIdBaseOlympiadOlympiadCreateSimplePost( idBaseOlympiad: number, createSimpleContestRequestTaskCreator: CreateSimpleContestRequestTaskCreator, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<ContestIdResponseTaskCreator>;
    public tasksCreatorBaseOlympiadIdBaseOlympiadOlympiadCreateSimplePost( idBaseOlympiad: number, createSimpleContestRequestTaskCreator: CreateSimpleContestRequestTaskCreator, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<ContestIdResponseTaskCreator>>;
    public tasksCreatorBaseOlympiadIdBaseOlympiadOlympiadCreateSimplePost( idBaseOlympiad: number, createSimpleContestRequestTaskCreator: CreateSimpleContestRequestTaskCreator, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<ContestIdResponseTaskCreator>>;
    public tasksCreatorBaseOlympiadIdBaseOlympiadOlympiadCreateSimplePost( idBaseOlympiad: number, createSimpleContestRequestTaskCreator: CreateSimpleContestRequestTaskCreator, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idBaseOlympiad === null || idBaseOlympiad === undefined )
        {
            throw new Error( 'Required parameter idBaseOlympiad was null or undefined when calling tasksCreatorBaseOlympiadIdBaseOlympiadOlympiadCreateSimplePost.' )
        }
        if ( createSimpleContestRequestTaskCreator === null || createSimpleContestRequestTaskCreator === undefined )
        {
            throw new Error( 'Required parameter createSimpleContestRequestTaskCreator was null or undefined when calling tasksCreatorBaseOlympiadIdBaseOlympiadOlympiadCreateSimplePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<ContestIdResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/base_olympiad/${ encodeURIComponent( String( idBaseOlympiad ) ) }/olympiad/create_simple`,
            createSimpleContestRequestTaskCreator,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idBaseOlympiad ID of the base olympiad
     * @param taskPool
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorBaseOlympiadIdBaseOlympiadTaskPoolCreatePost( idBaseOlympiad: number, taskPool: TaskPool, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<TaskPoolIdResponseTaskCreator>;
    public tasksCreatorBaseOlympiadIdBaseOlympiadTaskPoolCreatePost( idBaseOlympiad: number, taskPool: TaskPool, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<TaskPoolIdResponseTaskCreator>>;
    public tasksCreatorBaseOlympiadIdBaseOlympiadTaskPoolCreatePost( idBaseOlympiad: number, taskPool: TaskPool, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<TaskPoolIdResponseTaskCreator>>;
    public tasksCreatorBaseOlympiadIdBaseOlympiadTaskPoolCreatePost( idBaseOlympiad: number, taskPool: TaskPool, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idBaseOlympiad === null || idBaseOlympiad === undefined )
        {
            throw new Error( 'Required parameter idBaseOlympiad was null or undefined when calling tasksCreatorBaseOlympiadIdBaseOlympiadTaskPoolCreatePost.' )
        }
        if ( taskPool === null || taskPool === undefined )
        {
            throw new Error( 'Required parameter taskPool was null or undefined when calling tasksCreatorBaseOlympiadIdBaseOlympiadTaskPoolCreatePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<TaskPoolIdResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/base_olympiad/${ encodeURIComponent( String( idBaseOlympiad ) ) }/task_pool/create`,
            taskPool,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idBaseOlympiad ID of the base olympiad
     * @param idTaskPool ID of the task pool
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorBaseOlympiadIdBaseOlympiadTaskPoolIdTaskPoolGet( idBaseOlympiad: number, idTaskPool: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<TaskPool>;
    public tasksCreatorBaseOlympiadIdBaseOlympiadTaskPoolIdTaskPoolGet( idBaseOlympiad: number, idTaskPool: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<TaskPool>>;
    public tasksCreatorBaseOlympiadIdBaseOlympiadTaskPoolIdTaskPoolGet( idBaseOlympiad: number, idTaskPool: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<TaskPool>>;
    public tasksCreatorBaseOlympiadIdBaseOlympiadTaskPoolIdTaskPoolGet( idBaseOlympiad: number, idTaskPool: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idBaseOlympiad === null || idBaseOlympiad === undefined )
        {
            throw new Error( 'Required parameter idBaseOlympiad was null or undefined when calling tasksCreatorBaseOlympiadIdBaseOlympiadTaskPoolIdTaskPoolGet.' )
        }
        if ( idTaskPool === null || idTaskPool === undefined )
        {
            throw new Error( 'Required parameter idTaskPool was null or undefined when calling tasksCreatorBaseOlympiadIdBaseOlympiadTaskPoolIdTaskPoolGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<TaskPool>( `${ this.configuration.basePath }/tasks/creator/base_olympiad/${ encodeURIComponent( String( idBaseOlympiad ) ) }/task_pool/${ encodeURIComponent( String( idTaskPool ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorContestContestIdRestrictionsGet( contestId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<ContestGroupRestrictionListAdmin>;
    public tasksCreatorContestContestIdRestrictionsGet( contestId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<ContestGroupRestrictionListAdmin>>;
    public tasksCreatorContestContestIdRestrictionsGet( contestId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<ContestGroupRestrictionListAdmin>>;
    public tasksCreatorContestContestIdRestrictionsGet( contestId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling tasksCreatorContestContestIdRestrictionsGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<ContestGroupRestrictionListAdmin>( `${ this.configuration.basePath }/tasks/creator/contest/${ encodeURIComponent( String( contestId ) ) }/restrictions`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param contestGroupRestrictionListAdmin
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorContestContestIdRestrictionsPut( contestId: number, contestGroupRestrictionListAdmin: ContestGroupRestrictionListAdmin, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksCreatorContestContestIdRestrictionsPut( contestId: number, contestGroupRestrictionListAdmin: ContestGroupRestrictionListAdmin, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksCreatorContestContestIdRestrictionsPut( contestId: number, contestGroupRestrictionListAdmin: ContestGroupRestrictionListAdmin, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksCreatorContestContestIdRestrictionsPut( contestId: number, contestGroupRestrictionListAdmin: ContestGroupRestrictionListAdmin, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling tasksCreatorContestContestIdRestrictionsPut.' )
        }
        if ( contestGroupRestrictionListAdmin === null || contestGroupRestrictionListAdmin === undefined )
        {
            throw new Error( 'Required parameter contestGroupRestrictionListAdmin was null or undefined when calling tasksCreatorContestContestIdRestrictionsPut.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.put<any>( `${ this.configuration.basePath }/tasks/creator/contest/${ encodeURIComponent( String( contestId ) ) }/restrictions`,
            contestGroupRestrictionListAdmin,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorContestIdContestContestTaskAllGet( idContest: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllContestTaskResponseTaskCreator>;
    public tasksCreatorContestIdContestContestTaskAllGet( idContest: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllContestTaskResponseTaskCreator>>;
    public tasksCreatorContestIdContestContestTaskAllGet( idContest: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllContestTaskResponseTaskCreator>>;
    public tasksCreatorContestIdContestContestTaskAllGet( idContest: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksCreatorContestIdContestContestTaskAllGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<AllContestTaskResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/contest/${ encodeURIComponent( String( idContest ) ) }/contest_task/all`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param contestTask
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorContestIdContestContestTaskCreatePost( idContest: number, contestTask: ContestTask, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<ContestTaskResponseTaskCreator>;
    public tasksCreatorContestIdContestContestTaskCreatePost( idContest: number, contestTask: ContestTask, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<ContestTaskResponseTaskCreator>>;
    public tasksCreatorContestIdContestContestTaskCreatePost( idContest: number, contestTask: ContestTask, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<ContestTaskResponseTaskCreator>>;
    public tasksCreatorContestIdContestContestTaskCreatePost( idContest: number, contestTask: ContestTask, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksCreatorContestIdContestContestTaskCreatePost.' )
        }
        if ( contestTask === null || contestTask === undefined )
        {
            throw new Error( 'Required parameter contestTask was null or undefined when calling tasksCreatorContestIdContestContestTaskCreatePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<ContestTaskResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/contest/${ encodeURIComponent( String( idContest ) ) }/contest_task/create`,
            contestTask,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param idContestTask ID of the contest task
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorContestIdContestContestTaskIdContestTaskGet( idContest: number, idContestTask: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<ContestTask>;
    public tasksCreatorContestIdContestContestTaskIdContestTaskGet( idContest: number, idContestTask: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<ContestTask>>;
    public tasksCreatorContestIdContestContestTaskIdContestTaskGet( idContest: number, idContestTask: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<ContestTask>>;
    public tasksCreatorContestIdContestContestTaskIdContestTaskGet( idContest: number, idContestTask: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksCreatorContestIdContestContestTaskIdContestTaskGet.' )
        }
        if ( idContestTask === null || idContestTask === undefined )
        {
            throw new Error( 'Required parameter idContestTask was null or undefined when calling tasksCreatorContestIdContestContestTaskIdContestTaskGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<ContestTask>( `${ this.configuration.basePath }/tasks/creator/contest/${ encodeURIComponent( String( idContest ) ) }/contest_task/${ encodeURIComponent( String( idContestTask ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorContestIdContestVariantAllGet( idContest: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllVariantsResponseTaskCreator>;
    public tasksCreatorContestIdContestVariantAllGet( idContest: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllVariantsResponseTaskCreator>>;
    public tasksCreatorContestIdContestVariantAllGet( idContest: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllVariantsResponseTaskCreator>>;
    public tasksCreatorContestIdContestVariantAllGet( idContest: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksCreatorContestIdContestVariantAllGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<AllVariantsResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/contest/${ encodeURIComponent( String( idContest ) ) }/variant/all`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param variantNum Num of the variant
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorContestIdContestVariantVariantNumGet( idContest: number, variantNum: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<VariantResponseTaskCreator>;
    public tasksCreatorContestIdContestVariantVariantNumGet( idContest: number, variantNum: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<VariantResponseTaskCreator>>;
    public tasksCreatorContestIdContestVariantVariantNumGet( idContest: number, variantNum: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<VariantResponseTaskCreator>>;
    public tasksCreatorContestIdContestVariantVariantNumGet( idContest: number, variantNum: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksCreatorContestIdContestVariantVariantNumGet.' )
        }
        if ( variantNum === null || variantNum === undefined )
        {
            throw new Error( 'Required parameter variantNum was null or undefined when calling tasksCreatorContestIdContestVariantVariantNumGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<VariantResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( variantNum ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idOlympiad ID of the olympiad
     * @param createStageRequestTaskCreator
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorOlympiadIdOlympiadStageCreatePost( idOlympiad: number, createStageRequestTaskCreator: CreateStageRequestTaskCreator, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<StageIdResponseTaskCreator>;
    public tasksCreatorOlympiadIdOlympiadStageCreatePost( idOlympiad: number, createStageRequestTaskCreator: CreateStageRequestTaskCreator, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<StageIdResponseTaskCreator>>;
    public tasksCreatorOlympiadIdOlympiadStageCreatePost( idOlympiad: number, createStageRequestTaskCreator: CreateStageRequestTaskCreator, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<StageIdResponseTaskCreator>>;
    public tasksCreatorOlympiadIdOlympiadStageCreatePost( idOlympiad: number, createStageRequestTaskCreator: CreateStageRequestTaskCreator, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksCreatorOlympiadIdOlympiadStageCreatePost.' )
        }
        if ( createStageRequestTaskCreator === null || createStageRequestTaskCreator === undefined )
        {
            throw new Error( 'Required parameter createStageRequestTaskCreator was null or undefined when calling tasksCreatorOlympiadIdOlympiadStageCreatePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<StageIdResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/create`,
            createStageRequestTaskCreator,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idOlympiad ID of the olympiad
     * @param idStage ID of the stage
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorOlympiadIdOlympiadStageIdStageContestAllGet( idOlympiad: number, idStage: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllOlympiadsResponseTaskCreator>;
    public tasksCreatorOlympiadIdOlympiadStageIdStageContestAllGet( idOlympiad: number, idStage: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllOlympiadsResponseTaskCreator>>;
    public tasksCreatorOlympiadIdOlympiadStageIdStageContestAllGet( idOlympiad: number, idStage: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllOlympiadsResponseTaskCreator>>;
    public tasksCreatorOlympiadIdOlympiadStageIdStageContestAllGet( idOlympiad: number, idStage: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksCreatorOlympiadIdOlympiadStageIdStageContestAllGet.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling tasksCreatorOlympiadIdOlympiadStageIdStageContestAllGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<AllOlympiadsResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/all`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param baseContestId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorTaskPoolAllGet( baseContestId?: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllTaskPoolsResponseTaskCreator>;
    public tasksCreatorTaskPoolAllGet( baseContestId?: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllTaskPoolsResponseTaskCreator>>;
    public tasksCreatorTaskPoolAllGet( baseContestId?: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllTaskPoolsResponseTaskCreator>>;
    public tasksCreatorTaskPoolAllGet( baseContestId?: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {

        let localVarQueryParameters = new HttpParams( { encoder: this.encoder } )
        if ( baseContestId !== undefined && baseContestId !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> baseContestId, 'base_contest_id' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<AllTaskPoolsResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/task_pool/all`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idTaskPool ID of the task pool
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorTaskPoolIdTaskPoolTaskAllGet( idTaskPool: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllTasksResponseTaskCreator>;
    public tasksCreatorTaskPoolIdTaskPoolTaskAllGet( idTaskPool: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllTasksResponseTaskCreator>>;
    public tasksCreatorTaskPoolIdTaskPoolTaskAllGet( idTaskPool: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllTasksResponseTaskCreator>>;
    public tasksCreatorTaskPoolIdTaskPoolTaskAllGet( idTaskPool: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idTaskPool === null || idTaskPool === undefined )
        {
            throw new Error( 'Required parameter idTaskPool was null or undefined when calling tasksCreatorTaskPoolIdTaskPoolTaskAllGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<AllTasksResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/task_pool/${ encodeURIComponent( String( idTaskPool ) ) }/task/all`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idTaskPool ID of the task pool
     * @param multipleChoiceTask
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorTaskPoolIdTaskPoolTaskCreateMultiplePost( idTaskPool: number, multipleChoiceTask: MultipleChoiceTask, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<TaskIdResponseTaskCreator>;
    public tasksCreatorTaskPoolIdTaskPoolTaskCreateMultiplePost( idTaskPool: number, multipleChoiceTask: MultipleChoiceTask, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<TaskIdResponseTaskCreator>>;
    public tasksCreatorTaskPoolIdTaskPoolTaskCreateMultiplePost( idTaskPool: number, multipleChoiceTask: MultipleChoiceTask, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<TaskIdResponseTaskCreator>>;
    public tasksCreatorTaskPoolIdTaskPoolTaskCreateMultiplePost( idTaskPool: number, multipleChoiceTask: MultipleChoiceTask, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idTaskPool === null || idTaskPool === undefined )
        {
            throw new Error( 'Required parameter idTaskPool was null or undefined when calling tasksCreatorTaskPoolIdTaskPoolTaskCreateMultiplePost.' )
        }
        if ( multipleChoiceTask === null || multipleChoiceTask === undefined )
        {
            throw new Error( 'Required parameter multipleChoiceTask was null or undefined when calling tasksCreatorTaskPoolIdTaskPoolTaskCreateMultiplePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<TaskIdResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/task_pool/${ encodeURIComponent( String( idTaskPool ) ) }/task/create_multiple`,
            multipleChoiceTask,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idTaskPool ID of the task pool
     * @param plainTask
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorTaskPoolIdTaskPoolTaskCreatePlainPost( idTaskPool: number, plainTask: PlainTask, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<TaskIdResponseTaskCreator>;
    public tasksCreatorTaskPoolIdTaskPoolTaskCreatePlainPost( idTaskPool: number, plainTask: PlainTask, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<TaskIdResponseTaskCreator>>;
    public tasksCreatorTaskPoolIdTaskPoolTaskCreatePlainPost( idTaskPool: number, plainTask: PlainTask, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<TaskIdResponseTaskCreator>>;
    public tasksCreatorTaskPoolIdTaskPoolTaskCreatePlainPost( idTaskPool: number, plainTask: PlainTask, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idTaskPool === null || idTaskPool === undefined )
        {
            throw new Error( 'Required parameter idTaskPool was null or undefined when calling tasksCreatorTaskPoolIdTaskPoolTaskCreatePlainPost.' )
        }
        if ( plainTask === null || plainTask === undefined )
        {
            throw new Error( 'Required parameter plainTask was null or undefined when calling tasksCreatorTaskPoolIdTaskPoolTaskCreatePlainPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<TaskIdResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/task_pool/${ encodeURIComponent( String( idTaskPool ) ) }/task/create_plain`,
            plainTask,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idTaskPool ID of the task pool
     * @param rangeTask
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorTaskPoolIdTaskPoolTaskCreateRangePost( idTaskPool: number, rangeTask: RangeTask, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<TaskIdResponseTaskCreator>;
    public tasksCreatorTaskPoolIdTaskPoolTaskCreateRangePost( idTaskPool: number, rangeTask: RangeTask, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<TaskIdResponseTaskCreator>>;
    public tasksCreatorTaskPoolIdTaskPoolTaskCreateRangePost( idTaskPool: number, rangeTask: RangeTask, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<TaskIdResponseTaskCreator>>;
    public tasksCreatorTaskPoolIdTaskPoolTaskCreateRangePost( idTaskPool: number, rangeTask: RangeTask, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idTaskPool === null || idTaskPool === undefined )
        {
            throw new Error( 'Required parameter idTaskPool was null or undefined when calling tasksCreatorTaskPoolIdTaskPoolTaskCreateRangePost.' )
        }
        if ( rangeTask === null || rangeTask === undefined )
        {
            throw new Error( 'Required parameter rangeTask was null or undefined when calling tasksCreatorTaskPoolIdTaskPoolTaskCreateRangePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<TaskIdResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/task_pool/${ encodeURIComponent( String( idTaskPool ) ) }/task/create_range`,
            rangeTask,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idTaskPool ID of the task pool
     * @param idTask ID of the task
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorTaskPoolIdTaskPoolTaskIdTaskGet( idTaskPool: number, idTask: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<TaskResponseTaskCreator>;
    public tasksCreatorTaskPoolIdTaskPoolTaskIdTaskGet( idTaskPool: number, idTask: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<TaskResponseTaskCreator>>;
    public tasksCreatorTaskPoolIdTaskPoolTaskIdTaskGet( idTaskPool: number, idTask: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<TaskResponseTaskCreator>>;
    public tasksCreatorTaskPoolIdTaskPoolTaskIdTaskGet( idTaskPool: number, idTask: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idTaskPool === null || idTaskPool === undefined )
        {
            throw new Error( 'Required parameter idTaskPool was null or undefined when calling tasksCreatorTaskPoolIdTaskPoolTaskIdTaskGet.' )
        }
        if ( idTask === null || idTask === undefined )
        {
            throw new Error( 'Required parameter idTask was null or undefined when calling tasksCreatorTaskPoolIdTaskPoolTaskIdTaskGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<TaskResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/task_pool/${ encodeURIComponent( String( idTaskPool ) ) }/task/${ encodeURIComponent( String( idTask ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idTaskPool ID of the task pool
     * @param idTask ID of the task
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorTaskPoolIdTaskPoolTaskIdTaskImageGet( idTaskPool: number, idTask: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'image/jpeg', context?: HttpContext } ): Observable<Blob>;
    public tasksCreatorTaskPoolIdTaskPoolTaskIdTaskImageGet( idTaskPool: number, idTask: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'image/jpeg', context?: HttpContext } ): Observable<HttpResponse<Blob>>;
    public tasksCreatorTaskPoolIdTaskPoolTaskIdTaskImageGet( idTaskPool: number, idTask: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'image/jpeg', context?: HttpContext } ): Observable<HttpEvent<Blob>>;
    public tasksCreatorTaskPoolIdTaskPoolTaskIdTaskImageGet( idTaskPool: number, idTask: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'image/jpeg', context?: HttpContext } ): Observable<any>
    {
        if ( idTaskPool === null || idTaskPool === undefined )
        {
            throw new Error( 'Required parameter idTaskPool was null or undefined when calling tasksCreatorTaskPoolIdTaskPoolTaskIdTaskImageGet.' )
        }
        if ( idTask === null || idTask === undefined )
        {
            throw new Error( 'Required parameter idTask was null or undefined when calling tasksCreatorTaskPoolIdTaskPoolTaskIdTaskImageGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'image/jpeg'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        return this.httpClient.get( `${ this.configuration.basePath }/tasks/creator/task_pool/${ encodeURIComponent( String( idTaskPool ) ) }/task/${ encodeURIComponent( String( idTask ) ) }/image`,
            {
                context: localVarHttpContext,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idBaseOlympiad ID of the contest
     * @param updateTargetClassesOfContestRequestTaskEditor
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorBaseOlympiadIdBaseOlympiadAddTargetClassesPost( idBaseOlympiad: number, updateTargetClassesOfContestRequestTaskEditor: UpdateTargetClassesOfContestRequestTaskEditor, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorBaseOlympiadIdBaseOlympiadAddTargetClassesPost( idBaseOlympiad: number, updateTargetClassesOfContestRequestTaskEditor: UpdateTargetClassesOfContestRequestTaskEditor, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadAddTargetClassesPost( idBaseOlympiad: number, updateTargetClassesOfContestRequestTaskEditor: UpdateTargetClassesOfContestRequestTaskEditor, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadAddTargetClassesPost( idBaseOlympiad: number, updateTargetClassesOfContestRequestTaskEditor: UpdateTargetClassesOfContestRequestTaskEditor, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idBaseOlympiad === null || idBaseOlympiad === undefined )
        {
            throw new Error( 'Required parameter idBaseOlympiad was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadAddTargetClassesPost.' )
        }
        if ( updateTargetClassesOfContestRequestTaskEditor === null || updateTargetClassesOfContestRequestTaskEditor === undefined )
        {
            throw new Error( 'Required parameter updateTargetClassesOfContestRequestTaskEditor was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadAddTargetClassesPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/editor/base_olympiad/${ encodeURIComponent( String( idBaseOlympiad ) ) }/add_target_classes`,
            updateTargetClassesOfContestRequestTaskEditor,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idBaseOlympiad ID of the base olympiad
     * @param idOlympiad ID of the olympiad
     * @param updateContestRequestTaskEditor
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadPatch( idBaseOlympiad: number, idOlympiad: number, updateContestRequestTaskEditor: UpdateContestRequestTaskEditor, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<ContestResponseTaskCreator>;
    public tasksEditorBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadPatch( idBaseOlympiad: number, idOlympiad: number, updateContestRequestTaskEditor: UpdateContestRequestTaskEditor, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<ContestResponseTaskCreator>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadPatch( idBaseOlympiad: number, idOlympiad: number, updateContestRequestTaskEditor: UpdateContestRequestTaskEditor, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<ContestResponseTaskCreator>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadPatch( idBaseOlympiad: number, idOlympiad: number, updateContestRequestTaskEditor: UpdateContestRequestTaskEditor, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idBaseOlympiad === null || idBaseOlympiad === undefined )
        {
            throw new Error( 'Required parameter idBaseOlympiad was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadPatch.' )
        }
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadPatch.' )
        }
        if ( updateContestRequestTaskEditor === null || updateContestRequestTaskEditor === undefined )
        {
            throw new Error( 'Required parameter updateContestRequestTaskEditor was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadPatch.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.patch<ContestResponseTaskCreator>( `${ this.configuration.basePath }/tasks/editor/base_olympiad/${ encodeURIComponent( String( idBaseOlympiad ) ) }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }`,
            updateContestRequestTaskEditor,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idBaseOlympiad ID of the base olympiad
     * @param idOlympiad ID of the olympiad
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadRemovePost( idBaseOlympiad: number, idOlympiad: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadRemovePost( idBaseOlympiad: number, idOlympiad: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadRemovePost( idBaseOlympiad: number, idOlympiad: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadRemovePost( idBaseOlympiad: number, idOlympiad: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idBaseOlympiad === null || idBaseOlympiad === undefined )
        {
            throw new Error( 'Required parameter idBaseOlympiad was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadRemovePost.' )
        }
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadRemovePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/editor/base_olympiad/${ encodeURIComponent( String( idBaseOlympiad ) ) }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/remove`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idBaseOlympiad ID of the base olympiad
     * @param updateBaseOlympiadRequestTaskEditor
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorBaseOlympiadIdBaseOlympiadPatch( idBaseOlympiad: number, updateBaseOlympiadRequestTaskEditor: UpdateBaseOlympiadRequestTaskEditor, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<BaseOlympiadResponseTaskCreator>;
    public tasksEditorBaseOlympiadIdBaseOlympiadPatch( idBaseOlympiad: number, updateBaseOlympiadRequestTaskEditor: UpdateBaseOlympiadRequestTaskEditor, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<BaseOlympiadResponseTaskCreator>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadPatch( idBaseOlympiad: number, updateBaseOlympiadRequestTaskEditor: UpdateBaseOlympiadRequestTaskEditor, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<BaseOlympiadResponseTaskCreator>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadPatch( idBaseOlympiad: number, updateBaseOlympiadRequestTaskEditor: UpdateBaseOlympiadRequestTaskEditor, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idBaseOlympiad === null || idBaseOlympiad === undefined )
        {
            throw new Error( 'Required parameter idBaseOlympiad was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadPatch.' )
        }
        if ( updateBaseOlympiadRequestTaskEditor === null || updateBaseOlympiadRequestTaskEditor === undefined )
        {
            throw new Error( 'Required parameter updateBaseOlympiadRequestTaskEditor was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadPatch.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.patch<BaseOlympiadResponseTaskCreator>( `${ this.configuration.basePath }/tasks/editor/base_olympiad/${ encodeURIComponent( String( idBaseOlympiad ) ) }`,
            updateBaseOlympiadRequestTaskEditor,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idBaseOlympiad ID of the base olympiad
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorBaseOlympiadIdBaseOlympiadRemovePost( idBaseOlympiad: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorBaseOlympiadIdBaseOlympiadRemovePost( idBaseOlympiad: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadRemovePost( idBaseOlympiad: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadRemovePost( idBaseOlympiad: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idBaseOlympiad === null || idBaseOlympiad === undefined )
        {
            throw new Error( 'Required parameter idBaseOlympiad was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadRemovePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/editor/base_olympiad/${ encodeURIComponent( String( idBaseOlympiad ) ) }/remove`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idBaseOlympiad ID of the target class
     * @param updateTargetClassesOfContestRequestTaskEditor
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorBaseOlympiadIdBaseOlympiadRemoveTargetClassesPost( idBaseOlympiad: number, updateTargetClassesOfContestRequestTaskEditor: UpdateTargetClassesOfContestRequestTaskEditor, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorBaseOlympiadIdBaseOlympiadRemoveTargetClassesPost( idBaseOlympiad: number, updateTargetClassesOfContestRequestTaskEditor: UpdateTargetClassesOfContestRequestTaskEditor, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadRemoveTargetClassesPost( idBaseOlympiad: number, updateTargetClassesOfContestRequestTaskEditor: UpdateTargetClassesOfContestRequestTaskEditor, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadRemoveTargetClassesPost( idBaseOlympiad: number, updateTargetClassesOfContestRequestTaskEditor: UpdateTargetClassesOfContestRequestTaskEditor, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idBaseOlympiad === null || idBaseOlympiad === undefined )
        {
            throw new Error( 'Required parameter idBaseOlympiad was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadRemoveTargetClassesPost.' )
        }
        if ( updateTargetClassesOfContestRequestTaskEditor === null || updateTargetClassesOfContestRequestTaskEditor === undefined )
        {
            throw new Error( 'Required parameter updateTargetClassesOfContestRequestTaskEditor was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadRemoveTargetClassesPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/editor/base_olympiad/${ encodeURIComponent( String( idBaseOlympiad ) ) }/remove_target_classes`,
            updateTargetClassesOfContestRequestTaskEditor,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idBaseOlympiad ID of the base olympiad
     * @param idTaskPool ID of the task pool
     * @param taskPool
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorBaseOlympiadIdBaseOlympiadTaskPoolIdTaskPoolPatch( idBaseOlympiad: number, idTaskPool: number, taskPool: TaskPool, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorBaseOlympiadIdBaseOlympiadTaskPoolIdTaskPoolPatch( idBaseOlympiad: number, idTaskPool: number, taskPool: TaskPool, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadTaskPoolIdTaskPoolPatch( idBaseOlympiad: number, idTaskPool: number, taskPool: TaskPool, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadTaskPoolIdTaskPoolPatch( idBaseOlympiad: number, idTaskPool: number, taskPool: TaskPool, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idBaseOlympiad === null || idBaseOlympiad === undefined )
        {
            throw new Error( 'Required parameter idBaseOlympiad was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadTaskPoolIdTaskPoolPatch.' )
        }
        if ( idTaskPool === null || idTaskPool === undefined )
        {
            throw new Error( 'Required parameter idTaskPool was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadTaskPoolIdTaskPoolPatch.' )
        }
        if ( taskPool === null || taskPool === undefined )
        {
            throw new Error( 'Required parameter taskPool was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadTaskPoolIdTaskPoolPatch.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.patch<any>( `${ this.configuration.basePath }/tasks/editor/base_olympiad/${ encodeURIComponent( String( idBaseOlympiad ) ) }/task_pool/${ encodeURIComponent( String( idTaskPool ) ) }`,
            taskPool,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idBaseOlympiad ID of the base olympiad
     * @param idTaskPool ID of the task pool
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorBaseOlympiadIdBaseOlympiadTaskPoolIdTaskPoolRemovePost( idBaseOlympiad: number, idTaskPool: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorBaseOlympiadIdBaseOlympiadTaskPoolIdTaskPoolRemovePost( idBaseOlympiad: number, idTaskPool: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadTaskPoolIdTaskPoolRemovePost( idBaseOlympiad: number, idTaskPool: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadTaskPoolIdTaskPoolRemovePost( idBaseOlympiad: number, idTaskPool: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idBaseOlympiad === null || idBaseOlympiad === undefined )
        {
            throw new Error( 'Required parameter idBaseOlympiad was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadTaskPoolIdTaskPoolRemovePost.' )
        }
        if ( idTaskPool === null || idTaskPool === undefined )
        {
            throw new Error( 'Required parameter idTaskPool was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadTaskPoolIdTaskPoolRemovePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/editor/base_olympiad/${ encodeURIComponent( String( idBaseOlympiad ) ) }/task_pool/${ encodeURIComponent( String( idTaskPool ) ) }/remove`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param certificateId ID of the certificate
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorCertificateCertificateIdGet( certificateId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<Certificate>;
    public tasksEditorCertificateCertificateIdGet( certificateId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<Certificate>>;
    public tasksEditorCertificateCertificateIdGet( certificateId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<Certificate>>;
    public tasksEditorCertificateCertificateIdGet( certificateId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( certificateId === null || certificateId === undefined )
        {
            throw new Error( 'Required parameter certificateId was null or undefined when calling tasksEditorCertificateCertificateIdGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<Certificate>( `${ this.configuration.basePath }/tasks/editor/certificate/${ encodeURIComponent( String( certificateId ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param certificateId ID of the certificate
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorCertificateCertificateIdImageGet( certificateId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'image/jpeg' | 'image/png', context?: HttpContext } ): Observable<Blob>;
    public tasksEditorCertificateCertificateIdImageGet( certificateId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'image/jpeg' | 'image/png', context?: HttpContext } ): Observable<HttpResponse<Blob>>;
    public tasksEditorCertificateCertificateIdImageGet( certificateId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'image/jpeg' | 'image/png', context?: HttpContext } ): Observable<HttpEvent<Blob>>;
    public tasksEditorCertificateCertificateIdImageGet( certificateId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'image/jpeg' | 'image/png', context?: HttpContext } ): Observable<any>
    {
        if ( certificateId === null || certificateId === undefined )
        {
            throw new Error( 'Required parameter certificateId was null or undefined when calling tasksEditorCertificateCertificateIdImageGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'image/jpeg',
                'image/png'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        return this.httpClient.get( `${ this.configuration.basePath }/tasks/editor/certificate/${ encodeURIComponent( String( certificateId ) ) }/image`,
            {
                context: localVarHttpContext,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param certificateTypeId ID of the certificate type
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorCertificateTypeCertificateTypeIdGet( certificateTypeId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<CertificateType>;
    public tasksEditorCertificateTypeCertificateTypeIdGet( certificateTypeId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<CertificateType>>;
    public tasksEditorCertificateTypeCertificateTypeIdGet( certificateTypeId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<CertificateType>>;
    public tasksEditorCertificateTypeCertificateTypeIdGet( certificateTypeId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( certificateTypeId === null || certificateTypeId === undefined )
        {
            throw new Error( 'Required parameter certificateTypeId was null or undefined when calling tasksEditorCertificateTypeCertificateTypeIdGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<CertificateType>( `${ this.configuration.basePath }/tasks/editor/certificate_type/${ encodeURIComponent( String( certificateTypeId ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorCertificateTypeGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<CertificateGetResponseTaskEditor>;
    public tasksEditorCertificateTypeGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<CertificateGetResponseTaskEditor>>;
    public tasksEditorCertificateTypeGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<CertificateGetResponseTaskEditor>>;
    public tasksEditorCertificateTypeGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<CertificateGetResponseTaskEditor>( `${ this.configuration.basePath }/tasks/editor/certificate_type`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param updateLocationOfContestRequestTaskEditor
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorContestIdContestAddLocationPost( idContest: number, updateLocationOfContestRequestTaskEditor: UpdateLocationOfContestRequestTaskEditor, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorContestIdContestAddLocationPost( idContest: number, updateLocationOfContestRequestTaskEditor: UpdateLocationOfContestRequestTaskEditor, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorContestIdContestAddLocationPost( idContest: number, updateLocationOfContestRequestTaskEditor: UpdateLocationOfContestRequestTaskEditor, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorContestIdContestAddLocationPost( idContest: number, updateLocationOfContestRequestTaskEditor: UpdateLocationOfContestRequestTaskEditor, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksEditorContestIdContestAddLocationPost.' )
        }
        if ( updateLocationOfContestRequestTaskEditor === null || updateLocationOfContestRequestTaskEditor === undefined )
        {
            throw new Error( 'Required parameter updateLocationOfContestRequestTaskEditor was null or undefined when calling tasksEditorContestIdContestAddLocationPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/editor/contest/${ encodeURIComponent( String( idContest ) ) }/add_location`,
            updateLocationOfContestRequestTaskEditor,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param idContestTask ID of the contest task
     * @param contestTask
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorContestIdContestContestTaskIdContestTaskPatch( idContest: number, idContestTask: number, contestTask: ContestTask, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorContestIdContestContestTaskIdContestTaskPatch( idContest: number, idContestTask: number, contestTask: ContestTask, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorContestIdContestContestTaskIdContestTaskPatch( idContest: number, idContestTask: number, contestTask: ContestTask, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorContestIdContestContestTaskIdContestTaskPatch( idContest: number, idContestTask: number, contestTask: ContestTask, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksEditorContestIdContestContestTaskIdContestTaskPatch.' )
        }
        if ( idContestTask === null || idContestTask === undefined )
        {
            throw new Error( 'Required parameter idContestTask was null or undefined when calling tasksEditorContestIdContestContestTaskIdContestTaskPatch.' )
        }
        if ( contestTask === null || contestTask === undefined )
        {
            throw new Error( 'Required parameter contestTask was null or undefined when calling tasksEditorContestIdContestContestTaskIdContestTaskPatch.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.patch<any>( `${ this.configuration.basePath }/tasks/editor/contest/${ encodeURIComponent( String( idContest ) ) }/contest_task/${ encodeURIComponent( String( idContestTask ) ) }`,
            contestTask,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the base olympiad
     * @param idContestTask ID of the contest task
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorContestIdContestContestTaskIdContestTaskRemovePost( idContest: number, idContestTask: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorContestIdContestContestTaskIdContestTaskRemovePost( idContest: number, idContestTask: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorContestIdContestContestTaskIdContestTaskRemovePost( idContest: number, idContestTask: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorContestIdContestContestTaskIdContestTaskRemovePost( idContest: number, idContestTask: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksEditorContestIdContestContestTaskIdContestTaskRemovePost.' )
        }
        if ( idContestTask === null || idContestTask === undefined )
        {
            throw new Error( 'Required parameter idContestTask was null or undefined when calling tasksEditorContestIdContestContestTaskIdContestTaskRemovePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/editor/contest/${ encodeURIComponent( String( idContest ) ) }/contest_task/${ encodeURIComponent( String( idContestTask ) ) }/remove`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param updateLocationOfContestRequestTaskEditor
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorContestIdContestRemoveLocationPost( idContest: number, updateLocationOfContestRequestTaskEditor: UpdateLocationOfContestRequestTaskEditor, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorContestIdContestRemoveLocationPost( idContest: number, updateLocationOfContestRequestTaskEditor: UpdateLocationOfContestRequestTaskEditor, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorContestIdContestRemoveLocationPost( idContest: number, updateLocationOfContestRequestTaskEditor: UpdateLocationOfContestRequestTaskEditor, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorContestIdContestRemoveLocationPost( idContest: number, updateLocationOfContestRequestTaskEditor: UpdateLocationOfContestRequestTaskEditor, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksEditorContestIdContestRemoveLocationPost.' )
        }
        if ( updateLocationOfContestRequestTaskEditor === null || updateLocationOfContestRequestTaskEditor === undefined )
        {
            throw new Error( 'Required parameter updateLocationOfContestRequestTaskEditor was null or undefined when calling tasksEditorContestIdContestRemoveLocationPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/editor/contest/${ encodeURIComponent( String( idContest ) ) }/remove_location`,
            updateLocationOfContestRequestTaskEditor,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idOlympiad ID of the olympiad
     * @param idStage ID of the stage
     * @param idContest ID of the contest
     * @param updatePreviousContestRequestTaskEditor
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestAddPreviousPatch( idOlympiad: number, idStage: number, idContest: number, updatePreviousContestRequestTaskEditor: UpdatePreviousContestRequestTaskEditor, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestAddPreviousPatch( idOlympiad: number, idStage: number, idContest: number, updatePreviousContestRequestTaskEditor: UpdatePreviousContestRequestTaskEditor, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestAddPreviousPatch( idOlympiad: number, idStage: number, idContest: number, updatePreviousContestRequestTaskEditor: UpdatePreviousContestRequestTaskEditor, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestAddPreviousPatch( idOlympiad: number, idStage: number, idContest: number, updatePreviousContestRequestTaskEditor: UpdatePreviousContestRequestTaskEditor, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestAddPreviousPatch.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestAddPreviousPatch.' )
        }
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestAddPreviousPatch.' )
        }
        if ( updatePreviousContestRequestTaskEditor === null || updatePreviousContestRequestTaskEditor === undefined )
        {
            throw new Error( 'Required parameter updatePreviousContestRequestTaskEditor was null or undefined when calling tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestAddPreviousPatch.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.patch<any>( `${ this.configuration.basePath }/tasks/editor/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/add_previous`,
            updatePreviousContestRequestTaskEditor,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idOlympiad ID of the olympiad
     * @param idStage ID of the stage
     * @param idContest ID of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestRemovePost( idOlympiad: number, idStage: number, idContest: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestRemovePost( idOlympiad: number, idStage: number, idContest: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestRemovePost( idOlympiad: number, idStage: number, idContest: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestRemovePost( idOlympiad: number, idStage: number, idContest: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestRemovePost.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestRemovePost.' )
        }
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestRemovePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/editor/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/remove`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idOlympiad ID of the olympiad
     * @param idStage ID of the stage
     * @param updateStageRequestTaskEditor
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorOlympiadIdOlympiadStageIdStagePatch( idOlympiad: number, idStage: number, updateStageRequestTaskEditor: UpdateStageRequestTaskEditor, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<StageResponseTaskCreator>;
    public tasksEditorOlympiadIdOlympiadStageIdStagePatch( idOlympiad: number, idStage: number, updateStageRequestTaskEditor: UpdateStageRequestTaskEditor, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<StageResponseTaskCreator>>;
    public tasksEditorOlympiadIdOlympiadStageIdStagePatch( idOlympiad: number, idStage: number, updateStageRequestTaskEditor: UpdateStageRequestTaskEditor, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<StageResponseTaskCreator>>;
    public tasksEditorOlympiadIdOlympiadStageIdStagePatch( idOlympiad: number, idStage: number, updateStageRequestTaskEditor: UpdateStageRequestTaskEditor, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksEditorOlympiadIdOlympiadStageIdStagePatch.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling tasksEditorOlympiadIdOlympiadStageIdStagePatch.' )
        }
        if ( updateStageRequestTaskEditor === null || updateStageRequestTaskEditor === undefined )
        {
            throw new Error( 'Required parameter updateStageRequestTaskEditor was null or undefined when calling tasksEditorOlympiadIdOlympiadStageIdStagePatch.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.patch<StageResponseTaskCreator>( `${ this.configuration.basePath }/tasks/editor/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }`,
            updateStageRequestTaskEditor,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idOlympiad ID of the olympiad
     * @param idStage ID of the stage
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorOlympiadIdOlympiadStageIdStageRemovePost( idOlympiad: number, idStage: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorOlympiadIdOlympiadStageIdStageRemovePost( idOlympiad: number, idStage: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorOlympiadIdOlympiadStageIdStageRemovePost( idOlympiad: number, idStage: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorOlympiadIdOlympiadStageIdStageRemovePost( idOlympiad: number, idStage: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksEditorOlympiadIdOlympiadStageIdStageRemovePost.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling tasksEditorOlympiadIdOlympiadStageIdStageRemovePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/editor/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/remove`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idTaskPool ID of the task pool
     * @param idTask ID of the task
     * @param multipleChoiceTask
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorTaskPoolIdTaskPoolTaskIdTaskMultiplePatch( idTaskPool: number, idTask: number, multipleChoiceTask: MultipleChoiceTask, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<TaskResponseTaskCreator>;
    public tasksEditorTaskPoolIdTaskPoolTaskIdTaskMultiplePatch( idTaskPool: number, idTask: number, multipleChoiceTask: MultipleChoiceTask, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<TaskResponseTaskCreator>>;
    public tasksEditorTaskPoolIdTaskPoolTaskIdTaskMultiplePatch( idTaskPool: number, idTask: number, multipleChoiceTask: MultipleChoiceTask, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<TaskResponseTaskCreator>>;
    public tasksEditorTaskPoolIdTaskPoolTaskIdTaskMultiplePatch( idTaskPool: number, idTask: number, multipleChoiceTask: MultipleChoiceTask, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idTaskPool === null || idTaskPool === undefined )
        {
            throw new Error( 'Required parameter idTaskPool was null or undefined when calling tasksEditorTaskPoolIdTaskPoolTaskIdTaskMultiplePatch.' )
        }
        if ( idTask === null || idTask === undefined )
        {
            throw new Error( 'Required parameter idTask was null or undefined when calling tasksEditorTaskPoolIdTaskPoolTaskIdTaskMultiplePatch.' )
        }
        if ( multipleChoiceTask === null || multipleChoiceTask === undefined )
        {
            throw new Error( 'Required parameter multipleChoiceTask was null or undefined when calling tasksEditorTaskPoolIdTaskPoolTaskIdTaskMultiplePatch.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.patch<TaskResponseTaskCreator>( `${ this.configuration.basePath }/tasks/editor/task_pool/${ encodeURIComponent( String( idTaskPool ) ) }/task/${ encodeURIComponent( String( idTask ) ) }/multiple`,
            multipleChoiceTask,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idTaskPool ID of the task pool
     * @param idTask ID of the task
     * @param plainTask
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorTaskPoolIdTaskPoolTaskIdTaskPlainPatch( idTaskPool: number, idTask: number, plainTask: PlainTask, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<TaskResponseTaskCreator>;
    public tasksEditorTaskPoolIdTaskPoolTaskIdTaskPlainPatch( idTaskPool: number, idTask: number, plainTask: PlainTask, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<TaskResponseTaskCreator>>;
    public tasksEditorTaskPoolIdTaskPoolTaskIdTaskPlainPatch( idTaskPool: number, idTask: number, plainTask: PlainTask, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<TaskResponseTaskCreator>>;
    public tasksEditorTaskPoolIdTaskPoolTaskIdTaskPlainPatch( idTaskPool: number, idTask: number, plainTask: PlainTask, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idTaskPool === null || idTaskPool === undefined )
        {
            throw new Error( 'Required parameter idTaskPool was null or undefined when calling tasksEditorTaskPoolIdTaskPoolTaskIdTaskPlainPatch.' )
        }
        if ( idTask === null || idTask === undefined )
        {
            throw new Error( 'Required parameter idTask was null or undefined when calling tasksEditorTaskPoolIdTaskPoolTaskIdTaskPlainPatch.' )
        }
        if ( plainTask === null || plainTask === undefined )
        {
            throw new Error( 'Required parameter plainTask was null or undefined when calling tasksEditorTaskPoolIdTaskPoolTaskIdTaskPlainPatch.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.patch<TaskResponseTaskCreator>( `${ this.configuration.basePath }/tasks/editor/task_pool/${ encodeURIComponent( String( idTaskPool ) ) }/task/${ encodeURIComponent( String( idTask ) ) }/plain`,
            plainTask,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idTaskPool ID of the task pool
     * @param idTask ID of the task
     * @param rangeTask
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorTaskPoolIdTaskPoolTaskIdTaskRangePatch( idTaskPool: number, idTask: number, rangeTask: RangeTask, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<TaskResponseTaskCreator>;
    public tasksEditorTaskPoolIdTaskPoolTaskIdTaskRangePatch( idTaskPool: number, idTask: number, rangeTask: RangeTask, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<TaskResponseTaskCreator>>;
    public tasksEditorTaskPoolIdTaskPoolTaskIdTaskRangePatch( idTaskPool: number, idTask: number, rangeTask: RangeTask, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<TaskResponseTaskCreator>>;
    public tasksEditorTaskPoolIdTaskPoolTaskIdTaskRangePatch( idTaskPool: number, idTask: number, rangeTask: RangeTask, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idTaskPool === null || idTaskPool === undefined )
        {
            throw new Error( 'Required parameter idTaskPool was null or undefined when calling tasksEditorTaskPoolIdTaskPoolTaskIdTaskRangePatch.' )
        }
        if ( idTask === null || idTask === undefined )
        {
            throw new Error( 'Required parameter idTask was null or undefined when calling tasksEditorTaskPoolIdTaskPoolTaskIdTaskRangePatch.' )
        }
        if ( rangeTask === null || rangeTask === undefined )
        {
            throw new Error( 'Required parameter rangeTask was null or undefined when calling tasksEditorTaskPoolIdTaskPoolTaskIdTaskRangePatch.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.patch<TaskResponseTaskCreator>( `${ this.configuration.basePath }/tasks/editor/task_pool/${ encodeURIComponent( String( idTaskPool ) ) }/task/${ encodeURIComponent( String( idTask ) ) }/range`,
            rangeTask,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idTaskPool ID of the task pool
     * @param idTask ID of the task
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorTaskPoolIdTaskPoolTaskIdTaskRemovePost( idTaskPool: number, idTask: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorTaskPoolIdTaskPoolTaskIdTaskRemovePost( idTaskPool: number, idTask: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorTaskPoolIdTaskPoolTaskIdTaskRemovePost( idTaskPool: number, idTask: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorTaskPoolIdTaskPoolTaskIdTaskRemovePost( idTaskPool: number, idTask: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idTaskPool === null || idTaskPool === undefined )
        {
            throw new Error( 'Required parameter idTaskPool was null or undefined when calling tasksEditorTaskPoolIdTaskPoolTaskIdTaskRemovePost.' )
        }
        if ( idTask === null || idTask === undefined )
        {
            throw new Error( 'Required parameter idTask was null or undefined when calling tasksEditorTaskPoolIdTaskPoolTaskIdTaskRemovePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/editor/task_pool/${ encodeURIComponent( String( idTaskPool ) ) }/task/${ encodeURIComponent( String( idTask ) ) }/remove`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idTaskPool ID of the task pool
     * @param idTask ID of the task
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorTaskPoolIdTaskPoolTaskIdTaskUploadImagePost( idTaskPool: number, idTask: number, body: Blob, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorTaskPoolIdTaskPoolTaskIdTaskUploadImagePost( idTaskPool: number, idTask: number, body: Blob, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorTaskPoolIdTaskPoolTaskIdTaskUploadImagePost( idTaskPool: number, idTask: number, body: Blob, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorTaskPoolIdTaskPoolTaskIdTaskUploadImagePost( idTaskPool: number, idTask: number, body: Blob, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idTaskPool === null || idTaskPool === undefined )
        {
            throw new Error( 'Required parameter idTaskPool was null or undefined when calling tasksEditorTaskPoolIdTaskPoolTaskIdTaskUploadImagePost.' )
        }
        if ( idTask === null || idTask === undefined )
        {
            throw new Error( 'Required parameter idTask was null or undefined when calling tasksEditorTaskPoolIdTaskPoolTaskIdTaskUploadImagePost.' )
        }
        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling tasksEditorTaskPoolIdTaskPoolTaskIdTaskUploadImagePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/octet-stream'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/editor/task_pool/${ encodeURIComponent( String( idTaskPool ) ) }/task/${ encodeURIComponent( String( idTask ) ) }/upload_image`,
            body,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksParticipantContestIdContestCertificateSelfGet( idContest: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/pdf', context?: HttpContext } ): Observable<Blob>;
    public tasksParticipantContestIdContestCertificateSelfGet( idContest: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/pdf', context?: HttpContext } ): Observable<HttpResponse<Blob>>;
    public tasksParticipantContestIdContestCertificateSelfGet( idContest: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/pdf', context?: HttpContext } ): Observable<HttpEvent<Blob>>;
    public tasksParticipantContestIdContestCertificateSelfGet( idContest: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/pdf', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksParticipantContestIdContestCertificateSelfGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/pdf'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        return this.httpClient.get( `${ this.configuration.basePath }/tasks/participant/contest/${ encodeURIComponent( String( idContest ) ) }/certificate/self`,
            {
                context: localVarHttpContext,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param enrollRequestTaskParticipant
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksParticipantContestIdContestChangeLocationPost( idContest: number, enrollRequestTaskParticipant: EnrollRequestTaskParticipant, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksParticipantContestIdContestChangeLocationPost( idContest: number, enrollRequestTaskParticipant: EnrollRequestTaskParticipant, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksParticipantContestIdContestChangeLocationPost( idContest: number, enrollRequestTaskParticipant: EnrollRequestTaskParticipant, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksParticipantContestIdContestChangeLocationPost( idContest: number, enrollRequestTaskParticipant: EnrollRequestTaskParticipant, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksParticipantContestIdContestChangeLocationPost.' )
        }
        if ( enrollRequestTaskParticipant === null || enrollRequestTaskParticipant === undefined )
        {
            throw new Error( 'Required parameter enrollRequestTaskParticipant was null or undefined when calling tasksParticipantContestIdContestChangeLocationPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/participant/contest/${ encodeURIComponent( String( idContest ) ) }/change_location`,
            enrollRequestTaskParticipant,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param changeSupervisorRequestTaskParticipant
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksParticipantContestIdContestChangeSupervisorPost( idContest: number, changeSupervisorRequestTaskParticipant: ChangeSupervisorRequestTaskParticipant, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksParticipantContestIdContestChangeSupervisorPost( idContest: number, changeSupervisorRequestTaskParticipant: ChangeSupervisorRequestTaskParticipant, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksParticipantContestIdContestChangeSupervisorPost( idContest: number, changeSupervisorRequestTaskParticipant: ChangeSupervisorRequestTaskParticipant, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksParticipantContestIdContestChangeSupervisorPost( idContest: number, changeSupervisorRequestTaskParticipant: ChangeSupervisorRequestTaskParticipant, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksParticipantContestIdContestChangeSupervisorPost.' )
        }
        if ( changeSupervisorRequestTaskParticipant === null || changeSupervisorRequestTaskParticipant === undefined )
        {
            throw new Error( 'Required parameter changeSupervisorRequestTaskParticipant was null or undefined when calling tasksParticipantContestIdContestChangeSupervisorPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/participant/contest/${ encodeURIComponent( String( idContest ) ) }/change_supervisor`,
            changeSupervisorRequestTaskParticipant,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param enrollRequestTaskParticipant
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksParticipantContestIdContestEnrollPost( idContest: number, enrollRequestTaskParticipant: EnrollRequestTaskParticipant, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksParticipantContestIdContestEnrollPost( idContest: number, enrollRequestTaskParticipant: EnrollRequestTaskParticipant, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksParticipantContestIdContestEnrollPost( idContest: number, enrollRequestTaskParticipant: EnrollRequestTaskParticipant, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksParticipantContestIdContestEnrollPost( idContest: number, enrollRequestTaskParticipant: EnrollRequestTaskParticipant, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksParticipantContestIdContestEnrollPost.' )
        }
        if ( enrollRequestTaskParticipant === null || enrollRequestTaskParticipant === undefined )
        {
            throw new Error( 'Required parameter enrollRequestTaskParticipant was null or undefined when calling tasksParticipantContestIdContestEnrollPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/participant/contest/${ encodeURIComponent( String( idContest ) ) }/enroll`,
            enrollRequestTaskParticipant,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksParticipantContestIdContestExternalStageGet( idContest: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<UserExternalDataResponseTaskParticipant>;
    public tasksParticipantContestIdContestExternalStageGet( idContest: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<UserExternalDataResponseTaskParticipant>>;
    public tasksParticipantContestIdContestExternalStageGet( idContest: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<UserExternalDataResponseTaskParticipant>>;
    public tasksParticipantContestIdContestExternalStageGet( idContest: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksParticipantContestIdContestExternalStageGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<UserExternalDataResponseTaskParticipant>( `${ this.configuration.basePath }/tasks/participant/contest/${ encodeURIComponent( String( idContest ) ) }/external_stage`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksParticipantContestIdContestProctorDataGet( idContest: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<UserProctoringDataResponseTaskParticipant>;
    public tasksParticipantContestIdContestProctorDataGet( idContest: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<UserProctoringDataResponseTaskParticipant>>;
    public tasksParticipantContestIdContestProctorDataGet( idContest: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<UserProctoringDataResponseTaskParticipant>>;
    public tasksParticipantContestIdContestProctorDataGet( idContest: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksParticipantContestIdContestProctorDataGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<UserProctoringDataResponseTaskParticipant>( `${ this.configuration.basePath }/tasks/participant/contest/${ encodeURIComponent( String( idContest ) ) }/proctor_data`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param idTask ID of the task
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksParticipantContestIdContestTasksIdTaskImageSelfGet( idContest: number, idTask: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'image/jpeg', context?: HttpContext } ): Observable<Blob>;
    public tasksParticipantContestIdContestTasksIdTaskImageSelfGet( idContest: number, idTask: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'image/jpeg', context?: HttpContext } ): Observable<HttpResponse<Blob>>;
    public tasksParticipantContestIdContestTasksIdTaskImageSelfGet( idContest: number, idTask: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'image/jpeg', context?: HttpContext } ): Observable<HttpEvent<Blob>>;
    public tasksParticipantContestIdContestTasksIdTaskImageSelfGet( idContest: number, idTask: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'image/jpeg', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksParticipantContestIdContestTasksIdTaskImageSelfGet.' )
        }
        if ( idTask === null || idTask === undefined )
        {
            throw new Error( 'Required parameter idTask was null or undefined when calling tasksParticipantContestIdContestTasksIdTaskImageSelfGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'image/jpeg'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        return this.httpClient.get( `${ this.configuration.basePath }/tasks/participant/contest/${ encodeURIComponent( String( idContest ) ) }/tasks/${ encodeURIComponent( String( idTask ) ) }/image/self`,
            {
                context: localVarHttpContext,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksParticipantContestIdContestTasksSelfGet( idContest: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllTaskResponseTaskParticipant>;
    public tasksParticipantContestIdContestTasksSelfGet( idContest: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllTaskResponseTaskParticipant>>;
    public tasksParticipantContestIdContestTasksSelfGet( idContest: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllTaskResponseTaskParticipant>>;
    public tasksParticipantContestIdContestTasksSelfGet( idContest: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksParticipantContestIdContestTasksSelfGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<AllTaskResponseTaskParticipant>( `${ this.configuration.basePath }/tasks/participant/contest/${ encodeURIComponent( String( idContest ) ) }/tasks/self`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksParticipantContestIdContestVariantSelfGet( idContest: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<VariantWithCompletedTasksCountTaskParticipant>;
    public tasksParticipantContestIdContestVariantSelfGet( idContest: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<VariantWithCompletedTasksCountTaskParticipant>>;
    public tasksParticipantContestIdContestVariantSelfGet( idContest: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<VariantWithCompletedTasksCountTaskParticipant>>;
    public tasksParticipantContestIdContestVariantSelfGet( idContest: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksParticipantContestIdContestVariantSelfGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<VariantWithCompletedTasksCountTaskParticipant>( `${ this.configuration.basePath }/tasks/participant/contest/${ encodeURIComponent( String( idContest ) ) }/variant/self`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param visibility
     * @param offset
     * @param limit
     * @param baseContestId
     * @param locationId
     * @param academicYear
     * @param endDate
     * @param targetClasses
     * @param onlyCount
     * @param compositeType
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksParticipantOlympiadAllGet( visibility?: boolean, offset?: number, limit?: number, baseContestId?: number, locationId?: number, academicYear?: number, endDate?: string, targetClasses?: '5' | '6' | '7' | '8' | '9' | '10' | '11' | 'student', onlyCount?: boolean, compositeType?: 'SimpleContest' | 'CompositeContest', observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<FilterSimpleContestResponseTaskParticipant>;
    public tasksParticipantOlympiadAllGet( visibility?: boolean, offset?: number, limit?: number, baseContestId?: number, locationId?: number, academicYear?: number, endDate?: string, targetClasses?: '5' | '6' | '7' | '8' | '9' | '10' | '11' | 'student', onlyCount?: boolean, compositeType?: 'SimpleContest' | 'CompositeContest', observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<FilterSimpleContestResponseTaskParticipant>>;
    public tasksParticipantOlympiadAllGet( visibility?: boolean, offset?: number, limit?: number, baseContestId?: number, locationId?: number, academicYear?: number, endDate?: string, targetClasses?: '5' | '6' | '7' | '8' | '9' | '10' | '11' | 'student', onlyCount?: boolean, compositeType?: 'SimpleContest' | 'CompositeContest', observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<FilterSimpleContestResponseTaskParticipant>>;
    public tasksParticipantOlympiadAllGet( visibility?: boolean, offset?: number, limit?: number, baseContestId?: number, locationId?: number, academicYear?: number, endDate?: string, targetClasses?: '5' | '6' | '7' | '8' | '9' | '10' | '11' | 'student', onlyCount?: boolean, compositeType?: 'SimpleContest' | 'CompositeContest', observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {

        let localVarQueryParameters = new HttpParams( { encoder: this.encoder } )
        if ( visibility !== undefined && visibility !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> visibility, 'visibility' )
        }
        if ( offset !== undefined && offset !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> offset, 'offset' )
        }
        if ( limit !== undefined && limit !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> limit, 'limit' )
        }
        if ( baseContestId !== undefined && baseContestId !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> baseContestId, 'base_contest_id' )
        }
        if ( locationId !== undefined && locationId !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> locationId, 'location_id' )
        }
        if ( academicYear !== undefined && academicYear !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> academicYear, 'academic_year' )
        }
        if ( endDate !== undefined && endDate !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> endDate, 'end_date' )
        }
        if ( targetClasses !== undefined && targetClasses !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> targetClasses, 'target_classes' )
        }
        if ( onlyCount !== undefined && onlyCount !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> onlyCount, 'only_count' )
        }
        if ( compositeType !== undefined && compositeType !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> compositeType, 'composite_type' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<FilterSimpleContestResponseTaskParticipant>( `${ this.configuration.basePath }/tasks/participant/olympiad/all`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idOlympiad Id of the olympiad
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksParticipantOlympiadIdOlympiadGet( idOlympiad: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<Contest>;
    public tasksParticipantOlympiadIdOlympiadGet( idOlympiad: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<Contest>>;
    public tasksParticipantOlympiadIdOlympiadGet( idOlympiad: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<Contest>>;
    public tasksParticipantOlympiadIdOlympiadGet( idOlympiad: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksParticipantOlympiadIdOlympiadGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<Contest>( `${ this.configuration.basePath }/tasks/participant/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksParticipantOlympiadIdOlympiadStageIdStageContestAllGet( idOlympiad: number, idStage: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllOlympiadsResponseTaskUnauthorized>;
    public tasksParticipantOlympiadIdOlympiadStageIdStageContestAllGet( idOlympiad: number, idStage: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllOlympiadsResponseTaskUnauthorized>>;
    public tasksParticipantOlympiadIdOlympiadStageIdStageContestAllGet( idOlympiad: number, idStage: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllOlympiadsResponseTaskUnauthorized>>;
    public tasksParticipantOlympiadIdOlympiadStageIdStageContestAllGet( idOlympiad: number, idStage: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksParticipantOlympiadIdOlympiadStageIdStageContestAllGet.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling tasksParticipantOlympiadIdOlympiadStageIdStageContestAllGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<AllOlympiadsResponseTaskUnauthorized>( `${ this.configuration.basePath }/tasks/participant/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/all`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksParticipantOlympiadIdOlympiadStageIdStageContestIdContestGet( idOlympiad: number, idStage: number, idContest: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<Contest>;
    public tasksParticipantOlympiadIdOlympiadStageIdStageContestIdContestGet( idOlympiad: number, idStage: number, idContest: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<Contest>>;
    public tasksParticipantOlympiadIdOlympiadStageIdStageContestIdContestGet( idOlympiad: number, idStage: number, idContest: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<Contest>>;
    public tasksParticipantOlympiadIdOlympiadStageIdStageContestIdContestGet( idOlympiad: number, idStage: number, idContest: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksParticipantOlympiadIdOlympiadStageIdStageContestIdContestGet.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling tasksParticipantOlympiadIdOlympiadStageIdStageContestIdContestGet.' )
        }
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksParticipantOlympiadIdOlympiadStageIdStageContestIdContestGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<Contest>( `${ this.configuration.basePath }/tasks/participant/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksUnauthorizedBaseOlympiadAllGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllBaseContestResponseTaskUnauthorized>;
    public tasksUnauthorizedBaseOlympiadAllGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllBaseContestResponseTaskUnauthorized>>;
    public tasksUnauthorizedBaseOlympiadAllGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllBaseContestResponseTaskUnauthorized>>;
    public tasksUnauthorizedBaseOlympiadAllGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<AllBaseContestResponseTaskUnauthorized>( `${ this.configuration.basePath }/tasks/unauthorized/base_olympiad/all`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idBaseOlympiad Id of the base contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksUnauthorizedBaseOlympiadIdBaseOlympiadGet( idBaseOlympiad: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<BaseContest>;
    public tasksUnauthorizedBaseOlympiadIdBaseOlympiadGet( idBaseOlympiad: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<BaseContest>>;
    public tasksUnauthorizedBaseOlympiadIdBaseOlympiadGet( idBaseOlympiad: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<BaseContest>>;
    public tasksUnauthorizedBaseOlympiadIdBaseOlympiadGet( idBaseOlympiad: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idBaseOlympiad === null || idBaseOlympiad === undefined )
        {
            throw new Error( 'Required parameter idBaseOlympiad was null or undefined when calling tasksUnauthorizedBaseOlympiadIdBaseOlympiadGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<BaseContest>( `${ this.configuration.basePath }/tasks/unauthorized/base_olympiad/${ encodeURIComponent( String( idBaseOlympiad ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idBaseOlympiad Id of the base contest
     * @param idOlympiad Id of the olympiad
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksUnauthorizedBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadGet( idBaseOlympiad: number, idOlympiad: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<Contest>;
    public tasksUnauthorizedBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadGet( idBaseOlympiad: number, idOlympiad: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<Contest>>;
    public tasksUnauthorizedBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadGet( idBaseOlympiad: number, idOlympiad: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<Contest>>;
    public tasksUnauthorizedBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadGet( idBaseOlympiad: number, idOlympiad: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idBaseOlympiad === null || idBaseOlympiad === undefined )
        {
            throw new Error( 'Required parameter idBaseOlympiad was null or undefined when calling tasksUnauthorizedBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadGet.' )
        }
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksUnauthorizedBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<Contest>( `${ this.configuration.basePath }/tasks/unauthorized/base_olympiad/${ encodeURIComponent( String( idBaseOlympiad ) ) }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksUnauthorizedLocationAllGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllLocationResponseTaskUnauthorized>;
    public tasksUnauthorizedLocationAllGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllLocationResponseTaskUnauthorized>>;
    public tasksUnauthorizedLocationAllGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllLocationResponseTaskUnauthorized>>;
    public tasksUnauthorizedLocationAllGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<AllLocationResponseTaskUnauthorized>( `${ this.configuration.basePath }/tasks/unauthorized/location/all`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idLocation Id of the location
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksUnauthorizedLocationIdLocationGet( idLocation: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<OlympiadLocation>;
    public tasksUnauthorizedLocationIdLocationGet( idLocation: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<OlympiadLocation>>;
    public tasksUnauthorizedLocationIdLocationGet( idLocation: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<OlympiadLocation>>;
    public tasksUnauthorizedLocationIdLocationGet( idLocation: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idLocation === null || idLocation === undefined )
        {
            throw new Error( 'Required parameter idLocation was null or undefined when calling tasksUnauthorizedLocationIdLocationGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<OlympiadLocation>( `${ this.configuration.basePath }/tasks/unauthorized/location/${ encodeURIComponent( String( idLocation ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param visibility
     * @param offset
     * @param limit
     * @param baseContestId
     * @param academicYear
     * @param locationId
     * @param endDate
     * @param targetClass
     * @param onlyCount
     * @param compositeType
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksUnauthorizedOlympiadAllGet( visibility?: boolean, offset?: number, limit?: number, baseContestId?: number, academicYear?: number, locationId?: number, endDate?: string, targetClass?: number, onlyCount?: boolean, compositeType?: 'SimpleContest' | 'CompositeContest', observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<FilterSimpleContestResponse>;
    public tasksUnauthorizedOlympiadAllGet( visibility?: boolean, offset?: number, limit?: number, baseContestId?: number, academicYear?: number, locationId?: number, endDate?: string, targetClass?: number, onlyCount?: boolean, compositeType?: 'SimpleContest' | 'CompositeContest', observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<FilterSimpleContestResponse>>;
    public tasksUnauthorizedOlympiadAllGet( visibility?: boolean, offset?: number, limit?: number, baseContestId?: number, academicYear?: number, locationId?: number, endDate?: string, targetClass?: number, onlyCount?: boolean, compositeType?: 'SimpleContest' | 'CompositeContest', observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<FilterSimpleContestResponse>>;
    public tasksUnauthorizedOlympiadAllGet( visibility?: boolean, offset?: number, limit?: number, baseContestId?: number, academicYear?: number, locationId?: number, endDate?: string, targetClass?: number, onlyCount?: boolean, compositeType?: 'SimpleContest' | 'CompositeContest', observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {

        let localVarQueryParameters = new HttpParams( { encoder: this.encoder } )
        if ( visibility !== undefined && visibility !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> visibility, 'visibility' )
        }
        if ( offset !== undefined && offset !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> offset, 'offset' )
        }
        if ( limit !== undefined && limit !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> limit, 'limit' )
        }
        if ( baseContestId !== undefined && baseContestId !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> baseContestId, 'base_contest_id' )
        }
        if ( academicYear !== undefined && academicYear !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> academicYear, 'academic_year' )
        }
        if ( locationId !== undefined && locationId !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> locationId, 'location_id' )
        }
        if ( endDate !== undefined && endDate !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> endDate, 'end_date' )
        }
        if ( targetClass !== undefined && targetClass !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> targetClass, 'target_class' )
        }
        if ( onlyCount !== undefined && onlyCount !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> onlyCount, 'only_count' )
        }
        if ( compositeType !== undefined && compositeType !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> compositeType, 'composite_type' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<FilterSimpleContestResponse>( `${ this.configuration.basePath }/tasks/unauthorized/olympiad/all`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idOlympiad Id of the olympiad
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksUnauthorizedOlympiadIdOlympiadStageAllGet( idOlympiad: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllStagesResponseTaskUnauthorized>;
    public tasksUnauthorizedOlympiadIdOlympiadStageAllGet( idOlympiad: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllStagesResponseTaskUnauthorized>>;
    public tasksUnauthorizedOlympiadIdOlympiadStageAllGet( idOlympiad: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllStagesResponseTaskUnauthorized>>;
    public tasksUnauthorizedOlympiadIdOlympiadStageAllGet( idOlympiad: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksUnauthorizedOlympiadIdOlympiadStageAllGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<AllStagesResponseTaskUnauthorized>( `${ this.configuration.basePath }/tasks/unauthorized/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/all`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksUnauthorizedOlympiadIdOlympiadStageIdStageGet( idOlympiad: number, idStage: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<Stage>;
    public tasksUnauthorizedOlympiadIdOlympiadStageIdStageGet( idOlympiad: number, idStage: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<Stage>>;
    public tasksUnauthorizedOlympiadIdOlympiadStageIdStageGet( idOlympiad: number, idStage: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<Stage>>;
    public tasksUnauthorizedOlympiadIdOlympiadStageIdStageGet( idOlympiad: number, idStage: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksUnauthorizedOlympiadIdOlympiadStageIdStageGet.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling tasksUnauthorizedOlympiadIdOlympiadStageIdStageGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<Stage>( `${ this.configuration.basePath }/tasks/unauthorized/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksUnauthorizedOlympiadTypeAllGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllOlympiadTypesResponseTaskUnauthorized>;
    public tasksUnauthorizedOlympiadTypeAllGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllOlympiadTypesResponseTaskUnauthorized>>;
    public tasksUnauthorizedOlympiadTypeAllGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllOlympiadTypesResponseTaskUnauthorized>>;
    public tasksUnauthorizedOlympiadTypeAllGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<AllOlympiadTypesResponseTaskUnauthorized>( `${ this.configuration.basePath }/tasks/unauthorized/olympiad_type/all`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idOlympiadType Id of the olympiad type
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksUnauthorizedOlympiadTypeIdOlympiadTypeGet( idOlympiadType: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<OlympiadType>;
    public tasksUnauthorizedOlympiadTypeIdOlympiadTypeGet( idOlympiadType: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<OlympiadType>>;
    public tasksUnauthorizedOlympiadTypeIdOlympiadTypeGet( idOlympiadType: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<OlympiadType>>;
    public tasksUnauthorizedOlympiadTypeIdOlympiadTypeGet( idOlympiadType: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idOlympiadType === null || idOlympiadType === undefined )
        {
            throw new Error( 'Required parameter idOlympiadType was null or undefined when calling tasksUnauthorizedOlympiadTypeIdOlympiadTypeGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<OlympiadType>( `${ this.configuration.basePath }/tasks/unauthorized/olympiad_type/${ encodeURIComponent( String( idOlympiadType ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksUnauthorizedTargetClassAllGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllTargetClassesRequestTaskUnauthorized>;
    public tasksUnauthorizedTargetClassAllGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllTargetClassesRequestTaskUnauthorized>>;
    public tasksUnauthorizedTargetClassAllGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllTargetClassesRequestTaskUnauthorized>>;
    public tasksUnauthorizedTargetClassAllGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<AllTargetClassesRequestTaskUnauthorized>( `${ this.configuration.basePath }/tasks/unauthorized/target_class/all`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idTargetClass Id of the location
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksUnauthorizedTargetClassIdTargetClassGet( idTargetClass: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<TargetClass>;
    public tasksUnauthorizedTargetClassIdTargetClassGet( idTargetClass: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<TargetClass>>;
    public tasksUnauthorizedTargetClassIdTargetClassGet( idTargetClass: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<TargetClass>>;
    public tasksUnauthorizedTargetClassIdTargetClassGet( idTargetClass: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idTargetClass === null || idTargetClass === undefined )
        {
            throw new Error( 'Required parameter idTargetClass was null or undefined when calling tasksUnauthorizedTargetClassIdTargetClassGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json'
        if ( localVarHttpHeaderAcceptSelected )
        {
            if ( localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
            {
                responseType_ = 'text'
            }
            else if ( this.configuration.isJsonMime( localVarHttpHeaderAcceptSelected ) )
            {
                responseType_ = 'json'
            }
            else
            {
                responseType_ = 'blob'
            }
        }

        return this.httpClient.get<TargetClass>( `${ this.configuration.basePath }/tasks/unauthorized/target_class/${ encodeURIComponent( String( idTargetClass ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }
}