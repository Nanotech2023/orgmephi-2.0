/**
 * aggregate_contest_tasks
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core'
import {
    HttpClient,
    HttpContext,
    HttpEvent,
    HttpHeaders,
    HttpParameterCodec,
    HttpParams,
    HttpResponse
} from '@angular/common/http'
import { Observable } from 'rxjs'
import { CustomHttpParameterCodec } from '@api/encoder'
import { BASE_PATH } from '@api/variables'
import { Configuration } from '@api/configuration'
import { environment } from '@environments/environment'
import {
    AllBaseContestResponseTaskUnauthorized,
    AllLocationResponseTaskUnauthorized,
    AllOlympiadsResponseTaskCreator,
    AllOlympiadsResponseTaskUnauthorized,
    AllOlympiadTypesResponseTaskUnauthorized,
    AllStagesResponseTaskUnauthorized,
    AllTargetClassesRequestTaskUnauthorized,
    AllTaskResponseTaskParticipant,
    AllTasksResponseTaskCreator,
    AllVariantsResponseTaskCreator,
    BaseContest,
    BaseOlympiadIdResponseTaskCreator,
    BaseOlympiadResponseTaskCreator,
    ChangeSupervisorRequestTaskParticipant,
    ChangeUsersLocationInContestRequestTaskControlUsers,
    Contest,
    ContestGroupRestrictionListAdmin,
    ContestIdResponseTaskCreator,
    ContestResponseTaskCreator,
    CreateBaseOlympiadRequestTaskCreator,
    CreateCompositeContestRequestTaskCreator,
    CreateMultipleRequestTaskCreator,
    CreateOlympiadTypeRequestTaskAdmin,
    CreateOnlineLocationRequestTaskAdmin,
    CreateOtherLocationRequestTaskAdmin,
    CreatePlainRequestTaskCreator,
    CreateRangeRequestTaskCreator,
    CreateRussiaLocationRequestTaskAdmin,
    CreateSimpleContestRequestTaskCreator,
    CreateStageRequestTaskCreator,
    CreateVariantRequestTaskCreator,
    EnrollRequestTaskParticipant,
    FilterSimpleContestResponse,
    FilterSimpleContestResponseTaskParticipant,
    LocationResponseTaskAdmin,
    OlympiadLocation,
    OlympiadType,
    OlympiadTypeResponseTaskAdmin,
    Stage,
    StageIdResponseTaskCreator,
    StageResponseTaskCreator,
    TargetClass,
    TaskIdResponseTaskCreator,
    TaskResponseTaskCreator,
    UpdateBaseOlympiadRequestTaskEditor,
    UpdateContestRequestTaskEditor,
    UpdateLocationOfContestRequestTaskEditor,
    UpdateMultipleRequestTaskEditor,
    UpdatePlainRequestTaskEditor,
    UpdatePreviousContestRequestTaskEditor,
    UpdateRangeRequestTaskEditor,
    UpdateStageRequestTaskEditor,
    UpdateTargetClassesOfContestRequestTaskEditor,
    UpdateUserInContestRequestTaskControlUsers,
    UpdateVariantRequestTaskEditor,
    UsersResponseTaskControlUsers,
    VariantIdResponseTaskCreator,
    VariantResponseTaskCreator,
    VariantWithCompletedTasksCountTaskParticipant
} from '@api/tasks/model'


@Injectable()
export class TasksService
{
    protected basePath = environment.apiUrl + '/contest'
    public defaultHeaders = new HttpHeaders()
    public configuration = new Configuration()
    public encoder: HttpParameterCodec

    constructor( protected httpClient: HttpClient, @Optional() @Inject( BASE_PATH ) basePath: string, @Optional() configuration: Configuration )
    {
        if ( configuration )
        {
            this.configuration = configuration
        }
        if ( typeof this.configuration.basePath !== 'string' )
        {
            if ( typeof basePath !== 'string' )
            {
                basePath = this.basePath
            }
            this.configuration.basePath = basePath
        }
        this.configuration.withCredentials = true
        this.configuration.credentials[ "CSRFAccessToken" ] = () => localStorage.getItem( 'CSRFAccessToken' ) ?? undefined
        this.configuration.credentials[ "CSRFRefreshToken" ] = () => localStorage.getItem( 'CSRFRefreshToken' ) ?? undefined
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec()
    }

    private addToHttpParams( httpParams: HttpParams, value: any, key?: string ): HttpParams
    {
        if ( typeof value === "object" && value instanceof Date === false )
        {
            httpParams = this.addToHttpParamsRecursive( httpParams, value )
        }
        else
        {
            httpParams = this.addToHttpParamsRecursive( httpParams, value, key )
        }
        return httpParams
    }

    private addToHttpParamsRecursive( httpParams: HttpParams, value?: any, key?: string ): HttpParams
    {
        if ( value == null )
        {
            return httpParams
        }

        if ( typeof value === "object" )
        {
            if ( Array.isArray( value ) )
            {
                ( value as any[] ).forEach( elem => httpParams = this.addToHttpParamsRecursive( httpParams, elem, key ) )
            }
            else if ( value instanceof Date )
            {
                if ( key != null )
                {
                    httpParams = httpParams.append( key,
                        ( value as Date ).toISOString().substr( 0, 10 ) )
                }
                else
                {
                    throw Error( "key may not be null if value is Date" )
                }
            }
            else
            {
                Object.keys( value ).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[ k ], key != null ? `${ key }.${ k }` : k ) )
            }
        }
        else if ( key != null )
        {
            httpParams = httpParams.append( key, value )
        }
        else
        {
            throw Error( "key may not be null if value is not object or array" )
        }
        return httpParams
    }

    /**
     * @param createOnlineLocationRequestTaskAdmin
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksAdminLocationCreateOnlinePost( createOnlineLocationRequestTaskAdmin: CreateOnlineLocationRequestTaskAdmin, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<LocationResponseTaskAdmin>;
    public tasksAdminLocationCreateOnlinePost( createOnlineLocationRequestTaskAdmin: CreateOnlineLocationRequestTaskAdmin, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<LocationResponseTaskAdmin>>;
    public tasksAdminLocationCreateOnlinePost( createOnlineLocationRequestTaskAdmin: CreateOnlineLocationRequestTaskAdmin, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<LocationResponseTaskAdmin>>;
    public tasksAdminLocationCreateOnlinePost( createOnlineLocationRequestTaskAdmin: CreateOnlineLocationRequestTaskAdmin, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( createOnlineLocationRequestTaskAdmin === null || createOnlineLocationRequestTaskAdmin === undefined )
        {
            throw new Error( 'Required parameter createOnlineLocationRequestTaskAdmin was null or undefined when calling tasksAdminLocationCreateOnlinePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<LocationResponseTaskAdmin>( `${ this.configuration.basePath }/tasks/admin/location/create_online`,
            createOnlineLocationRequestTaskAdmin,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param createOtherLocationRequestTaskAdmin
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksAdminLocationCreateOtherPost( createOtherLocationRequestTaskAdmin: CreateOtherLocationRequestTaskAdmin, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<LocationResponseTaskAdmin>;
    public tasksAdminLocationCreateOtherPost( createOtherLocationRequestTaskAdmin: CreateOtherLocationRequestTaskAdmin, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<LocationResponseTaskAdmin>>;
    public tasksAdminLocationCreateOtherPost( createOtherLocationRequestTaskAdmin: CreateOtherLocationRequestTaskAdmin, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<LocationResponseTaskAdmin>>;
    public tasksAdminLocationCreateOtherPost( createOtherLocationRequestTaskAdmin: CreateOtherLocationRequestTaskAdmin, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( createOtherLocationRequestTaskAdmin === null || createOtherLocationRequestTaskAdmin === undefined )
        {
            throw new Error( 'Required parameter createOtherLocationRequestTaskAdmin was null or undefined when calling tasksAdminLocationCreateOtherPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<LocationResponseTaskAdmin>( `${ this.configuration.basePath }/tasks/admin/location/create_other`,
            createOtherLocationRequestTaskAdmin,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param createRussiaLocationRequestTaskAdmin
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksAdminLocationCreateRussiaPost( createRussiaLocationRequestTaskAdmin: CreateRussiaLocationRequestTaskAdmin, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<LocationResponseTaskAdmin>;
    public tasksAdminLocationCreateRussiaPost( createRussiaLocationRequestTaskAdmin: CreateRussiaLocationRequestTaskAdmin, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<LocationResponseTaskAdmin>>;
    public tasksAdminLocationCreateRussiaPost( createRussiaLocationRequestTaskAdmin: CreateRussiaLocationRequestTaskAdmin, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<LocationResponseTaskAdmin>>;
    public tasksAdminLocationCreateRussiaPost( createRussiaLocationRequestTaskAdmin: CreateRussiaLocationRequestTaskAdmin, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( createRussiaLocationRequestTaskAdmin === null || createRussiaLocationRequestTaskAdmin === undefined )
        {
            throw new Error( 'Required parameter createRussiaLocationRequestTaskAdmin was null or undefined when calling tasksAdminLocationCreateRussiaPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<LocationResponseTaskAdmin>( `${ this.configuration.basePath }/tasks/admin/location/create_russia`,
            createRussiaLocationRequestTaskAdmin,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idLocation Id of the location
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksAdminLocationIdLocationRemovePost( idLocation: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksAdminLocationIdLocationRemovePost( idLocation: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksAdminLocationIdLocationRemovePost( idLocation: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksAdminLocationIdLocationRemovePost( idLocation: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idLocation === null || idLocation === undefined )
        {
            throw new Error( 'Required parameter idLocation was null or undefined when calling tasksAdminLocationIdLocationRemovePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/admin/location/${ encodeURIComponent( String( idLocation ) ) }/remove`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param createOlympiadTypeRequestTaskAdmin
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksAdminOlympiadTypeCreatePost( createOlympiadTypeRequestTaskAdmin: CreateOlympiadTypeRequestTaskAdmin, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<OlympiadTypeResponseTaskAdmin>;
    public tasksAdminOlympiadTypeCreatePost( createOlympiadTypeRequestTaskAdmin: CreateOlympiadTypeRequestTaskAdmin, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<OlympiadTypeResponseTaskAdmin>>;
    public tasksAdminOlympiadTypeCreatePost( createOlympiadTypeRequestTaskAdmin: CreateOlympiadTypeRequestTaskAdmin, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<OlympiadTypeResponseTaskAdmin>>;
    public tasksAdminOlympiadTypeCreatePost( createOlympiadTypeRequestTaskAdmin: CreateOlympiadTypeRequestTaskAdmin, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( createOlympiadTypeRequestTaskAdmin === null || createOlympiadTypeRequestTaskAdmin === undefined )
        {
            throw new Error( 'Required parameter createOlympiadTypeRequestTaskAdmin was null or undefined when calling tasksAdminOlympiadTypeCreatePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<OlympiadTypeResponseTaskAdmin>( `${ this.configuration.basePath }/tasks/admin/olympiad_type/create`,
            createOlympiadTypeRequestTaskAdmin,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idOlympiadType Id of the olympiad type
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksAdminOlympiadTypeIdOlympiadTypeRemovePost( idOlympiadType: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksAdminOlympiadTypeIdOlympiadTypeRemovePost( idOlympiadType: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksAdminOlympiadTypeIdOlympiadTypeRemovePost( idOlympiadType: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksAdminOlympiadTypeIdOlympiadTypeRemovePost( idOlympiadType: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idOlympiadType === null || idOlympiadType === undefined )
        {
            throw new Error( 'Required parameter idOlympiadType was null or undefined when calling tasksAdminOlympiadTypeIdOlympiadTypeRemovePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/admin/olympiad_type/${ encodeURIComponent( String( idOlympiadType ) ) }/remove`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param updateUserInContestRequestTaskControlUsers
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksControlUsersContestIdContestAddUserPost( idContest: number, updateUserInContestRequestTaskControlUsers: UpdateUserInContestRequestTaskControlUsers, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksControlUsersContestIdContestAddUserPost( idContest: number, updateUserInContestRequestTaskControlUsers: UpdateUserInContestRequestTaskControlUsers, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksControlUsersContestIdContestAddUserPost( idContest: number, updateUserInContestRequestTaskControlUsers: UpdateUserInContestRequestTaskControlUsers, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksControlUsersContestIdContestAddUserPost( idContest: number, updateUserInContestRequestTaskControlUsers: UpdateUserInContestRequestTaskControlUsers, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksControlUsersContestIdContestAddUserPost.' )
        }
        if ( updateUserInContestRequestTaskControlUsers === null || updateUserInContestRequestTaskControlUsers === undefined )
        {
            throw new Error( 'Required parameter updateUserInContestRequestTaskControlUsers was null or undefined when calling tasksControlUsersContestIdContestAddUserPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/control_users/contest/${ encodeURIComponent( String( idContest ) ) }/add_user`,
            updateUserInContestRequestTaskControlUsers,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param changeUsersLocationInContestRequestTaskControlUsers
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksControlUsersContestIdContestChangeLocationPost( idContest: number, changeUsersLocationInContestRequestTaskControlUsers: ChangeUsersLocationInContestRequestTaskControlUsers, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksControlUsersContestIdContestChangeLocationPost( idContest: number, changeUsersLocationInContestRequestTaskControlUsers: ChangeUsersLocationInContestRequestTaskControlUsers, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksControlUsersContestIdContestChangeLocationPost( idContest: number, changeUsersLocationInContestRequestTaskControlUsers: ChangeUsersLocationInContestRequestTaskControlUsers, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksControlUsersContestIdContestChangeLocationPost( idContest: number, changeUsersLocationInContestRequestTaskControlUsers: ChangeUsersLocationInContestRequestTaskControlUsers, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksControlUsersContestIdContestChangeLocationPost.' )
        }
        if ( changeUsersLocationInContestRequestTaskControlUsers === null || changeUsersLocationInContestRequestTaskControlUsers === undefined )
        {
            throw new Error( 'Required parameter changeUsersLocationInContestRequestTaskControlUsers was null or undefined when calling tasksControlUsersContestIdContestChangeLocationPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/control_users/contest/${ encodeURIComponent( String( idContest ) ) }/change_location`,
            changeUsersLocationInContestRequestTaskControlUsers,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param updateUserInContestRequestTaskControlUsers
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksControlUsersContestIdContestEditUsersPatch( idContest: number, updateUserInContestRequestTaskControlUsers: UpdateUserInContestRequestTaskControlUsers, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksControlUsersContestIdContestEditUsersPatch( idContest: number, updateUserInContestRequestTaskControlUsers: UpdateUserInContestRequestTaskControlUsers, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksControlUsersContestIdContestEditUsersPatch( idContest: number, updateUserInContestRequestTaskControlUsers: UpdateUserInContestRequestTaskControlUsers, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksControlUsersContestIdContestEditUsersPatch( idContest: number, updateUserInContestRequestTaskControlUsers: UpdateUserInContestRequestTaskControlUsers, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksControlUsersContestIdContestEditUsersPatch.' )
        }
        if ( updateUserInContestRequestTaskControlUsers === null || updateUserInContestRequestTaskControlUsers === undefined )
        {
            throw new Error( 'Required parameter updateUserInContestRequestTaskControlUsers was null or undefined when calling tasksControlUsersContestIdContestEditUsersPatch.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.patch<any>( `${ this.configuration.basePath }/tasks/control_users/contest/${ encodeURIComponent( String( idContest ) ) }/edit_users`,
            updateUserInContestRequestTaskControlUsers,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param updateUserInContestRequestTaskControlUsers
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksControlUsersContestIdContestRemoveUserPost( idContest: number, updateUserInContestRequestTaskControlUsers: UpdateUserInContestRequestTaskControlUsers, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksControlUsersContestIdContestRemoveUserPost( idContest: number, updateUserInContestRequestTaskControlUsers: UpdateUserInContestRequestTaskControlUsers, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksControlUsersContestIdContestRemoveUserPost( idContest: number, updateUserInContestRequestTaskControlUsers: UpdateUserInContestRequestTaskControlUsers, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksControlUsersContestIdContestRemoveUserPost( idContest: number, updateUserInContestRequestTaskControlUsers: UpdateUserInContestRequestTaskControlUsers, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksControlUsersContestIdContestRemoveUserPost.' )
        }
        if ( updateUserInContestRequestTaskControlUsers === null || updateUserInContestRequestTaskControlUsers === undefined )
        {
            throw new Error( 'Required parameter updateUserInContestRequestTaskControlUsers was null or undefined when calling tasksControlUsersContestIdContestRemoveUserPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/control_users/contest/${ encodeURIComponent( String( idContest ) ) }/remove_user`,
            updateUserInContestRequestTaskControlUsers,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksControlUsersContestIdContestUserAllGet( idContest: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<UsersResponseTaskControlUsers>;
    public tasksControlUsersContestIdContestUserAllGet( idContest: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<UsersResponseTaskControlUsers>>;
    public tasksControlUsersContestIdContestUserAllGet( idContest: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<UsersResponseTaskControlUsers>>;
    public tasksControlUsersContestIdContestUserAllGet( idContest: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksControlUsersContestIdContestUserAllGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<UsersResponseTaskControlUsers>( `${ this.configuration.basePath }/tasks/control_users/contest/${ encodeURIComponent( String( idContest ) ) }/user/all`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param idUser ID of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksControlUsersContestIdContestUserIdUserCertificateGet( idContest: number, idUser: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/pdf', context?: HttpContext } ): Observable<Blob>;
    public tasksControlUsersContestIdContestUserIdUserCertificateGet( idContest: number, idUser: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/pdf', context?: HttpContext } ): Observable<HttpResponse<Blob>>;
    public tasksControlUsersContestIdContestUserIdUserCertificateGet( idContest: number, idUser: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/pdf', context?: HttpContext } ): Observable<HttpEvent<Blob>>;
    public tasksControlUsersContestIdContestUserIdUserCertificateGet( idContest: number, idUser: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/pdf', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksControlUsersContestIdContestUserIdUserCertificateGet.' )
        }
        if ( idUser === null || idUser === undefined )
        {
            throw new Error( 'Required parameter idUser was null or undefined when calling tasksControlUsersContestIdContestUserIdUserCertificateGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/pdf'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        return this.httpClient.get( `${ this.configuration.basePath }/tasks/control_users/contest/${ encodeURIComponent( String( idContest ) ) }/user/${ encodeURIComponent( String( idUser ) ) }/certificate`,
            {
                context: localVarHttpContext,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param createBaseOlympiadRequestTaskCreator
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorBaseOlympiadCreatePost( createBaseOlympiadRequestTaskCreator: CreateBaseOlympiadRequestTaskCreator, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<BaseOlympiadIdResponseTaskCreator>;
    public tasksCreatorBaseOlympiadCreatePost( createBaseOlympiadRequestTaskCreator: CreateBaseOlympiadRequestTaskCreator, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<BaseOlympiadIdResponseTaskCreator>>;
    public tasksCreatorBaseOlympiadCreatePost( createBaseOlympiadRequestTaskCreator: CreateBaseOlympiadRequestTaskCreator, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<BaseOlympiadIdResponseTaskCreator>>;
    public tasksCreatorBaseOlympiadCreatePost( createBaseOlympiadRequestTaskCreator: CreateBaseOlympiadRequestTaskCreator, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( createBaseOlympiadRequestTaskCreator === null || createBaseOlympiadRequestTaskCreator === undefined )
        {
            throw new Error( 'Required parameter createBaseOlympiadRequestTaskCreator was null or undefined when calling tasksCreatorBaseOlympiadCreatePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<BaseOlympiadIdResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/base_olympiad/create`,
            createBaseOlympiadRequestTaskCreator,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idBaseOlympiad ID of the base olympiad
     * @param createCompositeContestRequestTaskCreator
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorBaseOlympiadIdBaseOlympiadOlympiadCreateCompositePost( idBaseOlympiad: number, createCompositeContestRequestTaskCreator: CreateCompositeContestRequestTaskCreator, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<ContestIdResponseTaskCreator>;
    public tasksCreatorBaseOlympiadIdBaseOlympiadOlympiadCreateCompositePost( idBaseOlympiad: number, createCompositeContestRequestTaskCreator: CreateCompositeContestRequestTaskCreator, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<ContestIdResponseTaskCreator>>;
    public tasksCreatorBaseOlympiadIdBaseOlympiadOlympiadCreateCompositePost( idBaseOlympiad: number, createCompositeContestRequestTaskCreator: CreateCompositeContestRequestTaskCreator, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<ContestIdResponseTaskCreator>>;
    public tasksCreatorBaseOlympiadIdBaseOlympiadOlympiadCreateCompositePost( idBaseOlympiad: number, createCompositeContestRequestTaskCreator: CreateCompositeContestRequestTaskCreator, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idBaseOlympiad === null || idBaseOlympiad === undefined )
        {
            throw new Error( 'Required parameter idBaseOlympiad was null or undefined when calling tasksCreatorBaseOlympiadIdBaseOlympiadOlympiadCreateCompositePost.' )
        }
        if ( createCompositeContestRequestTaskCreator === null || createCompositeContestRequestTaskCreator === undefined )
        {
            throw new Error( 'Required parameter createCompositeContestRequestTaskCreator was null or undefined when calling tasksCreatorBaseOlympiadIdBaseOlympiadOlympiadCreateCompositePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<ContestIdResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/base_olympiad/${ encodeURIComponent( String( idBaseOlympiad ) ) }/olympiad/create_composite`,
            createCompositeContestRequestTaskCreator,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idBaseOlympiad ID of the base olympiad
     * @param createSimpleContestRequestTaskCreator
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorBaseOlympiadIdBaseOlympiadOlympiadCreateSimplePost( idBaseOlympiad: number, createSimpleContestRequestTaskCreator: CreateSimpleContestRequestTaskCreator, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<ContestIdResponseTaskCreator>;
    public tasksCreatorBaseOlympiadIdBaseOlympiadOlympiadCreateSimplePost( idBaseOlympiad: number, createSimpleContestRequestTaskCreator: CreateSimpleContestRequestTaskCreator, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<ContestIdResponseTaskCreator>>;
    public tasksCreatorBaseOlympiadIdBaseOlympiadOlympiadCreateSimplePost( idBaseOlympiad: number, createSimpleContestRequestTaskCreator: CreateSimpleContestRequestTaskCreator, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<ContestIdResponseTaskCreator>>;
    public tasksCreatorBaseOlympiadIdBaseOlympiadOlympiadCreateSimplePost( idBaseOlympiad: number, createSimpleContestRequestTaskCreator: CreateSimpleContestRequestTaskCreator, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idBaseOlympiad === null || idBaseOlympiad === undefined )
        {
            throw new Error( 'Required parameter idBaseOlympiad was null or undefined when calling tasksCreatorBaseOlympiadIdBaseOlympiadOlympiadCreateSimplePost.' )
        }
        if ( createSimpleContestRequestTaskCreator === null || createSimpleContestRequestTaskCreator === undefined )
        {
            throw new Error( 'Required parameter createSimpleContestRequestTaskCreator was null or undefined when calling tasksCreatorBaseOlympiadIdBaseOlympiadOlympiadCreateSimplePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<ContestIdResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/base_olympiad/${ encodeURIComponent( String( idBaseOlympiad ) ) }/olympiad/create_simple`,
            createSimpleContestRequestTaskCreator,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorContestContestIdRestrictionsGet( contestId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<ContestGroupRestrictionListAdmin>;
    public tasksCreatorContestContestIdRestrictionsGet( contestId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<ContestGroupRestrictionListAdmin>>;
    public tasksCreatorContestContestIdRestrictionsGet( contestId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<ContestGroupRestrictionListAdmin>>;
    public tasksCreatorContestContestIdRestrictionsGet( contestId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling tasksCreatorContestContestIdRestrictionsGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<ContestGroupRestrictionListAdmin>( `${ this.configuration.basePath }/tasks/creator/contest/${ encodeURIComponent( String( contestId ) ) }/restrictions`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param contestId Id of the contest
     * @param contestGroupRestrictionListAdmin
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorContestContestIdRestrictionsPut( contestId: number, contestGroupRestrictionListAdmin: ContestGroupRestrictionListAdmin, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksCreatorContestContestIdRestrictionsPut( contestId: number, contestGroupRestrictionListAdmin: ContestGroupRestrictionListAdmin, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksCreatorContestContestIdRestrictionsPut( contestId: number, contestGroupRestrictionListAdmin: ContestGroupRestrictionListAdmin, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksCreatorContestContestIdRestrictionsPut( contestId: number, contestGroupRestrictionListAdmin: ContestGroupRestrictionListAdmin, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( contestId === null || contestId === undefined )
        {
            throw new Error( 'Required parameter contestId was null or undefined when calling tasksCreatorContestContestIdRestrictionsPut.' )
        }
        if ( contestGroupRestrictionListAdmin === null || contestGroupRestrictionListAdmin === undefined )
        {
            throw new Error( 'Required parameter contestGroupRestrictionListAdmin was null or undefined when calling tasksCreatorContestContestIdRestrictionsPut.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.put<any>( `${ this.configuration.basePath }/tasks/creator/contest/${ encodeURIComponent( String( contestId ) ) }/restrictions`,
            contestGroupRestrictionListAdmin,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorContestIdContestVariantAllGet( idContest: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllVariantsResponseTaskCreator>;
    public tasksCreatorContestIdContestVariantAllGet( idContest: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllVariantsResponseTaskCreator>>;
    public tasksCreatorContestIdContestVariantAllGet( idContest: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllVariantsResponseTaskCreator>>;
    public tasksCreatorContestIdContestVariantAllGet( idContest: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksCreatorContestIdContestVariantAllGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<AllVariantsResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/contest/${ encodeURIComponent( String( idContest ) ) }/variant/all`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param createVariantRequestTaskCreator
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorContestIdContestVariantCreatePost( idContest: number, createVariantRequestTaskCreator: CreateVariantRequestTaskCreator, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<VariantIdResponseTaskCreator>;
    public tasksCreatorContestIdContestVariantCreatePost( idContest: number, createVariantRequestTaskCreator: CreateVariantRequestTaskCreator, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<VariantIdResponseTaskCreator>>;
    public tasksCreatorContestIdContestVariantCreatePost( idContest: number, createVariantRequestTaskCreator: CreateVariantRequestTaskCreator, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<VariantIdResponseTaskCreator>>;
    public tasksCreatorContestIdContestVariantCreatePost( idContest: number, createVariantRequestTaskCreator: CreateVariantRequestTaskCreator, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksCreatorContestIdContestVariantCreatePost.' )
        }
        if ( createVariantRequestTaskCreator === null || createVariantRequestTaskCreator === undefined )
        {
            throw new Error( 'Required parameter createVariantRequestTaskCreator was null or undefined when calling tasksCreatorContestIdContestVariantCreatePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<VariantIdResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/contest/${ encodeURIComponent( String( idContest ) ) }/variant/create`,
            createVariantRequestTaskCreator,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param idVariant ID of the variant
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorContestIdContestVariantIdVariantTaskAllGet( idContest: number, idVariant: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllTasksResponseTaskCreator>;
    public tasksCreatorContestIdContestVariantIdVariantTaskAllGet( idContest: number, idVariant: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllTasksResponseTaskCreator>>;
    public tasksCreatorContestIdContestVariantIdVariantTaskAllGet( idContest: number, idVariant: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllTasksResponseTaskCreator>>;
    public tasksCreatorContestIdContestVariantIdVariantTaskAllGet( idContest: number, idVariant: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksCreatorContestIdContestVariantIdVariantTaskAllGet.' )
        }
        if ( idVariant === null || idVariant === undefined )
        {
            throw new Error( 'Required parameter idVariant was null or undefined when calling tasksCreatorContestIdContestVariantIdVariantTaskAllGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<AllTasksResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( idVariant ) ) }/task/all`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param idVariant ID of the variant
     * @param createMultipleRequestTaskCreator
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorContestIdContestVariantIdVariantTaskCreateMultiplePost( idContest: number, idVariant: number, createMultipleRequestTaskCreator: CreateMultipleRequestTaskCreator, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<TaskIdResponseTaskCreator>;
    public tasksCreatorContestIdContestVariantIdVariantTaskCreateMultiplePost( idContest: number, idVariant: number, createMultipleRequestTaskCreator: CreateMultipleRequestTaskCreator, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<TaskIdResponseTaskCreator>>;
    public tasksCreatorContestIdContestVariantIdVariantTaskCreateMultiplePost( idContest: number, idVariant: number, createMultipleRequestTaskCreator: CreateMultipleRequestTaskCreator, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<TaskIdResponseTaskCreator>>;
    public tasksCreatorContestIdContestVariantIdVariantTaskCreateMultiplePost( idContest: number, idVariant: number, createMultipleRequestTaskCreator: CreateMultipleRequestTaskCreator, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksCreatorContestIdContestVariantIdVariantTaskCreateMultiplePost.' )
        }
        if ( idVariant === null || idVariant === undefined )
        {
            throw new Error( 'Required parameter idVariant was null or undefined when calling tasksCreatorContestIdContestVariantIdVariantTaskCreateMultiplePost.' )
        }
        if ( createMultipleRequestTaskCreator === null || createMultipleRequestTaskCreator === undefined )
        {
            throw new Error( 'Required parameter createMultipleRequestTaskCreator was null or undefined when calling tasksCreatorContestIdContestVariantIdVariantTaskCreateMultiplePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<TaskIdResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( idVariant ) ) }/task/create_multiple`,
            createMultipleRequestTaskCreator,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param idVariant ID of the variant
     * @param createPlainRequestTaskCreator
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorContestIdContestVariantIdVariantTaskCreatePlainPost( idContest: number, idVariant: number, createPlainRequestTaskCreator: CreatePlainRequestTaskCreator, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<TaskIdResponseTaskCreator>;
    public tasksCreatorContestIdContestVariantIdVariantTaskCreatePlainPost( idContest: number, idVariant: number, createPlainRequestTaskCreator: CreatePlainRequestTaskCreator, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<TaskIdResponseTaskCreator>>;
    public tasksCreatorContestIdContestVariantIdVariantTaskCreatePlainPost( idContest: number, idVariant: number, createPlainRequestTaskCreator: CreatePlainRequestTaskCreator, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<TaskIdResponseTaskCreator>>;
    public tasksCreatorContestIdContestVariantIdVariantTaskCreatePlainPost( idContest: number, idVariant: number, createPlainRequestTaskCreator: CreatePlainRequestTaskCreator, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksCreatorContestIdContestVariantIdVariantTaskCreatePlainPost.' )
        }
        if ( idVariant === null || idVariant === undefined )
        {
            throw new Error( 'Required parameter idVariant was null or undefined when calling tasksCreatorContestIdContestVariantIdVariantTaskCreatePlainPost.' )
        }
        if ( createPlainRequestTaskCreator === null || createPlainRequestTaskCreator === undefined )
        {
            throw new Error( 'Required parameter createPlainRequestTaskCreator was null or undefined when calling tasksCreatorContestIdContestVariantIdVariantTaskCreatePlainPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<TaskIdResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( idVariant ) ) }/task/create_plain`,
            createPlainRequestTaskCreator,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param idVariant ID of the variant
     * @param createRangeRequestTaskCreator
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorContestIdContestVariantIdVariantTaskCreateRangePost( idContest: number, idVariant: number, createRangeRequestTaskCreator: CreateRangeRequestTaskCreator, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<TaskIdResponseTaskCreator>;
    public tasksCreatorContestIdContestVariantIdVariantTaskCreateRangePost( idContest: number, idVariant: number, createRangeRequestTaskCreator: CreateRangeRequestTaskCreator, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<TaskIdResponseTaskCreator>>;
    public tasksCreatorContestIdContestVariantIdVariantTaskCreateRangePost( idContest: number, idVariant: number, createRangeRequestTaskCreator: CreateRangeRequestTaskCreator, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<TaskIdResponseTaskCreator>>;
    public tasksCreatorContestIdContestVariantIdVariantTaskCreateRangePost( idContest: number, idVariant: number, createRangeRequestTaskCreator: CreateRangeRequestTaskCreator, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksCreatorContestIdContestVariantIdVariantTaskCreateRangePost.' )
        }
        if ( idVariant === null || idVariant === undefined )
        {
            throw new Error( 'Required parameter idVariant was null or undefined when calling tasksCreatorContestIdContestVariantIdVariantTaskCreateRangePost.' )
        }
        if ( createRangeRequestTaskCreator === null || createRangeRequestTaskCreator === undefined )
        {
            throw new Error( 'Required parameter createRangeRequestTaskCreator was null or undefined when calling tasksCreatorContestIdContestVariantIdVariantTaskCreateRangePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<TaskIdResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( idVariant ) ) }/task/create_range`,
            createRangeRequestTaskCreator,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param idVariant ID of the variant
     * @param idTask ID of the task
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorContestIdContestVariantIdVariantTaskIdTaskGet( idContest: number, idVariant: number, idTask: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<TaskResponseTaskCreator>;
    public tasksCreatorContestIdContestVariantIdVariantTaskIdTaskGet( idContest: number, idVariant: number, idTask: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<TaskResponseTaskCreator>>;
    public tasksCreatorContestIdContestVariantIdVariantTaskIdTaskGet( idContest: number, idVariant: number, idTask: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<TaskResponseTaskCreator>>;
    public tasksCreatorContestIdContestVariantIdVariantTaskIdTaskGet( idContest: number, idVariant: number, idTask: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksCreatorContestIdContestVariantIdVariantTaskIdTaskGet.' )
        }
        if ( idVariant === null || idVariant === undefined )
        {
            throw new Error( 'Required parameter idVariant was null or undefined when calling tasksCreatorContestIdContestVariantIdVariantTaskIdTaskGet.' )
        }
        if ( idTask === null || idTask === undefined )
        {
            throw new Error( 'Required parameter idTask was null or undefined when calling tasksCreatorContestIdContestVariantIdVariantTaskIdTaskGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<TaskResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( idVariant ) ) }/task/${ encodeURIComponent( String( idTask ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param idVariant ID of the variant
     * @param idTask ID of the task
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorContestIdContestVariantIdVariantTasksIdTaskImageGet( idContest: number, idVariant: number, idTask: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'image/jpeg', context?: HttpContext } ): Observable<Blob>;
    public tasksCreatorContestIdContestVariantIdVariantTasksIdTaskImageGet( idContest: number, idVariant: number, idTask: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'image/jpeg', context?: HttpContext } ): Observable<HttpResponse<Blob>>;
    public tasksCreatorContestIdContestVariantIdVariantTasksIdTaskImageGet( idContest: number, idVariant: number, idTask: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'image/jpeg', context?: HttpContext } ): Observable<HttpEvent<Blob>>;
    public tasksCreatorContestIdContestVariantIdVariantTasksIdTaskImageGet( idContest: number, idVariant: number, idTask: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'image/jpeg', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksCreatorContestIdContestVariantIdVariantTasksIdTaskImageGet.' )
        }
        if ( idVariant === null || idVariant === undefined )
        {
            throw new Error( 'Required parameter idVariant was null or undefined when calling tasksCreatorContestIdContestVariantIdVariantTasksIdTaskImageGet.' )
        }
        if ( idTask === null || idTask === undefined )
        {
            throw new Error( 'Required parameter idTask was null or undefined when calling tasksCreatorContestIdContestVariantIdVariantTasksIdTaskImageGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'image/jpeg'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        return this.httpClient.get( `${ this.configuration.basePath }/tasks/creator/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( idVariant ) ) }/tasks/${ encodeURIComponent( String( idTask ) ) }/image`,
            {
                context: localVarHttpContext,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param variantNum Num of the variant
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorContestIdContestVariantVariantNumGet( idContest: number, variantNum: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<VariantResponseTaskCreator>;
    public tasksCreatorContestIdContestVariantVariantNumGet( idContest: number, variantNum: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<VariantResponseTaskCreator>>;
    public tasksCreatorContestIdContestVariantVariantNumGet( idContest: number, variantNum: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<VariantResponseTaskCreator>>;
    public tasksCreatorContestIdContestVariantVariantNumGet( idContest: number, variantNum: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksCreatorContestIdContestVariantVariantNumGet.' )
        }
        if ( variantNum === null || variantNum === undefined )
        {
            throw new Error( 'Required parameter variantNum was null or undefined when calling tasksCreatorContestIdContestVariantVariantNumGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<VariantResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( variantNum ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idOlympiad ID of the olympiad
     * @param createStageRequestTaskCreator
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorOlympiadIdOlympiadStageCreatePost( idOlympiad: number, createStageRequestTaskCreator: CreateStageRequestTaskCreator, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<StageIdResponseTaskCreator>;
    public tasksCreatorOlympiadIdOlympiadStageCreatePost( idOlympiad: number, createStageRequestTaskCreator: CreateStageRequestTaskCreator, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<StageIdResponseTaskCreator>>;
    public tasksCreatorOlympiadIdOlympiadStageCreatePost( idOlympiad: number, createStageRequestTaskCreator: CreateStageRequestTaskCreator, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<StageIdResponseTaskCreator>>;
    public tasksCreatorOlympiadIdOlympiadStageCreatePost( idOlympiad: number, createStageRequestTaskCreator: CreateStageRequestTaskCreator, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksCreatorOlympiadIdOlympiadStageCreatePost.' )
        }
        if ( createStageRequestTaskCreator === null || createStageRequestTaskCreator === undefined )
        {
            throw new Error( 'Required parameter createStageRequestTaskCreator was null or undefined when calling tasksCreatorOlympiadIdOlympiadStageCreatePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<StageIdResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/create`,
            createStageRequestTaskCreator,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idOlympiad ID of the olympiad
     * @param idStage ID of the stage
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksCreatorOlympiadIdOlympiadStageIdStageContestAllGet( idOlympiad: number, idStage: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllOlympiadsResponseTaskCreator>;
    public tasksCreatorOlympiadIdOlympiadStageIdStageContestAllGet( idOlympiad: number, idStage: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllOlympiadsResponseTaskCreator>>;
    public tasksCreatorOlympiadIdOlympiadStageIdStageContestAllGet( idOlympiad: number, idStage: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllOlympiadsResponseTaskCreator>>;
    public tasksCreatorOlympiadIdOlympiadStageIdStageContestAllGet( idOlympiad: number, idStage: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksCreatorOlympiadIdOlympiadStageIdStageContestAllGet.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling tasksCreatorOlympiadIdOlympiadStageIdStageContestAllGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<AllOlympiadsResponseTaskCreator>( `${ this.configuration.basePath }/tasks/creator/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/all`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idBaseOlympiad ID of the contest
     * @param updateTargetClassesOfContestRequestTaskEditor
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorBaseOlympiadIdBaseOlympiadAddTargetClassesPost( idBaseOlympiad: number, updateTargetClassesOfContestRequestTaskEditor: UpdateTargetClassesOfContestRequestTaskEditor, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorBaseOlympiadIdBaseOlympiadAddTargetClassesPost( idBaseOlympiad: number, updateTargetClassesOfContestRequestTaskEditor: UpdateTargetClassesOfContestRequestTaskEditor, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadAddTargetClassesPost( idBaseOlympiad: number, updateTargetClassesOfContestRequestTaskEditor: UpdateTargetClassesOfContestRequestTaskEditor, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadAddTargetClassesPost( idBaseOlympiad: number, updateTargetClassesOfContestRequestTaskEditor: UpdateTargetClassesOfContestRequestTaskEditor, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idBaseOlympiad === null || idBaseOlympiad === undefined )
        {
            throw new Error( 'Required parameter idBaseOlympiad was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadAddTargetClassesPost.' )
        }
        if ( updateTargetClassesOfContestRequestTaskEditor === null || updateTargetClassesOfContestRequestTaskEditor === undefined )
        {
            throw new Error( 'Required parameter updateTargetClassesOfContestRequestTaskEditor was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadAddTargetClassesPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/editor/base_olympiad/${ encodeURIComponent( String( idBaseOlympiad ) ) }/add_target_classes`,
            updateTargetClassesOfContestRequestTaskEditor,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idBaseOlympiad ID of the base olympiad
     * @param idOlympiad ID of the olympiad
     * @param updateContestRequestTaskEditor
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadPatch( idBaseOlympiad: number, idOlympiad: number, updateContestRequestTaskEditor: UpdateContestRequestTaskEditor, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<ContestResponseTaskCreator>;
    public tasksEditorBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadPatch( idBaseOlympiad: number, idOlympiad: number, updateContestRequestTaskEditor: UpdateContestRequestTaskEditor, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<ContestResponseTaskCreator>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadPatch( idBaseOlympiad: number, idOlympiad: number, updateContestRequestTaskEditor: UpdateContestRequestTaskEditor, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<ContestResponseTaskCreator>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadPatch( idBaseOlympiad: number, idOlympiad: number, updateContestRequestTaskEditor: UpdateContestRequestTaskEditor, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idBaseOlympiad === null || idBaseOlympiad === undefined )
        {
            throw new Error( 'Required parameter idBaseOlympiad was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadPatch.' )
        }
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadPatch.' )
        }
        if ( updateContestRequestTaskEditor === null || updateContestRequestTaskEditor === undefined )
        {
            throw new Error( 'Required parameter updateContestRequestTaskEditor was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadPatch.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.patch<ContestResponseTaskCreator>( `${ this.configuration.basePath }/tasks/editor/base_olympiad/${ encodeURIComponent( String( idBaseOlympiad ) ) }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }`,
            updateContestRequestTaskEditor,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idBaseOlympiad ID of the base olympiad
     * @param idOlympiad ID of the olympiad
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadRemovePost( idBaseOlympiad: number, idOlympiad: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadRemovePost( idBaseOlympiad: number, idOlympiad: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadRemovePost( idBaseOlympiad: number, idOlympiad: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadRemovePost( idBaseOlympiad: number, idOlympiad: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idBaseOlympiad === null || idBaseOlympiad === undefined )
        {
            throw new Error( 'Required parameter idBaseOlympiad was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadRemovePost.' )
        }
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadRemovePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/editor/base_olympiad/${ encodeURIComponent( String( idBaseOlympiad ) ) }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/remove`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idBaseOlympiad ID of the base olympiad
     * @param updateBaseOlympiadRequestTaskEditor
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorBaseOlympiadIdBaseOlympiadPatch( idBaseOlympiad: number, updateBaseOlympiadRequestTaskEditor: UpdateBaseOlympiadRequestTaskEditor, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<BaseOlympiadResponseTaskCreator>;
    public tasksEditorBaseOlympiadIdBaseOlympiadPatch( idBaseOlympiad: number, updateBaseOlympiadRequestTaskEditor: UpdateBaseOlympiadRequestTaskEditor, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<BaseOlympiadResponseTaskCreator>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadPatch( idBaseOlympiad: number, updateBaseOlympiadRequestTaskEditor: UpdateBaseOlympiadRequestTaskEditor, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<BaseOlympiadResponseTaskCreator>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadPatch( idBaseOlympiad: number, updateBaseOlympiadRequestTaskEditor: UpdateBaseOlympiadRequestTaskEditor, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idBaseOlympiad === null || idBaseOlympiad === undefined )
        {
            throw new Error( 'Required parameter idBaseOlympiad was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadPatch.' )
        }
        if ( updateBaseOlympiadRequestTaskEditor === null || updateBaseOlympiadRequestTaskEditor === undefined )
        {
            throw new Error( 'Required parameter updateBaseOlympiadRequestTaskEditor was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadPatch.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.patch<BaseOlympiadResponseTaskCreator>( `${ this.configuration.basePath }/tasks/editor/base_olympiad/${ encodeURIComponent( String( idBaseOlympiad ) ) }`,
            updateBaseOlympiadRequestTaskEditor,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idBaseOlympiad ID of the base olympiad
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorBaseOlympiadIdBaseOlympiadRemovePost( idBaseOlympiad: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorBaseOlympiadIdBaseOlympiadRemovePost( idBaseOlympiad: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadRemovePost( idBaseOlympiad: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadRemovePost( idBaseOlympiad: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idBaseOlympiad === null || idBaseOlympiad === undefined )
        {
            throw new Error( 'Required parameter idBaseOlympiad was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadRemovePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/editor/base_olympiad/${ encodeURIComponent( String( idBaseOlympiad ) ) }/remove`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idBaseOlympiad ID of the target class
     * @param updateTargetClassesOfContestRequestTaskEditor
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorBaseOlympiadIdBaseOlympiadRemoveTargetClassesPost( idBaseOlympiad: number, updateTargetClassesOfContestRequestTaskEditor: UpdateTargetClassesOfContestRequestTaskEditor, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorBaseOlympiadIdBaseOlympiadRemoveTargetClassesPost( idBaseOlympiad: number, updateTargetClassesOfContestRequestTaskEditor: UpdateTargetClassesOfContestRequestTaskEditor, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadRemoveTargetClassesPost( idBaseOlympiad: number, updateTargetClassesOfContestRequestTaskEditor: UpdateTargetClassesOfContestRequestTaskEditor, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadRemoveTargetClassesPost( idBaseOlympiad: number, updateTargetClassesOfContestRequestTaskEditor: UpdateTargetClassesOfContestRequestTaskEditor, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idBaseOlympiad === null || idBaseOlympiad === undefined )
        {
            throw new Error( 'Required parameter idBaseOlympiad was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadRemoveTargetClassesPost.' )
        }
        if ( updateTargetClassesOfContestRequestTaskEditor === null || updateTargetClassesOfContestRequestTaskEditor === undefined )
        {
            throw new Error( 'Required parameter updateTargetClassesOfContestRequestTaskEditor was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadRemoveTargetClassesPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/editor/base_olympiad/${ encodeURIComponent( String( idBaseOlympiad ) ) }/remove_target_classes`,
            updateTargetClassesOfContestRequestTaskEditor,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idBaseOlympiad Id of the olympiad
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorBaseOlympiadIdBaseOlympiadUploadCertificatePost( idBaseOlympiad: number, body: Blob, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorBaseOlympiadIdBaseOlympiadUploadCertificatePost( idBaseOlympiad: number, body: Blob, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadUploadCertificatePost( idBaseOlympiad: number, body: Blob, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorBaseOlympiadIdBaseOlympiadUploadCertificatePost( idBaseOlympiad: number, body: Blob, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idBaseOlympiad === null || idBaseOlympiad === undefined )
        {
            throw new Error( 'Required parameter idBaseOlympiad was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadUploadCertificatePost.' )
        }
        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling tasksEditorBaseOlympiadIdBaseOlympiadUploadCertificatePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/octet-stream'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/editor/base_olympiad/${ encodeURIComponent( String( idBaseOlympiad ) ) }/upload_certificate`,
            body,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param updateLocationOfContestRequestTaskEditor
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorContestIdContestAddLocationPost( idContest: number, updateLocationOfContestRequestTaskEditor: UpdateLocationOfContestRequestTaskEditor, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorContestIdContestAddLocationPost( idContest: number, updateLocationOfContestRequestTaskEditor: UpdateLocationOfContestRequestTaskEditor, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorContestIdContestAddLocationPost( idContest: number, updateLocationOfContestRequestTaskEditor: UpdateLocationOfContestRequestTaskEditor, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorContestIdContestAddLocationPost( idContest: number, updateLocationOfContestRequestTaskEditor: UpdateLocationOfContestRequestTaskEditor, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksEditorContestIdContestAddLocationPost.' )
        }
        if ( updateLocationOfContestRequestTaskEditor === null || updateLocationOfContestRequestTaskEditor === undefined )
        {
            throw new Error( 'Required parameter updateLocationOfContestRequestTaskEditor was null or undefined when calling tasksEditorContestIdContestAddLocationPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/editor/contest/${ encodeURIComponent( String( idContest ) ) }/add_location`,
            updateLocationOfContestRequestTaskEditor,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param updateLocationOfContestRequestTaskEditor
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorContestIdContestRemoveLocationPost( idContest: number, updateLocationOfContestRequestTaskEditor: UpdateLocationOfContestRequestTaskEditor, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorContestIdContestRemoveLocationPost( idContest: number, updateLocationOfContestRequestTaskEditor: UpdateLocationOfContestRequestTaskEditor, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorContestIdContestRemoveLocationPost( idContest: number, updateLocationOfContestRequestTaskEditor: UpdateLocationOfContestRequestTaskEditor, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorContestIdContestRemoveLocationPost( idContest: number, updateLocationOfContestRequestTaskEditor: UpdateLocationOfContestRequestTaskEditor, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksEditorContestIdContestRemoveLocationPost.' )
        }
        if ( updateLocationOfContestRequestTaskEditor === null || updateLocationOfContestRequestTaskEditor === undefined )
        {
            throw new Error( 'Required parameter updateLocationOfContestRequestTaskEditor was null or undefined when calling tasksEditorContestIdContestRemoveLocationPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/editor/contest/${ encodeURIComponent( String( idContest ) ) }/remove_location`,
            updateLocationOfContestRequestTaskEditor,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param idVariant ID of the variant
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorContestIdContestVariantIdVariantRemovePost( idContest: number, idVariant: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorContestIdContestVariantIdVariantRemovePost( idContest: number, idVariant: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorContestIdContestVariantIdVariantRemovePost( idContest: number, idVariant: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorContestIdContestVariantIdVariantRemovePost( idContest: number, idVariant: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksEditorContestIdContestVariantIdVariantRemovePost.' )
        }
        if ( idVariant === null || idVariant === undefined )
        {
            throw new Error( 'Required parameter idVariant was null or undefined when calling tasksEditorContestIdContestVariantIdVariantRemovePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/editor/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( idVariant ) ) }/remove`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param idVariant ID of the variant
     * @param idTask ID of the task
     * @param updateMultipleRequestTaskEditor
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorContestIdContestVariantIdVariantTaskIdTaskMultiplePatch( idContest: number, idVariant: number, idTask: number, updateMultipleRequestTaskEditor: UpdateMultipleRequestTaskEditor, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<TaskResponseTaskCreator>;
    public tasksEditorContestIdContestVariantIdVariantTaskIdTaskMultiplePatch( idContest: number, idVariant: number, idTask: number, updateMultipleRequestTaskEditor: UpdateMultipleRequestTaskEditor, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<TaskResponseTaskCreator>>;
    public tasksEditorContestIdContestVariantIdVariantTaskIdTaskMultiplePatch( idContest: number, idVariant: number, idTask: number, updateMultipleRequestTaskEditor: UpdateMultipleRequestTaskEditor, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<TaskResponseTaskCreator>>;
    public tasksEditorContestIdContestVariantIdVariantTaskIdTaskMultiplePatch( idContest: number, idVariant: number, idTask: number, updateMultipleRequestTaskEditor: UpdateMultipleRequestTaskEditor, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksEditorContestIdContestVariantIdVariantTaskIdTaskMultiplePatch.' )
        }
        if ( idVariant === null || idVariant === undefined )
        {
            throw new Error( 'Required parameter idVariant was null or undefined when calling tasksEditorContestIdContestVariantIdVariantTaskIdTaskMultiplePatch.' )
        }
        if ( idTask === null || idTask === undefined )
        {
            throw new Error( 'Required parameter idTask was null or undefined when calling tasksEditorContestIdContestVariantIdVariantTaskIdTaskMultiplePatch.' )
        }
        if ( updateMultipleRequestTaskEditor === null || updateMultipleRequestTaskEditor === undefined )
        {
            throw new Error( 'Required parameter updateMultipleRequestTaskEditor was null or undefined when calling tasksEditorContestIdContestVariantIdVariantTaskIdTaskMultiplePatch.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.patch<TaskResponseTaskCreator>( `${ this.configuration.basePath }/tasks/editor/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( idVariant ) ) }/task/${ encodeURIComponent( String( idTask ) ) }/multiple`,
            updateMultipleRequestTaskEditor,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param idVariant ID of the variant
     * @param idTask ID of the task
     * @param updatePlainRequestTaskEditor
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorContestIdContestVariantIdVariantTaskIdTaskPlainPatch( idContest: number, idVariant: number, idTask: number, updatePlainRequestTaskEditor: UpdatePlainRequestTaskEditor, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<TaskResponseTaskCreator>;
    public tasksEditorContestIdContestVariantIdVariantTaskIdTaskPlainPatch( idContest: number, idVariant: number, idTask: number, updatePlainRequestTaskEditor: UpdatePlainRequestTaskEditor, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<TaskResponseTaskCreator>>;
    public tasksEditorContestIdContestVariantIdVariantTaskIdTaskPlainPatch( idContest: number, idVariant: number, idTask: number, updatePlainRequestTaskEditor: UpdatePlainRequestTaskEditor, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<TaskResponseTaskCreator>>;
    public tasksEditorContestIdContestVariantIdVariantTaskIdTaskPlainPatch( idContest: number, idVariant: number, idTask: number, updatePlainRequestTaskEditor: UpdatePlainRequestTaskEditor, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksEditorContestIdContestVariantIdVariantTaskIdTaskPlainPatch.' )
        }
        if ( idVariant === null || idVariant === undefined )
        {
            throw new Error( 'Required parameter idVariant was null or undefined when calling tasksEditorContestIdContestVariantIdVariantTaskIdTaskPlainPatch.' )
        }
        if ( idTask === null || idTask === undefined )
        {
            throw new Error( 'Required parameter idTask was null or undefined when calling tasksEditorContestIdContestVariantIdVariantTaskIdTaskPlainPatch.' )
        }
        if ( updatePlainRequestTaskEditor === null || updatePlainRequestTaskEditor === undefined )
        {
            throw new Error( 'Required parameter updatePlainRequestTaskEditor was null or undefined when calling tasksEditorContestIdContestVariantIdVariantTaskIdTaskPlainPatch.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.patch<TaskResponseTaskCreator>( `${ this.configuration.basePath }/tasks/editor/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( idVariant ) ) }/task/${ encodeURIComponent( String( idTask ) ) }/plain`,
            updatePlainRequestTaskEditor,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param idVariant ID of the variant
     * @param idTask ID of the task
     * @param updateRangeRequestTaskEditor
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorContestIdContestVariantIdVariantTaskIdTaskRangePatch( idContest: number, idVariant: number, idTask: number, updateRangeRequestTaskEditor: UpdateRangeRequestTaskEditor, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<TaskResponseTaskCreator>;
    public tasksEditorContestIdContestVariantIdVariantTaskIdTaskRangePatch( idContest: number, idVariant: number, idTask: number, updateRangeRequestTaskEditor: UpdateRangeRequestTaskEditor, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<TaskResponseTaskCreator>>;
    public tasksEditorContestIdContestVariantIdVariantTaskIdTaskRangePatch( idContest: number, idVariant: number, idTask: number, updateRangeRequestTaskEditor: UpdateRangeRequestTaskEditor, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<TaskResponseTaskCreator>>;
    public tasksEditorContestIdContestVariantIdVariantTaskIdTaskRangePatch( idContest: number, idVariant: number, idTask: number, updateRangeRequestTaskEditor: UpdateRangeRequestTaskEditor, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksEditorContestIdContestVariantIdVariantTaskIdTaskRangePatch.' )
        }
        if ( idVariant === null || idVariant === undefined )
        {
            throw new Error( 'Required parameter idVariant was null or undefined when calling tasksEditorContestIdContestVariantIdVariantTaskIdTaskRangePatch.' )
        }
        if ( idTask === null || idTask === undefined )
        {
            throw new Error( 'Required parameter idTask was null or undefined when calling tasksEditorContestIdContestVariantIdVariantTaskIdTaskRangePatch.' )
        }
        if ( updateRangeRequestTaskEditor === null || updateRangeRequestTaskEditor === undefined )
        {
            throw new Error( 'Required parameter updateRangeRequestTaskEditor was null or undefined when calling tasksEditorContestIdContestVariantIdVariantTaskIdTaskRangePatch.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.patch<TaskResponseTaskCreator>( `${ this.configuration.basePath }/tasks/editor/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( idVariant ) ) }/task/${ encodeURIComponent( String( idTask ) ) }/range`,
            updateRangeRequestTaskEditor,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param idVariant ID of the variant
     * @param idTask ID of the task
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorContestIdContestVariantIdVariantTaskIdTaskRemovePost( idContest: number, idVariant: number, idTask: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorContestIdContestVariantIdVariantTaskIdTaskRemovePost( idContest: number, idVariant: number, idTask: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorContestIdContestVariantIdVariantTaskIdTaskRemovePost( idContest: number, idVariant: number, idTask: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorContestIdContestVariantIdVariantTaskIdTaskRemovePost( idContest: number, idVariant: number, idTask: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksEditorContestIdContestVariantIdVariantTaskIdTaskRemovePost.' )
        }
        if ( idVariant === null || idVariant === undefined )
        {
            throw new Error( 'Required parameter idVariant was null or undefined when calling tasksEditorContestIdContestVariantIdVariantTaskIdTaskRemovePost.' )
        }
        if ( idTask === null || idTask === undefined )
        {
            throw new Error( 'Required parameter idTask was null or undefined when calling tasksEditorContestIdContestVariantIdVariantTaskIdTaskRemovePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/editor/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( idVariant ) ) }/task/${ encodeURIComponent( String( idTask ) ) }/remove`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param idVariant ID of the variant
     * @param idTask ID of the task
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorContestIdContestVariantIdVariantTaskIdTaskUploadImagePost( idContest: number, idVariant: number, idTask: number, body: Blob, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorContestIdContestVariantIdVariantTaskIdTaskUploadImagePost( idContest: number, idVariant: number, idTask: number, body: Blob, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorContestIdContestVariantIdVariantTaskIdTaskUploadImagePost( idContest: number, idVariant: number, idTask: number, body: Blob, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorContestIdContestVariantIdVariantTaskIdTaskUploadImagePost( idContest: number, idVariant: number, idTask: number, body: Blob, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksEditorContestIdContestVariantIdVariantTaskIdTaskUploadImagePost.' )
        }
        if ( idVariant === null || idVariant === undefined )
        {
            throw new Error( 'Required parameter idVariant was null or undefined when calling tasksEditorContestIdContestVariantIdVariantTaskIdTaskUploadImagePost.' )
        }
        if ( idTask === null || idTask === undefined )
        {
            throw new Error( 'Required parameter idTask was null or undefined when calling tasksEditorContestIdContestVariantIdVariantTaskIdTaskUploadImagePost.' )
        }
        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling tasksEditorContestIdContestVariantIdVariantTaskIdTaskUploadImagePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/octet-stream'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/editor/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( idVariant ) ) }/task/${ encodeURIComponent( String( idTask ) ) }/upload_image`,
            body,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param variantNum Num of the variant
     * @param updateVariantRequestTaskEditor
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorContestIdContestVariantVariantNumPatch( idContest: number, variantNum: number, updateVariantRequestTaskEditor: UpdateVariantRequestTaskEditor, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<VariantResponseTaskCreator>;
    public tasksEditorContestIdContestVariantVariantNumPatch( idContest: number, variantNum: number, updateVariantRequestTaskEditor: UpdateVariantRequestTaskEditor, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<VariantResponseTaskCreator>>;
    public tasksEditorContestIdContestVariantVariantNumPatch( idContest: number, variantNum: number, updateVariantRequestTaskEditor: UpdateVariantRequestTaskEditor, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<VariantResponseTaskCreator>>;
    public tasksEditorContestIdContestVariantVariantNumPatch( idContest: number, variantNum: number, updateVariantRequestTaskEditor: UpdateVariantRequestTaskEditor, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksEditorContestIdContestVariantVariantNumPatch.' )
        }
        if ( variantNum === null || variantNum === undefined )
        {
            throw new Error( 'Required parameter variantNum was null or undefined when calling tasksEditorContestIdContestVariantVariantNumPatch.' )
        }
        if ( updateVariantRequestTaskEditor === null || updateVariantRequestTaskEditor === undefined )
        {
            throw new Error( 'Required parameter updateVariantRequestTaskEditor was null or undefined when calling tasksEditorContestIdContestVariantVariantNumPatch.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.patch<VariantResponseTaskCreator>( `${ this.configuration.basePath }/tasks/editor/contest/${ encodeURIComponent( String( idContest ) ) }/variant/${ encodeURIComponent( String( variantNum ) ) }`,
            updateVariantRequestTaskEditor,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idOlympiad ID of the olympiad
     * @param idStage ID of the stage
     * @param idContest ID of the contest
     * @param updatePreviousContestRequestTaskEditor
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestAddPreviousPatch( idOlympiad: number, idStage: number, idContest: number, updatePreviousContestRequestTaskEditor: UpdatePreviousContestRequestTaskEditor, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestAddPreviousPatch( idOlympiad: number, idStage: number, idContest: number, updatePreviousContestRequestTaskEditor: UpdatePreviousContestRequestTaskEditor, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestAddPreviousPatch( idOlympiad: number, idStage: number, idContest: number, updatePreviousContestRequestTaskEditor: UpdatePreviousContestRequestTaskEditor, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestAddPreviousPatch( idOlympiad: number, idStage: number, idContest: number, updatePreviousContestRequestTaskEditor: UpdatePreviousContestRequestTaskEditor, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestAddPreviousPatch.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestAddPreviousPatch.' )
        }
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestAddPreviousPatch.' )
        }
        if ( updatePreviousContestRequestTaskEditor === null || updatePreviousContestRequestTaskEditor === undefined )
        {
            throw new Error( 'Required parameter updatePreviousContestRequestTaskEditor was null or undefined when calling tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestAddPreviousPatch.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.patch<any>( `${ this.configuration.basePath }/tasks/editor/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/add_previous`,
            updatePreviousContestRequestTaskEditor,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idOlympiad ID of the olympiad
     * @param idStage ID of the stage
     * @param idContest ID of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestRemovePost( idOlympiad: number, idStage: number, idContest: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestRemovePost( idOlympiad: number, idStage: number, idContest: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestRemovePost( idOlympiad: number, idStage: number, idContest: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestRemovePost( idOlympiad: number, idStage: number, idContest: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestRemovePost.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestRemovePost.' )
        }
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksEditorOlympiadIdOlympiadStageIdStageContestIdContestRemovePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/editor/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }/remove`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idOlympiad ID of the olympiad
     * @param idStage ID of the stage
     * @param updateStageRequestTaskEditor
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorOlympiadIdOlympiadStageIdStagePatch( idOlympiad: number, idStage: number, updateStageRequestTaskEditor: UpdateStageRequestTaskEditor, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<StageResponseTaskCreator>;
    public tasksEditorOlympiadIdOlympiadStageIdStagePatch( idOlympiad: number, idStage: number, updateStageRequestTaskEditor: UpdateStageRequestTaskEditor, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<StageResponseTaskCreator>>;
    public tasksEditorOlympiadIdOlympiadStageIdStagePatch( idOlympiad: number, idStage: number, updateStageRequestTaskEditor: UpdateStageRequestTaskEditor, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<StageResponseTaskCreator>>;
    public tasksEditorOlympiadIdOlympiadStageIdStagePatch( idOlympiad: number, idStage: number, updateStageRequestTaskEditor: UpdateStageRequestTaskEditor, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksEditorOlympiadIdOlympiadStageIdStagePatch.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling tasksEditorOlympiadIdOlympiadStageIdStagePatch.' )
        }
        if ( updateStageRequestTaskEditor === null || updateStageRequestTaskEditor === undefined )
        {
            throw new Error( 'Required parameter updateStageRequestTaskEditor was null or undefined when calling tasksEditorOlympiadIdOlympiadStageIdStagePatch.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.patch<StageResponseTaskCreator>( `${ this.configuration.basePath }/tasks/editor/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }`,
            updateStageRequestTaskEditor,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idOlympiad ID of the olympiad
     * @param idStage ID of the stage
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksEditorOlympiadIdOlympiadStageIdStageRemovePost( idOlympiad: number, idStage: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksEditorOlympiadIdOlympiadStageIdStageRemovePost( idOlympiad: number, idStage: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksEditorOlympiadIdOlympiadStageIdStageRemovePost( idOlympiad: number, idStage: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksEditorOlympiadIdOlympiadStageIdStageRemovePost( idOlympiad: number, idStage: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksEditorOlympiadIdOlympiadStageIdStageRemovePost.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling tasksEditorOlympiadIdOlympiadStageIdStageRemovePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/editor/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/remove`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksParticipantContestIdContestCertificateSelfGet( idContest: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/pdf', context?: HttpContext } ): Observable<Blob>;
    public tasksParticipantContestIdContestCertificateSelfGet( idContest: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/pdf', context?: HttpContext } ): Observable<HttpResponse<Blob>>;
    public tasksParticipantContestIdContestCertificateSelfGet( idContest: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/pdf', context?: HttpContext } ): Observable<HttpEvent<Blob>>;
    public tasksParticipantContestIdContestCertificateSelfGet( idContest: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/pdf', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksParticipantContestIdContestCertificateSelfGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/pdf'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        return this.httpClient.get( `${ this.configuration.basePath }/tasks/participant/contest/${ encodeURIComponent( String( idContest ) ) }/certificate/self`,
            {
                context: localVarHttpContext,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param enrollRequestTaskParticipant
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksParticipantContestIdContestChangeLocationPost( idContest: number, enrollRequestTaskParticipant: EnrollRequestTaskParticipant, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksParticipantContestIdContestChangeLocationPost( idContest: number, enrollRequestTaskParticipant: EnrollRequestTaskParticipant, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksParticipantContestIdContestChangeLocationPost( idContest: number, enrollRequestTaskParticipant: EnrollRequestTaskParticipant, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksParticipantContestIdContestChangeLocationPost( idContest: number, enrollRequestTaskParticipant: EnrollRequestTaskParticipant, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksParticipantContestIdContestChangeLocationPost.' )
        }
        if ( enrollRequestTaskParticipant === null || enrollRequestTaskParticipant === undefined )
        {
            throw new Error( 'Required parameter enrollRequestTaskParticipant was null or undefined when calling tasksParticipantContestIdContestChangeLocationPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/participant/contest/${ encodeURIComponent( String( idContest ) ) }/change_location`,
            enrollRequestTaskParticipant,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param changeSupervisorRequestTaskParticipant
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksParticipantContestIdContestChangeSupervisorPost( idContest: number, changeSupervisorRequestTaskParticipant: ChangeSupervisorRequestTaskParticipant, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksParticipantContestIdContestChangeSupervisorPost( idContest: number, changeSupervisorRequestTaskParticipant: ChangeSupervisorRequestTaskParticipant, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksParticipantContestIdContestChangeSupervisorPost( idContest: number, changeSupervisorRequestTaskParticipant: ChangeSupervisorRequestTaskParticipant, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksParticipantContestIdContestChangeSupervisorPost( idContest: number, changeSupervisorRequestTaskParticipant: ChangeSupervisorRequestTaskParticipant, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksParticipantContestIdContestChangeSupervisorPost.' )
        }
        if ( changeSupervisorRequestTaskParticipant === null || changeSupervisorRequestTaskParticipant === undefined )
        {
            throw new Error( 'Required parameter changeSupervisorRequestTaskParticipant was null or undefined when calling tasksParticipantContestIdContestChangeSupervisorPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/participant/contest/${ encodeURIComponent( String( idContest ) ) }/change_supervisor`,
            changeSupervisorRequestTaskParticipant,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param enrollRequestTaskParticipant
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksParticipantContestIdContestEnrollPost( idContest: number, enrollRequestTaskParticipant: EnrollRequestTaskParticipant, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public tasksParticipantContestIdContestEnrollPost( idContest: number, enrollRequestTaskParticipant: EnrollRequestTaskParticipant, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public tasksParticipantContestIdContestEnrollPost( idContest: number, enrollRequestTaskParticipant: EnrollRequestTaskParticipant, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public tasksParticipantContestIdContestEnrollPost( idContest: number, enrollRequestTaskParticipant: EnrollRequestTaskParticipant, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksParticipantContestIdContestEnrollPost.' )
        }
        if ( enrollRequestTaskParticipant === null || enrollRequestTaskParticipant === undefined )
        {
            throw new Error( 'Required parameter enrollRequestTaskParticipant was null or undefined when calling tasksParticipantContestIdContestEnrollPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/tasks/participant/contest/${ encodeURIComponent( String( idContest ) ) }/enroll`,
            enrollRequestTaskParticipant,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest ID of the contest
     * @param idTask ID of the task
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksParticipantContestIdContestTasksIdTaskImageSelfGet( idContest: number, idTask: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'image/jpeg', context?: HttpContext } ): Observable<Blob>;
    public tasksParticipantContestIdContestTasksIdTaskImageSelfGet( idContest: number, idTask: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'image/jpeg', context?: HttpContext } ): Observable<HttpResponse<Blob>>;
    public tasksParticipantContestIdContestTasksIdTaskImageSelfGet( idContest: number, idTask: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'image/jpeg', context?: HttpContext } ): Observable<HttpEvent<Blob>>;
    public tasksParticipantContestIdContestTasksIdTaskImageSelfGet( idContest: number, idTask: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'image/jpeg', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksParticipantContestIdContestTasksIdTaskImageSelfGet.' )
        }
        if ( idTask === null || idTask === undefined )
        {
            throw new Error( 'Required parameter idTask was null or undefined when calling tasksParticipantContestIdContestTasksIdTaskImageSelfGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'image/jpeg'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        return this.httpClient.get( `${ this.configuration.basePath }/tasks/participant/contest/${ encodeURIComponent( String( idContest ) ) }/tasks/${ encodeURIComponent( String( idTask ) ) }/image/self`,
            {
                context: localVarHttpContext,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksParticipantContestIdContestTasksSelfGet( idContest: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllTaskResponseTaskParticipant>;
    public tasksParticipantContestIdContestTasksSelfGet( idContest: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllTaskResponseTaskParticipant>>;
    public tasksParticipantContestIdContestTasksSelfGet( idContest: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllTaskResponseTaskParticipant>>;
    public tasksParticipantContestIdContestTasksSelfGet( idContest: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksParticipantContestIdContestTasksSelfGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<AllTaskResponseTaskParticipant>( `${ this.configuration.basePath }/tasks/participant/contest/${ encodeURIComponent( String( idContest ) ) }/tasks/self`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idContest Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksParticipantContestIdContestVariantSelfGet( idContest: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<VariantWithCompletedTasksCountTaskParticipant>;
    public tasksParticipantContestIdContestVariantSelfGet( idContest: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<VariantWithCompletedTasksCountTaskParticipant>>;
    public tasksParticipantContestIdContestVariantSelfGet( idContest: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<VariantWithCompletedTasksCountTaskParticipant>>;
    public tasksParticipantContestIdContestVariantSelfGet( idContest: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksParticipantContestIdContestVariantSelfGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<VariantWithCompletedTasksCountTaskParticipant>( `${ this.configuration.basePath }/tasks/participant/contest/${ encodeURIComponent( String( idContest ) ) }/variant/self`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param visibility
     * @param offset
     * @param limit
     * @param baseContestId
     * @param locationId
     * @param academicYear
     * @param endDate
     * @param targetClasses
     * @param onlyCount
     * @param compositeType
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksParticipantOlympiadAllGet( visibility?: boolean, offset?: number, limit?: number, baseContestId?: number, locationId?: number, academicYear?: number, endDate?: string, targetClasses?: '5' | '6' | '7' | '8' | '9' | '10' | '11' | 'student', onlyCount?: boolean, compositeType?: 'SimpleContest' | 'CompositeContest', observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<FilterSimpleContestResponseTaskParticipant>;
    public tasksParticipantOlympiadAllGet( visibility?: boolean, offset?: number, limit?: number, baseContestId?: number, locationId?: number, academicYear?: number, endDate?: string, targetClasses?: '5' | '6' | '7' | '8' | '9' | '10' | '11' | 'student', onlyCount?: boolean, compositeType?: 'SimpleContest' | 'CompositeContest', observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<FilterSimpleContestResponseTaskParticipant>>;
    public tasksParticipantOlympiadAllGet( visibility?: boolean, offset?: number, limit?: number, baseContestId?: number, locationId?: number, academicYear?: number, endDate?: string, targetClasses?: '5' | '6' | '7' | '8' | '9' | '10' | '11' | 'student', onlyCount?: boolean, compositeType?: 'SimpleContest' | 'CompositeContest', observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<FilterSimpleContestResponseTaskParticipant>>;
    public tasksParticipantOlympiadAllGet( visibility?: boolean, offset?: number, limit?: number, baseContestId?: number, locationId?: number, academicYear?: number, endDate?: string, targetClasses?: '5' | '6' | '7' | '8' | '9' | '10' | '11' | 'student', onlyCount?: boolean, compositeType?: 'SimpleContest' | 'CompositeContest', observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {

        let localVarQueryParameters = new HttpParams( { encoder: this.encoder } )
        if ( visibility !== undefined && visibility !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> visibility, 'visibility' )
        }
        if ( offset !== undefined && offset !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> offset, 'offset' )
        }
        if ( limit !== undefined && limit !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> limit, 'limit' )
        }
        if ( baseContestId !== undefined && baseContestId !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> baseContestId, 'base_contest_id' )
        }
        if ( locationId !== undefined && locationId !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> locationId, 'location_id' )
        }
        if ( academicYear !== undefined && academicYear !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> academicYear, 'academic_year' )
        }
        if ( endDate !== undefined && endDate !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> endDate, 'end_date' )
        }
        if ( targetClasses !== undefined && targetClasses !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> targetClasses, 'target_classes' )
        }
        if ( onlyCount !== undefined && onlyCount !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> onlyCount, 'only_count' )
        }
        if ( compositeType !== undefined && compositeType !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> compositeType, 'composite_type' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<FilterSimpleContestResponseTaskParticipant>( `${ this.configuration.basePath }/tasks/participant/olympiad/all`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idOlympiad Id of the olympiad
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksParticipantOlympiadIdOlympiadGet( idOlympiad: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<Contest>;
    public tasksParticipantOlympiadIdOlympiadGet( idOlympiad: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<Contest>>;
    public tasksParticipantOlympiadIdOlympiadGet( idOlympiad: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<Contest>>;
    public tasksParticipantOlympiadIdOlympiadGet( idOlympiad: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksParticipantOlympiadIdOlympiadGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<Contest>( `${ this.configuration.basePath }/tasks/participant/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksParticipantOlympiadIdOlympiadStageIdStageContestAllGet( idOlympiad: number, idStage: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllOlympiadsResponseTaskUnauthorized>;
    public tasksParticipantOlympiadIdOlympiadStageIdStageContestAllGet( idOlympiad: number, idStage: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllOlympiadsResponseTaskUnauthorized>>;
    public tasksParticipantOlympiadIdOlympiadStageIdStageContestAllGet( idOlympiad: number, idStage: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllOlympiadsResponseTaskUnauthorized>>;
    public tasksParticipantOlympiadIdOlympiadStageIdStageContestAllGet( idOlympiad: number, idStage: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksParticipantOlympiadIdOlympiadStageIdStageContestAllGet.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling tasksParticipantOlympiadIdOlympiadStageIdStageContestAllGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<AllOlympiadsResponseTaskUnauthorized>( `${ this.configuration.basePath }/tasks/participant/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/all`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param idContest Id of the contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksParticipantOlympiadIdOlympiadStageIdStageContestIdContestGet( idOlympiad: number, idStage: number, idContest: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<Contest>;
    public tasksParticipantOlympiadIdOlympiadStageIdStageContestIdContestGet( idOlympiad: number, idStage: number, idContest: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<Contest>>;
    public tasksParticipantOlympiadIdOlympiadStageIdStageContestIdContestGet( idOlympiad: number, idStage: number, idContest: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<Contest>>;
    public tasksParticipantOlympiadIdOlympiadStageIdStageContestIdContestGet( idOlympiad: number, idStage: number, idContest: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksParticipantOlympiadIdOlympiadStageIdStageContestIdContestGet.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling tasksParticipantOlympiadIdOlympiadStageIdStageContestIdContestGet.' )
        }
        if ( idContest === null || idContest === undefined )
        {
            throw new Error( 'Required parameter idContest was null or undefined when calling tasksParticipantOlympiadIdOlympiadStageIdStageContestIdContestGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<Contest>( `${ this.configuration.basePath }/tasks/participant/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }/contest/${ encodeURIComponent( String( idContest ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksUnauthorizedBaseOlympiadAllGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllBaseContestResponseTaskUnauthorized>;
    public tasksUnauthorizedBaseOlympiadAllGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllBaseContestResponseTaskUnauthorized>>;
    public tasksUnauthorizedBaseOlympiadAllGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllBaseContestResponseTaskUnauthorized>>;
    public tasksUnauthorizedBaseOlympiadAllGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<AllBaseContestResponseTaskUnauthorized>( `${ this.configuration.basePath }/tasks/unauthorized/base_olympiad/all`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idBaseOlympiad Id of the base contest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksUnauthorizedBaseOlympiadIdBaseOlympiadGet( idBaseOlympiad: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<BaseContest>;
    public tasksUnauthorizedBaseOlympiadIdBaseOlympiadGet( idBaseOlympiad: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<BaseContest>>;
    public tasksUnauthorizedBaseOlympiadIdBaseOlympiadGet( idBaseOlympiad: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<BaseContest>>;
    public tasksUnauthorizedBaseOlympiadIdBaseOlympiadGet( idBaseOlympiad: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idBaseOlympiad === null || idBaseOlympiad === undefined )
        {
            throw new Error( 'Required parameter idBaseOlympiad was null or undefined when calling tasksUnauthorizedBaseOlympiadIdBaseOlympiadGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<BaseContest>( `${ this.configuration.basePath }/tasks/unauthorized/base_olympiad/${ encodeURIComponent( String( idBaseOlympiad ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idBaseOlympiad Id of the base contest
     * @param idOlympiad Id of the olympiad
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksUnauthorizedBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadGet( idBaseOlympiad: number, idOlympiad: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<Contest>;
    public tasksUnauthorizedBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadGet( idBaseOlympiad: number, idOlympiad: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<Contest>>;
    public tasksUnauthorizedBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadGet( idBaseOlympiad: number, idOlympiad: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<Contest>>;
    public tasksUnauthorizedBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadGet( idBaseOlympiad: number, idOlympiad: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idBaseOlympiad === null || idBaseOlympiad === undefined )
        {
            throw new Error( 'Required parameter idBaseOlympiad was null or undefined when calling tasksUnauthorizedBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadGet.' )
        }
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksUnauthorizedBaseOlympiadIdBaseOlympiadOlympiadIdOlympiadGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<Contest>( `${ this.configuration.basePath }/tasks/unauthorized/base_olympiad/${ encodeURIComponent( String( idBaseOlympiad ) ) }/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksUnauthorizedLocationAllGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllLocationResponseTaskUnauthorized>;
    public tasksUnauthorizedLocationAllGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllLocationResponseTaskUnauthorized>>;
    public tasksUnauthorizedLocationAllGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllLocationResponseTaskUnauthorized>>;
    public tasksUnauthorizedLocationAllGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<AllLocationResponseTaskUnauthorized>( `${ this.configuration.basePath }/tasks/unauthorized/location/all`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idLocation Id of the location
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksUnauthorizedLocationIdLocationGet( idLocation: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<OlympiadLocation>;
    public tasksUnauthorizedLocationIdLocationGet( idLocation: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<OlympiadLocation>>;
    public tasksUnauthorizedLocationIdLocationGet( idLocation: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<OlympiadLocation>>;
    public tasksUnauthorizedLocationIdLocationGet( idLocation: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idLocation === null || idLocation === undefined )
        {
            throw new Error( 'Required parameter idLocation was null or undefined when calling tasksUnauthorizedLocationIdLocationGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<OlympiadLocation>( `${ this.configuration.basePath }/tasks/unauthorized/location/${ encodeURIComponent( String( idLocation ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param visibility
     * @param offset
     * @param limit
     * @param baseContestId
     * @param academicYear
     * @param locationId
     * @param endDate
     * @param targetClass
     * @param onlyCount
     * @param compositeType
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksUnauthorizedOlympiadAllGet( visibility?: boolean, offset?: number, limit?: number, baseContestId?: number, academicYear?: number, locationId?: number, endDate?: string, targetClass?: number, onlyCount?: boolean, compositeType?: 'SimpleContest' | 'CompositeContest', observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<FilterSimpleContestResponse>;
    public tasksUnauthorizedOlympiadAllGet( visibility?: boolean, offset?: number, limit?: number, baseContestId?: number, academicYear?: number, locationId?: number, endDate?: string, targetClass?: number, onlyCount?: boolean, compositeType?: 'SimpleContest' | 'CompositeContest', observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<FilterSimpleContestResponse>>;
    public tasksUnauthorizedOlympiadAllGet( visibility?: boolean, offset?: number, limit?: number, baseContestId?: number, academicYear?: number, locationId?: number, endDate?: string, targetClass?: number, onlyCount?: boolean, compositeType?: 'SimpleContest' | 'CompositeContest', observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<FilterSimpleContestResponse>>;
    public tasksUnauthorizedOlympiadAllGet( visibility?: boolean, offset?: number, limit?: number, baseContestId?: number, academicYear?: number, locationId?: number, endDate?: string, targetClass?: number, onlyCount?: boolean, compositeType?: 'SimpleContest' | 'CompositeContest', observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {

        let localVarQueryParameters = new HttpParams( { encoder: this.encoder } )
        if ( visibility !== undefined && visibility !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> visibility, 'visibility' )
        }
        if ( offset !== undefined && offset !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> offset, 'offset' )
        }
        if ( limit !== undefined && limit !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> limit, 'limit' )
        }
        if ( baseContestId !== undefined && baseContestId !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> baseContestId, 'base_contest_id' )
        }
        if ( academicYear !== undefined && academicYear !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> academicYear, 'academic_year' )
        }
        if ( locationId !== undefined && locationId !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> locationId, 'location_id' )
        }
        if ( endDate !== undefined && endDate !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> endDate, 'end_date' )
        }
        if ( targetClass !== undefined && targetClass !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> targetClass, 'target_class' )
        }
        if ( onlyCount !== undefined && onlyCount !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> onlyCount, 'only_count' )
        }
        if ( compositeType !== undefined && compositeType !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> compositeType, 'composite_type' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<FilterSimpleContestResponse>( `${ this.configuration.basePath }/tasks/unauthorized/olympiad/all`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idOlympiad Id of the olympiad
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksUnauthorizedOlympiadIdOlympiadStageAllGet( idOlympiad: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllStagesResponseTaskUnauthorized>;
    public tasksUnauthorizedOlympiadIdOlympiadStageAllGet( idOlympiad: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllStagesResponseTaskUnauthorized>>;
    public tasksUnauthorizedOlympiadIdOlympiadStageAllGet( idOlympiad: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllStagesResponseTaskUnauthorized>>;
    public tasksUnauthorizedOlympiadIdOlympiadStageAllGet( idOlympiad: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksUnauthorizedOlympiadIdOlympiadStageAllGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<AllStagesResponseTaskUnauthorized>( `${ this.configuration.basePath }/tasks/unauthorized/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/all`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idOlympiad Id of the olympiad
     * @param idStage Id of the stage
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksUnauthorizedOlympiadIdOlympiadStageIdStageGet( idOlympiad: number, idStage: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<Stage>;
    public tasksUnauthorizedOlympiadIdOlympiadStageIdStageGet( idOlympiad: number, idStage: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<Stage>>;
    public tasksUnauthorizedOlympiadIdOlympiadStageIdStageGet( idOlympiad: number, idStage: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<Stage>>;
    public tasksUnauthorizedOlympiadIdOlympiadStageIdStageGet( idOlympiad: number, idStage: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idOlympiad === null || idOlympiad === undefined )
        {
            throw new Error( 'Required parameter idOlympiad was null or undefined when calling tasksUnauthorizedOlympiadIdOlympiadStageIdStageGet.' )
        }
        if ( idStage === null || idStage === undefined )
        {
            throw new Error( 'Required parameter idStage was null or undefined when calling tasksUnauthorizedOlympiadIdOlympiadStageIdStageGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<Stage>( `${ this.configuration.basePath }/tasks/unauthorized/olympiad/${ encodeURIComponent( String( idOlympiad ) ) }/stage/${ encodeURIComponent( String( idStage ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksUnauthorizedOlympiadTypeAllGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllOlympiadTypesResponseTaskUnauthorized>;
    public tasksUnauthorizedOlympiadTypeAllGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllOlympiadTypesResponseTaskUnauthorized>>;
    public tasksUnauthorizedOlympiadTypeAllGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllOlympiadTypesResponseTaskUnauthorized>>;
    public tasksUnauthorizedOlympiadTypeAllGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<AllOlympiadTypesResponseTaskUnauthorized>( `${ this.configuration.basePath }/tasks/unauthorized/olympiad_type/all`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idOlympiadType Id of the olympiad type
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksUnauthorizedOlympiadTypeIdOlympiadTypeGet( idOlympiadType: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<OlympiadType>;
    public tasksUnauthorizedOlympiadTypeIdOlympiadTypeGet( idOlympiadType: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<OlympiadType>>;
    public tasksUnauthorizedOlympiadTypeIdOlympiadTypeGet( idOlympiadType: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<OlympiadType>>;
    public tasksUnauthorizedOlympiadTypeIdOlympiadTypeGet( idOlympiadType: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idOlympiadType === null || idOlympiadType === undefined )
        {
            throw new Error( 'Required parameter idOlympiadType was null or undefined when calling tasksUnauthorizedOlympiadTypeIdOlympiadTypeGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<OlympiadType>( `${ this.configuration.basePath }/tasks/unauthorized/olympiad_type/${ encodeURIComponent( String( idOlympiadType ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksUnauthorizedTargetClassAllGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<AllTargetClassesRequestTaskUnauthorized>;
    public tasksUnauthorizedTargetClassAllGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<AllTargetClassesRequestTaskUnauthorized>>;
    public tasksUnauthorizedTargetClassAllGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<AllTargetClassesRequestTaskUnauthorized>>;
    public tasksUnauthorizedTargetClassAllGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<AllTargetClassesRequestTaskUnauthorized>( `${ this.configuration.basePath }/tasks/unauthorized/target_class/all`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param idTargetClass Id of the location
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksUnauthorizedTargetClassIdTargetClassGet( idTargetClass: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<TargetClass>;
    public tasksUnauthorizedTargetClassIdTargetClassGet( idTargetClass: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<TargetClass>>;
    public tasksUnauthorizedTargetClassIdTargetClassGet( idTargetClass: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<TargetClass>>;
    public tasksUnauthorizedTargetClassIdTargetClassGet( idTargetClass: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( idTargetClass === null || idTargetClass === undefined )
        {
            throw new Error( 'Required parameter idTargetClass was null or undefined when calling tasksUnauthorizedTargetClassIdTargetClassGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<TargetClass>( `${ this.configuration.basePath }/tasks/unauthorized/target_class/${ encodeURIComponent( String( idTargetClass ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }
}