/**
 * aggregate_news
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core'
import {
    HttpClient,
    HttpContext,
    HttpEvent,
    HttpHeaders,
    HttpParameterCodec,
    HttpParams,
    HttpResponse
} from '@angular/common/http'
import { Observable } from 'rxjs'
import { CustomHttpParameterCodec } from '@api/encoder'
import { BASE_PATH } from '@api/variables'
import { Configuration } from '@api/configuration'
import { environment } from '@environments/environment'
import {
    AddCategoryNewsRequest,
    CreateNewsRequest,
    EditNewsRequest,
    FilterNewsResponse,
    ListCategoriesNewsResponse,
    News,
    NewsCategory
} from '@api/news/model'


@Injectable()
export class NewsService
{
    protected basePath = environment.apiUrl + '/news'
    public defaultHeaders = new HttpHeaders()
    public configuration = new Configuration()
    public encoder: HttpParameterCodec

    constructor( protected httpClient: HttpClient, @Optional() @Inject( BASE_PATH ) basePath: string, @Optional() configuration: Configuration )
    {
        if ( configuration )
        {
            this.configuration = configuration
        }
        if ( typeof this.configuration.basePath !== 'string' )
        {
            if ( typeof basePath !== 'string' )
            {
                basePath = this.basePath
            }
            this.configuration.basePath = basePath
        }
        this.configuration.withCredentials = true
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec()
    }


    private addToHttpParams( httpParams: HttpParams, value: any, key?: string ): HttpParams
    {
        if ( typeof value === "object" && value instanceof Date === false )
        {
            httpParams = this.addToHttpParamsRecursive( httpParams, value )
        }
        else
        {
            httpParams = this.addToHttpParamsRecursive( httpParams, value, key )
        }
        return httpParams
    }

    private addToHttpParamsRecursive( httpParams: HttpParams, value?: any, key?: string ): HttpParams
    {
        if ( value == null )
        {
            return httpParams
        }

        if ( typeof value === "object" )
        {
            if ( Array.isArray( value ) )
            {
                ( value as any[] ).forEach( elem => httpParams = this.addToHttpParamsRecursive( httpParams, elem, key ) )
            }
            else if ( value instanceof Date )
            {
                if ( key != null )
                {
                    httpParams = httpParams.append( key,
                        ( value as Date ).toISOString().substr( 0, 10 ) )
                }
                else
                {
                    throw Error( "key may not be null if value is Date" )
                }
            }
            else
            {
                Object.keys( value ).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[ k ], key != null ? `${ key }.${ k }` : k ) )
            }
        }
        else if ( key != null )
        {
            httpParams = httpParams.append( key, value )
        }
        else
        {
            throw Error( "key may not be null if value is not object or array" )
        }
        return httpParams
    }

    /**
     * @param addCategoryNewsRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newsAdminAddCategoryPost( addCategoryNewsRequest: AddCategoryNewsRequest, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<NewsCategory>;
    public newsAdminAddCategoryPost( addCategoryNewsRequest: AddCategoryNewsRequest, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<NewsCategory>>;
    public newsAdminAddCategoryPost( addCategoryNewsRequest: AddCategoryNewsRequest, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<NewsCategory>>;
    public newsAdminAddCategoryPost( addCategoryNewsRequest: AddCategoryNewsRequest, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( addCategoryNewsRequest === null || addCategoryNewsRequest === undefined )
        {
            throw new Error( 'Required parameter addCategoryNewsRequest was null or undefined when calling newsAdminAddCategoryPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<NewsCategory>( `${ this.configuration.basePath }/news/admin/add_category`,
            addCategoryNewsRequest,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param categoryName Name of the category
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newsAdminDeleteCategoryCategoryNamePost( categoryName: string, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public newsAdminDeleteCategoryCategoryNamePost( categoryName: string, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public newsAdminDeleteCategoryCategoryNamePost( categoryName: string, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public newsAdminDeleteCategoryCategoryNamePost( categoryName: string, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( categoryName === null || categoryName === undefined )
        {
            throw new Error( 'Required parameter categoryName was null or undefined when calling newsAdminDeleteCategoryCategoryNamePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/news/admin/delete_category/${ encodeURIComponent( String( categoryName ) ) }`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param newsId ID of news
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newsAdminNewsNewsIdDeletePost( newsId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public newsAdminNewsNewsIdDeletePost( newsId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public newsAdminNewsNewsIdDeletePost( newsId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public newsAdminNewsNewsIdDeletePost( newsId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( newsId === null || newsId === undefined )
        {
            throw new Error( 'Required parameter newsId was null or undefined when calling newsAdminNewsNewsIdDeletePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/news/admin/news/${ encodeURIComponent( String( newsId ) ) }/delete`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newsCreatorCategoriesGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<ListCategoriesNewsResponse>;
    public newsCreatorCategoriesGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<ListCategoriesNewsResponse>>;
    public newsCreatorCategoriesGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<ListCategoriesNewsResponse>>;
    public newsCreatorCategoriesGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<ListCategoriesNewsResponse>( `${ this.configuration.basePath }/news/creator/categories`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param offset
     * @param limit
     * @param posted
     * @param categoryName
     * @param grade
     * @param title
     * @param contestId
     * @param onlyCount
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newsCreatorNewsGet( offset?: number, limit?: number, posted?: boolean, categoryName?: string, grade?: number, title?: string, contestId?: number, onlyCount?: boolean, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<FilterNewsResponse>;
    public newsCreatorNewsGet( offset?: number, limit?: number, posted?: boolean, categoryName?: string, grade?: number, title?: string, contestId?: number, onlyCount?: boolean, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<FilterNewsResponse>>;
    public newsCreatorNewsGet( offset?: number, limit?: number, posted?: boolean, categoryName?: string, grade?: number, title?: string, contestId?: number, onlyCount?: boolean, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<FilterNewsResponse>>;
    public newsCreatorNewsGet( offset?: number, limit?: number, posted?: boolean, categoryName?: string, grade?: number, title?: string, contestId?: number, onlyCount?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {

        let localVarQueryParameters = new HttpParams( { encoder: this.encoder } )
        if ( offset !== undefined && offset !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> offset, 'offset' )
        }
        if ( limit !== undefined && limit !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> limit, 'limit' )
        }
        if ( posted !== undefined && posted !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> posted, 'posted' )
        }
        if ( categoryName !== undefined && categoryName !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> categoryName, 'category_name' )
        }
        if ( grade !== undefined && grade !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> grade, 'grade' )
        }
        if ( title !== undefined && title !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> title, 'title' )
        }
        if ( contestId !== undefined && contestId !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> contestId, 'contest_id' )
        }
        if ( onlyCount !== undefined && onlyCount !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> onlyCount, 'only_count' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<FilterNewsResponse>( `${ this.configuration.basePath }/news/creator/news`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param newsId ID of news
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newsCreatorNewsNewsIdGet( newsId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<News>;
    public newsCreatorNewsNewsIdGet( newsId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<News>>;
    public newsCreatorNewsNewsIdGet( newsId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<News>>;
    public newsCreatorNewsNewsIdGet( newsId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( newsId === null || newsId === undefined )
        {
            throw new Error( 'Required parameter newsId was null or undefined when calling newsCreatorNewsNewsIdGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<News>( `${ this.configuration.basePath }/news/creator/news/${ encodeURIComponent( String( newsId ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param newsId ID of news
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newsCreatorNewsNewsIdHidePost( newsId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public newsCreatorNewsNewsIdHidePost( newsId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public newsCreatorNewsNewsIdHidePost( newsId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public newsCreatorNewsNewsIdHidePost( newsId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( newsId === null || newsId === undefined )
        {
            throw new Error( 'Required parameter newsId was null or undefined when calling newsCreatorNewsNewsIdHidePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/news/creator/news/${ encodeURIComponent( String( newsId ) ) }/hide`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param newsId ID of news
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newsCreatorNewsNewsIdImageGet( newsId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'image/_*', context?: HttpContext } ): Observable<Blob>;
    public newsCreatorNewsNewsIdImageGet( newsId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'image/_*', context?: HttpContext } ): Observable<HttpResponse<Blob>>;
    public newsCreatorNewsNewsIdImageGet( newsId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'image/_*', context?: HttpContext } ): Observable<HttpEvent<Blob>>;
    public newsCreatorNewsNewsIdImageGet( newsId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'image/_*', context?: HttpContext } ): Observable<any>
    {
        if ( newsId === null || newsId === undefined )
        {
            throw new Error( 'Required parameter newsId was null or undefined when calling newsCreatorNewsNewsIdImageGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'image/_*'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        return this.httpClient.get( `${ this.configuration.basePath }/news/creator/news/${ encodeURIComponent( String( newsId ) ) }/image`,
            {
                context: localVarHttpContext,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param newsId ID of news
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newsCreatorNewsNewsIdImagePost( newsId: number, body: Blob, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public newsCreatorNewsNewsIdImagePost( newsId: number, body: Blob, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public newsCreatorNewsNewsIdImagePost( newsId: number, body: Blob, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public newsCreatorNewsNewsIdImagePost( newsId: number, body: Blob, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( newsId === null || newsId === undefined )
        {
            throw new Error( 'Required parameter newsId was null or undefined when calling newsCreatorNewsNewsIdImagePost.' )
        }
        if ( body === null || body === undefined )
        {
            throw new Error( 'Required parameter body was null or undefined when calling newsCreatorNewsNewsIdImagePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'image/_*'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/news/creator/news/${ encodeURIComponent( String( newsId ) ) }/image`,
            body,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param newsId ID of news
     * @param editNewsRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newsCreatorNewsNewsIdPatch( newsId: number, editNewsRequest: EditNewsRequest, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<News>;
    public newsCreatorNewsNewsIdPatch( newsId: number, editNewsRequest: EditNewsRequest, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<News>>;
    public newsCreatorNewsNewsIdPatch( newsId: number, editNewsRequest: EditNewsRequest, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<News>>;
    public newsCreatorNewsNewsIdPatch( newsId: number, editNewsRequest: EditNewsRequest, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( newsId === null || newsId === undefined )
        {
            throw new Error( 'Required parameter newsId was null or undefined when calling newsCreatorNewsNewsIdPatch.' )
        }
        if ( editNewsRequest === null || editNewsRequest === undefined )
        {
            throw new Error( 'Required parameter editNewsRequest was null or undefined when calling newsCreatorNewsNewsIdPatch.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.patch<News>( `${ this.configuration.basePath }/news/creator/news/${ encodeURIComponent( String( newsId ) ) }`,
            editNewsRequest,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param newsId ID of news
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newsCreatorNewsNewsIdPostPost( newsId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public newsCreatorNewsNewsIdPostPost( newsId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public newsCreatorNewsNewsIdPostPost( newsId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public newsCreatorNewsNewsIdPostPost( newsId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( newsId === null || newsId === undefined )
        {
            throw new Error( 'Required parameter newsId was null or undefined when calling newsCreatorNewsNewsIdPostPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/news/creator/news/${ encodeURIComponent( String( newsId ) ) }/post`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param createNewsRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newsCreatorNewsPost( createNewsRequest: CreateNewsRequest, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<News>;
    public newsCreatorNewsPost( createNewsRequest: CreateNewsRequest, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<News>>;
    public newsCreatorNewsPost( createNewsRequest: CreateNewsRequest, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<News>>;
    public newsCreatorNewsPost( createNewsRequest: CreateNewsRequest, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( createNewsRequest === null || createNewsRequest === undefined )
        {
            throw new Error( 'Required parameter createNewsRequest was null or undefined when calling newsCreatorNewsPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<News>( `${ this.configuration.basePath }/news/creator/news`,
            createNewsRequest,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param offset
     * @param limit
     * @param categoryName
     * @param grade
     * @param title
     * @param contestId
     * @param onlyCount
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newsVisitorNewsGet( offset?: number, limit?: number, categoryName?: string, grade?: number, title?: string, contestId?: number, onlyCount?: boolean, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<FilterNewsResponse>;
    public newsVisitorNewsGet( offset?: number, limit?: number, categoryName?: string, grade?: number, title?: string, contestId?: number, onlyCount?: boolean, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<FilterNewsResponse>>;
    public newsVisitorNewsGet( offset?: number, limit?: number, categoryName?: string, grade?: number, title?: string, contestId?: number, onlyCount?: boolean, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<FilterNewsResponse>>;
    public newsVisitorNewsGet( offset?: number, limit?: number, categoryName?: string, grade?: number, title?: string, contestId?: number, onlyCount?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        let localVarQueryParameters = new HttpParams( { encoder: this.encoder } )
        if ( offset !== undefined && offset !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> offset, 'offset' )
        }
        if ( limit !== undefined && limit !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> limit, 'limit' )
        }
        if ( categoryName !== undefined && categoryName !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> categoryName, 'category_name' )
        }
        if ( grade !== undefined && grade !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> grade, 'grade' )
        }
        if ( title !== undefined && title !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> title, 'title' )
        }
        if ( contestId !== undefined && contestId !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> contestId, 'contest_id' )
        }
        if ( onlyCount !== undefined && onlyCount !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> onlyCount, 'only_count' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<FilterNewsResponse>( `${ this.configuration.basePath }/news/visitor/news`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param newsId ID of news
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newsVisitorNewsNewsIdGet( newsId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<News>;
    public newsVisitorNewsNewsIdGet( newsId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<News>>;
    public newsVisitorNewsNewsIdGet( newsId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<News>>;
    public newsVisitorNewsNewsIdGet( newsId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( newsId === null || newsId === undefined )
        {
            throw new Error( 'Required parameter newsId was null or undefined when calling newsVisitorNewsNewsIdGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<News>( `${ this.configuration.basePath }/news/visitor/news/${ encodeURIComponent( String( newsId ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param newsId ID of news
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newsVisitorNewsNewsIdImageGet( newsId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'image/_*', context?: HttpContext } ): Observable<Blob>;
    public newsVisitorNewsNewsIdImageGet( newsId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'image/_*', context?: HttpContext } ): Observable<HttpResponse<Blob>>;
    public newsVisitorNewsNewsIdImageGet( newsId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'image/_*', context?: HttpContext } ): Observable<HttpEvent<Blob>>;
    public newsVisitorNewsNewsIdImageGet( newsId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'image/_*', context?: HttpContext } ): Observable<any>
    {
        if ( newsId === null || newsId === undefined )
        {
            throw new Error( 'Required parameter newsId was null or undefined when calling newsVisitorNewsNewsIdImageGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'image/_*'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }

        return this.httpClient.get( `${ this.configuration.basePath }/news/visitor/news/${ encodeURIComponent( String( newsId ) ) }/image`,
            {
                context: localVarHttpContext,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }
}