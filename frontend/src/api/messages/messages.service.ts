/**
 * aggregate_messages
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core'
import {
    HttpClient,
    HttpContext,
    HttpEvent,
    HttpHeaders,
    HttpParameterCodec,
    HttpParams,
    HttpResponse
} from '@angular/common/http'
import { Observable } from 'rxjs'
import { CustomHttpParameterCodec } from '@api/encoder'
import { BASE_PATH } from '@api/variables'
import { Configuration } from '@api/configuration'
import { environment } from '@environments/environment'
import {
    AddCategoryMessagesRequest,
    CleanupMessagesRequest,
    CreateMessageCreatorMessagesRequest,
    CreateMessageMessagesRequest,
    CreateThreadMessagesRequest,
    FilterThreadsMessagesResponse,
    ListCategoriesMessagesResponse,
    Message,
    Thread,
    ThreadStatusMessagesRequest
} from '@api/messages/model'


@Injectable()
export class MessagesService
{
    protected basePath = environment.apiUrl + '/messages'
    public defaultHeaders = new HttpHeaders()
    public configuration = new Configuration()
    public encoder: HttpParameterCodec

    constructor( protected httpClient: HttpClient, @Optional() @Inject( BASE_PATH ) basePath: string, @Optional() configuration: Configuration )
    {
        if ( configuration )
        {
            this.configuration = configuration
        }
        if ( typeof this.configuration.basePath !== 'string' )
        {
            if ( typeof basePath !== 'string' )
            {
                basePath = this.basePath
            }
            this.configuration.basePath = basePath
        }
        this.configuration.withCredentials = true
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec()
    }

    private addToHttpParams( httpParams: HttpParams, value: any, key?: string ): HttpParams
    {
        if ( typeof value === "object" && value instanceof Date === false )
        {
            httpParams = this.addToHttpParamsRecursive( httpParams, value )
        }
        else
        {
            httpParams = this.addToHttpParamsRecursive( httpParams, value, key )
        }
        return httpParams
    }

    private addToHttpParamsRecursive( httpParams: HttpParams, value?: any, key?: string ): HttpParams
    {
        if ( value == null )
        {
            return httpParams
        }

        if ( typeof value === "object" )
        {
            if ( Array.isArray( value ) )
            {
                ( value as any[] ).forEach( elem => httpParams = this.addToHttpParamsRecursive( httpParams, elem, key ) )
            }
            else if ( value instanceof Date )
            {
                if ( key != null )
                {
                    httpParams = httpParams.append( key,
                        ( value as Date ).toISOString().substr( 0, 10 ) )
                }
                else
                {
                    throw Error( "key may not be null if value is Date" )
                }
            }
            else
            {
                Object.keys( value ).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[ k ], key != null ? `${ key }.${ k }` : k ) )
            }
        }
        else if ( key != null )
        {
            httpParams = httpParams.append( key, value )
        }
        else
        {
            throw Error( "key may not be null if value is not object or array" )
        }
        return httpParams
    }

    /**
     * @param addCategoryMessagesRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public messagesAdminAddCategoryPost( addCategoryMessagesRequest: AddCategoryMessagesRequest, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public messagesAdminAddCategoryPost( addCategoryMessagesRequest: AddCategoryMessagesRequest, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public messagesAdminAddCategoryPost( addCategoryMessagesRequest: AddCategoryMessagesRequest, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public messagesAdminAddCategoryPost( addCategoryMessagesRequest: AddCategoryMessagesRequest, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( addCategoryMessagesRequest === null || addCategoryMessagesRequest === undefined )
        {
            throw new Error( 'Required parameter addCategoryMessagesRequest was null or undefined when calling messagesAdminAddCategoryPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/messages/admin/add_category`,
            addCategoryMessagesRequest,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param cleanupMessagesRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public messagesAdminCleanupPost( cleanupMessagesRequest: CleanupMessagesRequest, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public messagesAdminCleanupPost( cleanupMessagesRequest: CleanupMessagesRequest, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public messagesAdminCleanupPost( cleanupMessagesRequest: CleanupMessagesRequest, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public messagesAdminCleanupPost( cleanupMessagesRequest: CleanupMessagesRequest, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( cleanupMessagesRequest === null || cleanupMessagesRequest === undefined )
        {
            throw new Error( 'Required parameter cleanupMessagesRequest was null or undefined when calling messagesAdminCleanupPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/messages/admin/cleanup`,
            cleanupMessagesRequest,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param categoryName Name of the category
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public messagesAdminDeleteCategoryCategoryNamePost( categoryName: string, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public messagesAdminDeleteCategoryCategoryNamePost( categoryName: string, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public messagesAdminDeleteCategoryCategoryNamePost( categoryName: string, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public messagesAdminDeleteCategoryCategoryNamePost( categoryName: string, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( categoryName === null || categoryName === undefined )
        {
            throw new Error( 'Required parameter categoryName was null or undefined when calling messagesAdminDeleteCategoryCategoryNamePost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/messages/admin/delete_category/${ encodeURIComponent( String( categoryName ) ) }`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param threadId ID of the thread
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public messagesAdminDeleteThreadThreadIdPost( threadId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>;
    public messagesAdminDeleteThreadThreadIdPost( threadId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpResponse<any>>;
    public messagesAdminDeleteThreadThreadIdPost( threadId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<HttpEvent<any>>;
    public messagesAdminDeleteThreadThreadIdPost( threadId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: undefined, context?: HttpContext } ): Observable<any>
    {
        if ( threadId === null || threadId === undefined )
        {
            throw new Error( 'Required parameter threadId was null or undefined when calling messagesAdminDeleteThreadThreadIdPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = []
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<any>( `${ this.configuration.basePath }/messages/admin/delete_thread/${ encodeURIComponent( String( threadId ) ) }`,
            null,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param threadId ID of the thread
     * @param createMessageCreatorMessagesRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public messagesCreatorMessageThreadIdPost( threadId: number, createMessageCreatorMessagesRequest: CreateMessageCreatorMessagesRequest, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<Message>;
    public messagesCreatorMessageThreadIdPost( threadId: number, createMessageCreatorMessagesRequest: CreateMessageCreatorMessagesRequest, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<Message>>;
    public messagesCreatorMessageThreadIdPost( threadId: number, createMessageCreatorMessagesRequest: CreateMessageCreatorMessagesRequest, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<Message>>;
    public messagesCreatorMessageThreadIdPost( threadId: number, createMessageCreatorMessagesRequest: CreateMessageCreatorMessagesRequest, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( threadId === null || threadId === undefined )
        {
            throw new Error( 'Required parameter threadId was null or undefined when calling messagesCreatorMessageThreadIdPost.' )
        }
        if ( createMessageCreatorMessagesRequest === null || createMessageCreatorMessagesRequest === undefined )
        {
            throw new Error( 'Required parameter createMessageCreatorMessagesRequest was null or undefined when calling messagesCreatorMessageThreadIdPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<Message>( `${ this.configuration.basePath }/messages/creator/message/${ encodeURIComponent( String( threadId ) ) }`,
            createMessageCreatorMessagesRequest,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param threadId ID of the thread
     * @param threadStatusMessagesRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public messagesCreatorThreadStatusThreadIdPost( threadId: number, threadStatusMessagesRequest: ThreadStatusMessagesRequest, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<Thread>;
    public messagesCreatorThreadStatusThreadIdPost( threadId: number, threadStatusMessagesRequest: ThreadStatusMessagesRequest, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<Thread>>;
    public messagesCreatorThreadStatusThreadIdPost( threadId: number, threadStatusMessagesRequest: ThreadStatusMessagesRequest, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<Thread>>;
    public messagesCreatorThreadStatusThreadIdPost( threadId: number, threadStatusMessagesRequest: ThreadStatusMessagesRequest, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( threadId === null || threadId === undefined )
        {
            throw new Error( 'Required parameter threadId was null or undefined when calling messagesCreatorThreadStatusThreadIdPost.' )
        }
        if ( threadStatusMessagesRequest === null || threadStatusMessagesRequest === undefined )
        {
            throw new Error( 'Required parameter threadStatusMessagesRequest was null or undefined when calling messagesCreatorThreadStatusThreadIdPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<Thread>( `${ this.configuration.basePath }/messages/creator/thread_status/${ encodeURIComponent( String( threadId ) ) }`,
            threadStatusMessagesRequest,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param threadId ID of the thread
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public messagesCreatorThreadThreadIdGet( threadId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<Thread>;
    public messagesCreatorThreadThreadIdGet( threadId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<Thread>>;
    public messagesCreatorThreadThreadIdGet( threadId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<Thread>>;
    public messagesCreatorThreadThreadIdGet( threadId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( threadId === null || threadId === undefined )
        {
            throw new Error( 'Required parameter threadId was null or undefined when calling messagesCreatorThreadThreadIdGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<Thread>( `${ this.configuration.basePath }/messages/creator/thread/${ encodeURIComponent( String( threadId ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param offset
     * @param limit
     * @param resolved
     * @param answered
     * @param threadType
     * @param categoryName
     * @param onlyCount
     * @param contestId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public messagesCreatorThreadsGet( offset?: number, limit?: number, resolved?: boolean, answered?: boolean, threadType?: 'Appeal' | 'Work' | 'Contest' | 'General', categoryName?: string, onlyCount?: boolean, contestId?: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<FilterThreadsMessagesResponse>;
    public messagesCreatorThreadsGet( offset?: number, limit?: number, resolved?: boolean, answered?: boolean, threadType?: 'Appeal' | 'Work' | 'Contest' | 'General', categoryName?: string, onlyCount?: boolean, contestId?: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<FilterThreadsMessagesResponse>>;
    public messagesCreatorThreadsGet( offset?: number, limit?: number, resolved?: boolean, answered?: boolean, threadType?: 'Appeal' | 'Work' | 'Contest' | 'General', categoryName?: string, onlyCount?: boolean, contestId?: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<FilterThreadsMessagesResponse>>;
    public messagesCreatorThreadsGet( offset?: number, limit?: number, resolved?: boolean, answered?: boolean, threadType?: 'Appeal' | 'Work' | 'Contest' | 'General', categoryName?: string, onlyCount?: boolean, contestId?: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {

        let localVarQueryParameters = new HttpParams( { encoder: this.encoder } )
        if ( offset !== undefined && offset !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> offset, 'offset' )
        }
        if ( limit !== undefined && limit !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> limit, 'limit' )
        }
        if ( resolved !== undefined && resolved !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> resolved, 'resolved' )
        }
        if ( answered !== undefined && answered !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> answered, 'answered' )
        }
        if ( threadType !== undefined && threadType !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> threadType, 'thread_type' )
        }
        if ( categoryName !== undefined && categoryName !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> categoryName, 'category_name' )
        }
        if ( onlyCount !== undefined && onlyCount !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> onlyCount, 'only_count' )
        }
        if ( contestId !== undefined && contestId !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> contestId, 'contest_id' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<FilterThreadsMessagesResponse>( `${ this.configuration.basePath }/messages/creator/threads`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public messagesParticipantCategoriesGet( observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<ListCategoriesMessagesResponse>;
    public messagesParticipantCategoriesGet( observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<ListCategoriesMessagesResponse>>;
    public messagesParticipantCategoriesGet( observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<ListCategoriesMessagesResponse>>;
    public messagesParticipantCategoriesGet( observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<ListCategoriesMessagesResponse>( `${ this.configuration.basePath }/messages/participant/categories`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param threadId ID of the thread
     * @param createMessageMessagesRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public messagesParticipantMessageThreadIdPost( threadId: number, createMessageMessagesRequest: CreateMessageMessagesRequest, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<Message>;
    public messagesParticipantMessageThreadIdPost( threadId: number, createMessageMessagesRequest: CreateMessageMessagesRequest, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<Message>>;
    public messagesParticipantMessageThreadIdPost( threadId: number, createMessageMessagesRequest: CreateMessageMessagesRequest, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<Message>>;
    public messagesParticipantMessageThreadIdPost( threadId: number, createMessageMessagesRequest: CreateMessageMessagesRequest, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( threadId === null || threadId === undefined )
        {
            throw new Error( 'Required parameter threadId was null or undefined when calling messagesParticipantMessageThreadIdPost.' )
        }
        if ( createMessageMessagesRequest === null || createMessageMessagesRequest === undefined )
        {
            throw new Error( 'Required parameter createMessageMessagesRequest was null or undefined when calling messagesParticipantMessageThreadIdPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<Message>( `${ this.configuration.basePath }/messages/participant/message/${ encodeURIComponent( String( threadId ) ) }`,
            createMessageMessagesRequest,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param createThreadMessagesRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public messagesParticipantThreadPost( createThreadMessagesRequest: CreateThreadMessagesRequest, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<Thread>;
    public messagesParticipantThreadPost( createThreadMessagesRequest: CreateThreadMessagesRequest, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<Thread>>;
    public messagesParticipantThreadPost( createThreadMessagesRequest: CreateThreadMessagesRequest, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<Thread>>;
    public messagesParticipantThreadPost( createThreadMessagesRequest: CreateThreadMessagesRequest, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( createThreadMessagesRequest === null || createThreadMessagesRequest === undefined )
        {
            throw new Error( 'Required parameter createThreadMessagesRequest was null or undefined when calling messagesParticipantThreadPost.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (CSRFAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'CSRFAccessToken' )
        if ( localVarCredential )
        {
            localVarHeaders = localVarHeaders.set( 'X-CSRF-TOKEN', localVarCredential )
        }

        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ]
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType( consumes )
        if ( httpContentTypeSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Content-Type', httpContentTypeSelected )
        }

        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.post<Thread>( `${ this.configuration.basePath }/messages/participant/thread`,
            createThreadMessagesRequest,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param threadId ID of the thread
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public messagesParticipantThreadThreadIdGet( threadId: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<Thread>;
    public messagesParticipantThreadThreadIdGet( threadId: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<Thread>>;
    public messagesParticipantThreadThreadIdGet( threadId: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<Thread>>;
    public messagesParticipantThreadThreadIdGet( threadId: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {
        if ( threadId === null || threadId === undefined )
        {
            throw new Error( 'Required parameter threadId was null or undefined when calling messagesParticipantThreadThreadIdGet.' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<Thread>( `${ this.configuration.basePath }/messages/participant/thread/${ encodeURIComponent( String( threadId ) ) }`,
            {
                context: localVarHttpContext,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }

    /**
     * @param offset
     * @param limit
     * @param resolved
     * @param answered
     * @param threadType
     * @param categoryName
     * @param onlyCount
     * @param contestId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public messagesParticipantThreadsGet( offset?: number, limit?: number, resolved?: boolean, answered?: boolean, threadType?: 'Appeal' | 'Work' | 'Contest' | 'General', categoryName?: string, onlyCount?: boolean, contestId?: number, observe?: 'body', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<FilterThreadsMessagesResponse>;
    public messagesParticipantThreadsGet( offset?: number, limit?: number, resolved?: boolean, answered?: boolean, threadType?: 'Appeal' | 'Work' | 'Contest' | 'General', categoryName?: string, onlyCount?: boolean, contestId?: number, observe?: 'response', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpResponse<FilterThreadsMessagesResponse>>;
    public messagesParticipantThreadsGet( offset?: number, limit?: number, resolved?: boolean, answered?: boolean, threadType?: 'Appeal' | 'Work' | 'Contest' | 'General', categoryName?: string, onlyCount?: boolean, contestId?: number, observe?: 'events', reportProgress?: boolean, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<HttpEvent<FilterThreadsMessagesResponse>>;
    public messagesParticipantThreadsGet( offset?: number, limit?: number, resolved?: boolean, answered?: boolean, threadType?: 'Appeal' | 'Work' | 'Contest' | 'General', categoryName?: string, onlyCount?: boolean, contestId?: number, observe: any = 'body', reportProgress: boolean = false, options?: { httpHeaderAccept?: 'application/json', context?: HttpContext } ): Observable<any>
    {

        let localVarQueryParameters = new HttpParams( { encoder: this.encoder } )
        if ( offset !== undefined && offset !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> offset, 'offset' )
        }
        if ( limit !== undefined && limit !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> limit, 'limit' )
        }
        if ( resolved !== undefined && resolved !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> resolved, 'resolved' )
        }
        if ( answered !== undefined && answered !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> answered, 'answered' )
        }
        if ( threadType !== undefined && threadType !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> threadType, 'thread_type' )
        }
        if ( categoryName !== undefined && categoryName !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> categoryName, 'category_name' )
        }
        if ( onlyCount !== undefined && onlyCount !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> onlyCount, 'only_count' )
        }
        if ( contestId !== undefined && contestId !== null )
        {
            localVarQueryParameters = this.addToHttpParams( localVarQueryParameters,
                <any> contestId, 'contest_id' )
        }

        let localVarHeaders = this.defaultHeaders

        let localVarCredential: string | undefined
        // authentication (JWTAccessToken) required
        localVarCredential = this.configuration.lookupCredential( 'JWTAccessToken' )
        if ( localVarCredential )
        {
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
        if ( localVarHttpHeaderAcceptSelected === undefined )
        {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ]
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept( httpHeaderAccepts )
        }
        if ( localVarHttpHeaderAcceptSelected !== undefined )
        {
            localVarHeaders = localVarHeaders.set( 'Accept', localVarHttpHeaderAcceptSelected )
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context
        if ( localVarHttpContext === undefined )
        {
            localVarHttpContext = new HttpContext()
        }


        let responseType_: 'text' | 'json' = 'json'
        if ( localVarHttpHeaderAcceptSelected && localVarHttpHeaderAcceptSelected.startsWith( 'text' ) )
        {
            responseType_ = 'text'
        }

        return this.httpClient.get<FilterThreadsMessagesResponse>( `${ this.configuration.basePath }/messages/participant/threads`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any> responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        )
    }
}